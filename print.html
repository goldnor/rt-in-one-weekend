<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ray Tracing in One Weekend (Rust)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ray Tracing in One Weekend (Rust)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h1>
<p>The content of the original <a href="https://raytracing.github.io">book series</a> is licensed under the <a href="https://github.com/RayTracing/raytracing.github.io/blob/release/COPYING.txt">CC0 license</a>, which permits copying, modification, and distribution. The explanations are copied directly and have been annotated with Rust-specific details where appropriate. Any sentences that include words such as <em>I</em>, <em>me</em>, or <em>mine</em> are from the original authors, Peter Shirley, Trevor David Black or Steve Hollasch. Once again, thank you for this outstanding book series.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="chapters/../imgs/cover/CoverRTW1.jpg" alt="cover" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>I’ve taught many graphics classes over the years. Often I do them in ray tracing, because you are forced to write all the code, but you can still get cool images with no API. I decided to adapt my course notes into a how-to, to get you to a cool program as quickly as possible. It will not be a full-featured ray tracer, but it does have the indirect lighting which has made ray tracing a staple in movies. Follow these steps, and the architecture of the ray tracer you produce will be good for extending to a more extensive ray tracer if you get excited and want to pursue that.</p>
<p>When somebody says “ray tracing” it could mean many things. What I am going to describe is technically a path tracer, and a fairly general one. While the code will be pretty simple (let the computer do the work!) I think you’ll be very happy with the images you can make.</p>
<p>I’ll take you through writing a ray tracer in the order I do it, along with some debugging tips. By the end, you will have a ray tracer that produces some great images. You should be able to do this in a weekend. If you take longer, don’t worry about it. I use C++ as the driving language, but you don’t need to.<sup class="footnote-reference" id="fr-1a-1"><a href="#footnote-1a">1</a></sup> However, I suggest you do, because it’s fast, portable, and most production movie and video game renderers are written in C++. Note that I avoid most “modern features” of C++, but inheritance and operator overloading are too useful for ray tracers to pass on.<sup class="footnote-reference" id="fr-1b-1"><a href="#footnote-1b">2</a></sup></p>
<p>I do not provide the code online, but the code is real and I show all of it except for a few straightforward operators in the vec3 class. I am a big believer in typing in code to learn it, but when code is available I use it, so I only practice what I preach when the code is not available. So don’t ask!
I have left that last part in because it is funny what a 180 I have done. Several readers ended up with subtle errors that were helped when we compared code. So please do type in the code, but you can find the finished source for each book in the <a href="https://github.com/goldnor/rt-books">RayTracing project on GitHub</a>.</p>
<p>A note on the implementing code for these books — our philosophy for the included code prioritizes the following goals:</p>
<ul>
<li>The code should implement the concepts covered in the books.</li>
<li>We use C++, but as simple as possible. Our programming style is very C-like, but we take advantage of modern features where it makes the code easier to use or understand.</li>
<li>Our coding style continues the style established from the original books as much as possible, for continuity.</li>
<li>Line length is kept to 96 characters per line, to keep lines consistent between the codebase and code listings in the books.<sup class="footnote-reference" id="fr-1c-1"><a href="#footnote-1c">3</a></sup></li>
</ul>
<p>The code thus provides a baseline implementation, with tons of improvements left for the reader to enjoy. There are endless ways one can optimize and modernize the code; we prioritize the simple solution.</p>
<p>We assume a little bit of familiarity with vectors (like dot product and vector addition). If you don’t know that, do a little review. If you need that review, or to learn it for the first time, check out the online <em><a href="https://graphicscodex.com/">Graphics Codex</a></em> by Morgan McGuire, <em>Fundamentals of Computer Graphics</em> by Steve Marschner and Peter Shirley, or <em>Computer Graphics: Principles and Practice</em> by J.D. Foley and Andy Van Dam.</p>
<p>See the <a href="https://github.com/goldnor/rt-books/blob/main/README.md">project README</a> file for information about this project, the repository on GitHub, directory structure, building &amp; running, and how to make or reference corrections and contributions.</p>
<p>See our <a href="https://github.com/RayTracing/raytracing.github.io/wiki/Further-Readings">Further Reading wiki page</a> for additional project related resources.</p>
<p>These books have been formatted to print well directly from your browser. We also include PDFs of each book <a href="chapters/TODO">with each release</a>, in the “Assets” section.</p>
<p>If you want to communicate with us, feel free to send us an email at:</p>
<ul>
<li>Peter Shirley, <a href="mailto:ptrshrl@gmail.com">ptrshrl@gmail.com</a></li>
<li>Steve Hollasch, <a href="mailto:steve@hollasch.net">steve@hollasch.net</a></li>
<li>Trevor David Black, <a href="mailto:trevordblack@trevord.black">trevordblack@trevord.black</a></li>
</ul>
<p>Finally, if you run into problems with your implementation, have general questions, or would like to share your own ideas or work, see the GitHub Discussions forum on the GitHub project.</p>
<p>Thanks to everyone who lent a hand on this project. You can find them in the acknowledgments section at the end of this book.</p>
<p>Let’s get on with it!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1a">
<p>There is where Rust comes into play - a fast, reliable language with better ergonomics. This is an unbiased opinion of course *caugh*. <a href="#fr-1a-1">↩</a></p>
</li>
<li id="footnote-1b">
<p>Inheritance is not supported in Rust. In many places simple composition and traits will do the trick. <a href="#fr-1b-1">↩</a></p>
</li>
<li id="footnote-1c">
<p><a href="https://github.com/rust-lang/rustfmt">rustfmt</a> will be used instead, as it is shipped with most IDEs. <a href="#fr-1c-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="the-ppm-image-format"><a class="header" href="#the-ppm-image-format">The PPM Image Format</a></h2>
<p>Whenever you start a renderer, you need a way to see an image. The most straightforward way is to write it to a file. The catch is, there are so many formats. Many of those are complex. I always start with a plain text ppm file. Here’s a nice description from Wikipedia:</p>
<p><img src="chapters/output_an_image/../../imgs/fig-1.01-ppm.jpg" alt="PPM Example" /></p>
<p><strong>Figure 1:</strong> <em>PPM Example</em></p>
<br>
<p>Let’s make some C++ code to output such a thing:<sup class="footnote-reference" id="fr-21a-1"><a href="#footnote-21a">1</a></sup></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Image

    const IMAGE_WIDTH: u32 = 256;
    const IMAGE_HEIGHT: u32 = 256;

    // Render

    println!("P3");
    println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
    println!("255");

    for j in 0..IMAGE_HEIGHT {
        for i in 0..IMAGE_WIDTH {
            let r = i as f64 / (IMAGE_WIDTH - 1) as f64;
            let g = j as f64 / (IMAGE_HEIGHT - 1) as f64;
            let b = 0.0;

            let ir = (255.999 * r) as i32;
            let ig = (255.999 * g) as i32;
            let ib = (255.999 * b) as i32;

            println!("{ir} {ig} {ib}");
        }
    }
}</code></pre></pre>
<p><strong>Listing 1:</strong> [<a href="https://github.com/goldnor/code/blob/c2b88fe22dadf9cba6dff369ee0b1834dd9733d4/src/main.rs">main.rs</a>] <em>Creating your first image</em></p>
<br>
<p>There are some things to note in this code:</p>
<ol>
<li>The pixels are written out in rows.</li>
<li>Every row of pixels is written out left to right.</li>
<li>These rows are written out from top to bottom.</li>
<li>By convention, each of the red/green/blue components are represented internally by real-valued variables that range from 0.0 to 1.0. These must be scaled to integer values between 0 and 255 before we print them out.</li>
<li>Red goes from fully off (black) to fully on (bright red) from left to right, and green goes from fully off at the top (black) to fully on at the bottom (bright green). Adding red and green light together make yellow so we should expect the bottom right corner to be yellow.</li>
</ol>
<hr>
<ol class="footnote-definition"><li id="footnote-21a">
<p>It is Rust code of course. This won't be annotated anymore. <a href="#fr-21a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="creating-an-image-file"><a class="header" href="#creating-an-image-file">Creating an Image File</a></h2>
<p>Because the file is written to the standard output stream, you'll need to redirect it to an image file. Typically this is done from the command-line by using the <code>&gt;</code> redirection operator.</p>
<p>On Windows, you'd get the debug build from CMake running this command:<sup class="footnote-reference" id="fr-22a-1"><a href="#footnote-22a">1</a></sup></p>
<pre><code class="language-shell">cargo b
</code></pre>
<p>Then run your newly-built program like so:<sup class="footnote-reference" id="fr-22b-1"><a href="#footnote-22b">2</a></sup></p>
<pre><code class="language-shell">cargo r &gt; image.ppm
</code></pre>
<p>Later, it will be better to run optimized builds for speed. In that case, you would build like this:</p>
<pre><code class="language-shell">cargo b -r
</code></pre>
<p>and would run the optimized program like this:</p>
<pre><code class="language-shell">cargo r -r
</code></pre>
<p>The examples above assume that you are building with CMake, using the same approach as the CMakeLists.txt file in the included source. Use whatever build environment (and language) you're most comfortable with.</p>
<p>On Mac or Linux, release build, you would launch the program like this:<sup class="footnote-reference" id="fr-22c-1"><a href="#footnote-22c">3</a></sup></p>
<pre><code class="language-shell">cargo r &gt; image.ppm
</code></pre>
<p>Complete building and running instructions can be found in the <a href="https://github.com/goldnor/rt-books/blob/main/README.md">project README</a>.</p>
<p>Opening the output file (in <code>ToyViewer</code> on my Mac, but try it in your favorite image viewer and Google “ppm viewer” if your viewer doesn’t support it) shows this result:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/output_an_image/../../imgs/img-1.01-first-ppm-image.png" alt="First PPM image">
<p><strong>Image 1:</strong> <em>First PPM image</em></p>
<br>
<p>Hooray! This is the graphics “hello world”. If your image doesn’t look like that, open the output file in a text editor and see what it looks like. It should start something like this:</p>
<pre><code class="language-ppm">P3
256 256
255
0 0 0
1 0 0
2 0 0
3 0 0
4 0 0
5 0 0
6 0 0
7 0 0
8 0 0
9 0 0
10 0 0
11 0 0
12 0 0
...
</code></pre>
<p><strong>Listing 2:</strong> <em>First image output</em></p>
<br>
<p>If your PPM file doesn't look like this, then double-check your formatting code. If it <em>does</em> look like this but fails to render, then you may have line-ending differences or something similar that is confusing your image viewer. To help debug this, you can find a file <code>test.ppm</code> in the <code>images</code> directory of the Github project. This should help to ensure that your viewer can handle the PPM format and to use as a comparison against your generated PPM file.</p>
<p>Some readers have reported problems viewing their generated files on Windows. In this case, the problem is often that the PPM is written out as UTF-16, often from PowerShell. If you run into this problem, see <a href="https://github.com/RayTracing/raytracing.github.io/discussions/1114">Discussion 1114</a> for help with this issue.</p>
<p>If everything displays correctly, then you're pretty much done with system and IDE issues — everything in the remainder of this series uses this same simple mechanism for generated rendered images.</p>
<p>If you want to produce other image formats, I am a fan of <code>stb_image.h</code>, a header-only image library available on GitHub at <a href="https://github.com/nothings/stb">https://github.com/nothings/stb</a>.<sup class="footnote-reference" id="fr-22d-1"><a href="#footnote-22d">4</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-22a">
<p>We are not using CMake; we are relying on the standard cargo build tool. <a href="#fr-22a-1">↩</a></p>
</li>
<li id="footnote-22b">
<p>You can skip the building step since it is part of the run command (or <code>r</code> for short). <a href="#fr-22b-1">↩</a></p>
</li>
<li id="footnote-22c">
<p>It is the same as for Windows. <a href="#fr-22c-1">↩</a></p>
</li>
<li id="footnote-22d">
<p>Rust crate alternativ: <a href="https://crates.io/crates/stb_image">https://crates.io/crates/stb_image</a>. <a href="#fr-22d-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="adding-a-progress-indicator"><a class="header" href="#adding-a-progress-indicator">Adding a Progress Indicator</a></h2>
<p>Before we continue, let's add a progress indicator to our output. This is a handy way to track the progress of a long render, and also to possibly identify a run that's stalled out due to an infinite loop or other problem.</p>
<p>Our program outputs the image to the standard output stream (<code>std::cout</code>), so leave that alone and instead write to the logging output stream (<code>std::clog</code>):<sup class="footnote-reference" id="fr-23a-1"><a href="#footnote-23a">1</a></sup></p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index af636bc..00cad27 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,26 +1,29 @@
</span><span class="boring"> fn main() {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const IMAGE_WIDTH: u32 = 256;
</span><span class="boring">     const IMAGE_HEIGHT: u32 = 256;
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span>+    env_logger::init();
     println!("P3");
     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
     println!("255");
 
     for j in 0..IMAGE_HEIGHT {
+        log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
         for i in 0..IMAGE_WIDTH {
             let r = i as f64 / (IMAGE_WIDTH - 1) as f64;
             let g = j as f64 / (IMAGE_HEIGHT - 1) as f64;
             let b = 0.0;
 
             let ir = (255.999 * r) as i32;
             let ig = (255.999 * g) as i32;
             let ib = (255.999 * b) as i32;
 
             println!("{ir} {ig} {ib}");
         }
     }
+    log::info!("Done.");
<span class="boring"> }</span></code></pre>
<p><strong>Listing 3:</strong> [<a href="https://github.com/goldnor/code/blob/5c4dfec5c8122b0a6df768027866c4a526da8677/src/main.rs">main.rs</a>] <em>Main render loop with progress reporting</em></p>
<br>
<p>Now when running, you'll see a running count of the number of scanlines remaining. Hopefully this runs so fast that you don't even see it! Don't worry — you'll have lots of time in the future to watch a slowly updating progress line as we expand our ray tracer.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-23a">
<p>The <a href="https://crates.io/crates/log">log crate</a> with the <a href="https://crates.io/crates/env_logger">env_logger</a> implementation is a good alternative to <code>std::clog</code>. Run <code>RUST_LOG=info cargo r &gt; image.ppm</code> for the log output. <a href="#fr-23a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="the-vec3-class-1"><a class="header" href="#the-vec3-class-1">The vec3 Class <sup class="footnote-reference" id="fr-3a-1"><a href="#footnote-3a">1</a></sup></a></h1>
<p>Almost all graphics programs have some class(es) for storing geometric vectors and colors. In many systems these vectors are 4D (3D position plus a homogeneous coordinate for geometry, or RGB plus an alpha transparency component for colors). For our purposes, three coordinates suffice. We’ll use the same class vec3 for colors, locations, directions, offsets, whatever. Some people don’t like this because it doesn’t prevent you from doing something silly, like subtracting a position from a color. They have a good point, but we’re going to always take the “less code” route when not obviously wrong. In spite of this, we do declare two aliases for vec3: point3 and color. Since these two types are just aliases for vec3, you won't get warnings if you pass a color to a function expecting a point3, and nothing is stopping you from adding a point3 to a color, but it makes the code a little bit easier to read and to understand.</p>
<p>We define the vec3 class in the top half of a new vec3.h header file, and define a set of useful vector utility functions in the bottom half:</p>
<pre><code class="language-rust norun noplayground">use std::{
    fmt::Display,
    ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
};

#[derive(Debug, Default, Clone, Copy)]
pub struct Vec3 {
    pub e: [f64; 3],
}

pub type Point3 = Vec3;

impl Vec3 {
    pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
        Self { e: [e0, e1, e2] }
    }

    pub fn x(&amp;self) -&gt; f64 {
        self.e[0]
    }

    pub fn y(&amp;self) -&gt; f64 {
        self.e[1]
    }

    pub fn z(&amp;self) -&gt; f64 {
        self.e[2]
    }

    pub fn length(&amp;self) -&gt; f64 {
        f64::sqrt(self.length_squared())
    }

    pub fn length_squared(&amp;self) -&gt; f64 {
        self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
    }
}

impl Neg for Vec3 {
    type Output = Self;

    fn neg(self) -&gt; Self::Output {
        Self::Output {
            e: self.e.map(|e| -e),
        }
    }
}

impl Index&lt;usize&gt; for Vec3 {
    type Output = f64;

    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self.e[index]
    }
}

impl IndexMut&lt;usize&gt; for Vec3 {
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
        &amp;mut self.e[index]
    }
}

impl AddAssign for Vec3 {
    fn add_assign(&amp;mut self, rhs: Self) {
        self.e[0] += rhs.e[0];
        self.e[1] += rhs.e[1];
        self.e[2] += rhs.e[2];
    }
}

impl MulAssign&lt;f64&gt; for Vec3 {
    fn mul_assign(&amp;mut self, rhs: f64) {
        self.e[0] *= rhs;
        self.e[1] *= rhs;
        self.e[2] *= rhs;
    }
}

impl DivAssign&lt;f64&gt; for Vec3 {
    fn div_assign(&amp;mut self, rhs: f64) {
        self.mul_assign(1.0 / rhs);
    }
}

impl Display for Vec3 {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
    }
}

impl Add for Vec3 {
    type Output = Self;

    fn add(self, rhs: Self) -&gt; Self::Output {
        Self::Output {
            e: [
                self.e[0] + rhs.e[0],
                self.e[1] + rhs.e[1],
                self.e[2] + rhs.e[2],
            ],
        }
    }
}

impl Sub for Vec3 {
    type Output = Self;

    fn sub(self, rhs: Self) -&gt; Self::Output {
        Self::Output {
            e: [
                self.e[0] - rhs.e[0],
                self.e[1] - rhs.e[1],
                self.e[2] - rhs.e[2],
            ],
        }
    }
}

impl Mul for Vec3 {
    type Output = Self;

    fn mul(self, rhs: Self) -&gt; Self::Output {
        Self::Output {
            e: [
                self.e[0] * rhs.e[0],
                self.e[1] * rhs.e[1],
                self.e[2] * rhs.e[2],
            ],
        }
    }
}

impl Mul&lt;f64&gt; for Vec3 {
    type Output = Self;

    fn mul(self, rhs: f64) -&gt; Self::Output {
        Self::Output {
            e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
        }
    }
}

impl Mul&lt;Vec3&gt; for f64 {
    type Output = Vec3;

    fn mul(self, rhs: Vec3) -&gt; Self::Output {
        rhs.mul(self)
    }
}

impl Div&lt;f64&gt; for Vec3 {
    type Output = Self;

    fn div(self, rhs: f64) -&gt; Self::Output {
        self * (1.0 / rhs)
    }
}

#[inline]
pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
    u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
}

#[inline]
pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
    Vec3::new(
        u.e[1] * v.e[2] - u.e[2] * v.e[1],
        u.e[2] * v.e[0] - u.e[0] * v.e[2],
        u.e[0] * v.e[1] - u.e[1] * v.e[0],
    )
}

#[inline]
pub fn unit_vector(v: Vec3) -&gt; Vec3 {
    v / v.length()
}</code></pre>
<p><strong>Listing 4:</strong> [<a href="https://github.com/goldnor/code/blob/400e8e91847d5b2fbde6eb17432cbbe49794e28d/src/vec3.rs">vec3.rs</a>] <em>vec3 definitions and helper functions</em></p>
<br>
<p>We use double here, but some ray tracers use float. double has greater precision and range, but is twice the size compared to float. This increase in size may be important if you're programming in limited memory conditions (such as hardware shaders). Either one is fine — follow your own tastes.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-3a">
<p>There are no classes in Rust. They are replaced with structs. <a href="#fr-3a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="color-utility-functions"><a class="header" href="#color-utility-functions">Color Utility Functions</a></h2>
<p>Using our new <code>vec3</code> class, we'll create a new <code>color.h</code> header file and define a utility function that writes a single pixel's color out to the standard output stream.</p>
<pre><code class="language-rust norun noplayground">use crate::vec3::Vec3;

pub type Color = Vec3;

pub fn write_color(mut out: impl std::io::Write, pixel_color: Color) -&gt; std::io::Result&lt;()&gt; {
    let r = pixel_color.x();
    let g = pixel_color.y();
    let b = pixel_color.z();

    let rbyte = (255.999 * r) as i32;
    let gbyte = (255.999 * g) as i32;
    let bbyte = (255.999 * b) as i32;

    writeln!(out, "{rbyte} {gbyte} {bbyte}")
}</code></pre>
<p><strong>Listing 5:</strong> [<a href="https://github.com/goldnor/code/blob/6a4c63a317edcf4bb154fff3f817c561c2ed3aa9/src/color.rs">color.rs</a>] <em>color utility functions</em></p>
<br>
<p>Now we can change our main to use both of these:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 00cad27..bb37ee6 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,29 +1,30 @@
</span><span class="boring">-fn main() {
</span>+use code::color::{Color, write_color};
+
+fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
     // Image
 
     const IMAGE_WIDTH: u32 = 256;
     const IMAGE_HEIGHT: u32 = 256;
 
     // Render
 
     env_logger::init();
     println!("P3");
     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
     println!("255");
 
     for j in 0..IMAGE_HEIGHT {
         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
         for i in 0..IMAGE_WIDTH {
<span class="boring">-            let r = i as f64 / (IMAGE_WIDTH - 1) as f64;
</span><span class="boring">-            let g = j as f64 / (IMAGE_HEIGHT - 1) as f64;
</span><span class="boring">-            let b = 0.0;
</span><span class="boring">-
</span><span class="boring">-            let ir = (255.999 * r) as i32;
</span><span class="boring">-            let ig = (255.999 * g) as i32;
</span><span class="boring">-            let ib = (255.999 * b) as i32;
</span><span class="boring">-
</span><span class="boring">-            println!("{ir} {ig} {ib}");
</span>+            let pixel_color = Color::new(
+                i as f64 / (IMAGE_WIDTH - 1) as f64,
+                j as f64 / (IMAGE_HEIGHT - 1) as f64,
+                0.0,
+            );
+            write_color(std::io::stdout(), pixel_color)?;
         }
     }
     log::info!("Done.");
+
+    Ok(())
 }</code></pre>
<p><strong>Listing 6:</strong> [<a href="https://github.com/goldnor/code/blob/7e3d601b91c93177f3b3d1ed98aa69d8ecf4ffee/src/main.rs">main.rs</a>)] <em>Final code for the first PPM image</em></p>
<br>
<p>And you should get the exact same picture as before.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-ray-class"><a class="header" href="#the-ray-class">The ray Class</a></h2>
<p>The one thing that all ray tracers have is a ray class and a computation of what color is seen along a ray. Let’s think of a ray as a function \( \mathbf{P} (t) = \mathbf{A} + t \mathbf{b} \). Here \( \mathbf{P} \) is a 3D position along a line in 3D. \( \mathbf{A} \) is the ray origin and \( \mathbf{b} \) is the ray direction. The ray parameter \( t \) is a real number (double in the code). Plug in a different \( t \) and \( \mathbf{P} (t) \) moves the point along the ray. Add in negative \( t \) values and you can go anywhere on the 3D line. For positive \( t \), you get only the parts in front of \( \mathbf{A} \), and this is what is often called a half-line or a ray.</p>
<p><img src="chapters/rays_a_simple_camera_and_background/../../imgs/fig-1.02-lerp.jpg" alt="Linear interpolation" /></p>
<p><strong>Figure 2:</strong> <em>Linear interpolation</em></p>
<br>
<p>We can represent the idea of a ray as a class, and represent the function \( \mathbf{P} (t) \) as a function that we'll call <code>ray::at(t)</code>:</p>
<pre><code class="language-rust norun noplayground">use crate::vec3::{Point3, Vec3};

#[derive(Debug, Default, Clone, Copy)]
pub struct Ray {
    origin: Point3,
    direction: Vec3,
}

impl Ray {
    pub fn new(origin: Point3, direction: Vec3) -&gt; Self {
        Self { origin, direction }
    }

    pub fn origin(&amp;self) -&gt; Point3 {
        self.origin
    }

    pub fn direction(&amp;self) -&gt; Vec3 {
        self.direction
    }

    pub fn at(&amp;self, t: f64) -&gt; Point3 {
        self.origin + t * self.direction
    }
}</code></pre>
<p><strong>Listing 7:</strong> [<a href="https://github.com/goldnor/code/blob/b54170d548e41ff6ea02b4eceb59269ee20b2a56/src/ray.rs">ray.rs</a>] <em>The ray class</em></p>
<br>
<p>(For those unfamiliar with C++, the functions ray::origin() and ray::direction() both return an immutable reference to their members. Callers can either just use the reference directly, or make a mutable copy depending on their needs.) <sup class="footnote-reference" id="fr-41a-1"><a href="#footnote-41a">1</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-41a">
<p>The careful reader may have noticed that, in the Rust approach, both the <code>Vec3</code> and <code>Ray</code> structs implement Copy. This method is generally more common than returning a reference and cloning it for mutability when needed. <a href="#fr-41a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="sending-rays-into-the-scene"><a class="header" href="#sending-rays-into-the-scene">Sending Rays Into the Scene</a></h2>
<p>Now we are ready to turn the corner and make a ray tracer. At its core, a ray tracer sends rays through pixels and computes the color seen in the direction of those rays. The involved steps are</p>
<ol>
<li>Calculate the ray from the “eye” through the pixel,</li>
<li>Determine which objects the ray intersects, and</li>
<li>Compute a color for the closest intersection point.</li>
</ol>
<p>When first developing a ray tracer, I always do a simple camera for getting the code up and running.</p>
<p>I’ve often gotten into trouble using square images for debugging because I transpose 𝑥 and 𝑦 too often, so we’ll use a non-square image. A square image has a 1∶1 aspect ratio, because its width is the same as its height. Since we want a non-square image, we'll choose 16∶9 because it's so common. A 16∶9 aspect ratio means that the ratio of image width to image height is 16∶9. Put another way, given an image with a 16∶9 aspect ratio,</p>
<p>\[ width\,/\,height=16\,/\,9=1.7778 \]</p>
<p>For a practical example, an image 800 pixels wide by 400 pixels high has a 2∶1 aspect ratio.</p>
<p>The image's aspect ratio can be determined from the ratio of its width to its height. However, since we have a given aspect ratio in mind, it's easier to set the image's width and the aspect ratio, and then using this to calculate for its height. This way, we can scale up or down the image by changing the image width, and it won't throw off our desired aspect ratio. We do have to make sure that when we solve for the image height the resulting height is at least 1.</p>
<p>In addition to setting up the pixel dimensions for the rendered image, we also need to set up a virtual <em>viewport</em> through which to pass our scene rays. The viewport is a virtual rectangle in the 3D world that contains the grid of image pixel locations. If pixels are spaced the same distance horizontally as they are vertically, the viewport that bounds them will have the same aspect ratio as the rendered image. The distance between two adjacent pixels is called the pixel spacing, and square pixels is the standard.</p>
<p>To start things off, we'll choose an arbitrary viewport height of 2.0, and scale the viewport width to give us the desired aspect ratio. Here's a snippet of what this code will look like:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use code::color::{Color, write_color};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    // Image
</span><span class="boring">
</span>    const ASPECT_RATIO: f64 = 16.0 / 9.0;
    const IMAGE_WIDTH: i32 = 400;

    // Calculate the image height, and ensure that it's at least 1.
    const IMAGE_HEIGHT: i32 = {
        let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
        if image_height &lt; 1 { 1 } else { image_height }
    };

    // Viewport widths less than one are ok since they are real valued.
    let viewport_height = 2.0;
    let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
<span class="boring">
</span><span class="boring">    // Render
</span><span class="boring">
</span><span class="boring">    env_logger::init();
</span><span class="boring">    println!("P3");
</span><span class="boring">    println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">    println!("255");
</span><span class="boring">
</span><span class="boring">    for j in 0..IMAGE_HEIGHT {
</span><span class="boring">        log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">        for i in 0..IMAGE_WIDTH {
</span><span class="boring">            let pixel_color = Color::new(
</span><span class="boring">                i as f64 / (IMAGE_WIDTH - 1) as f64,
</span><span class="boring">                j as f64 / (IMAGE_HEIGHT - 1) as f64,
</span><span class="boring">                0.0,
</span><span class="boring">            );
</span><span class="boring">            write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    log::info!("Done.");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 8:</strong> <em>Rendered image setup</em></p>
<br>
<p>If you're wondering why we don't just use <code>aspect_ratio</code> when computing <code>viewport_width</code>, it's because the value set to <code>aspect_ratio</code> is the ideal ratio, it may not be the <em>actual</em> ratio between <code>image_width</code> and <code>image_height</code>. If <code>image_height</code> was allowed to be real valued—rather than just an integer—then it would be fine to use <code>aspect_ratio</code>. But the <em>actual</em> ratio between <code>image_width</code> and <code>image_height</code> can vary based on two parts of the code. First, <code>image_height</code> is rounded down to the nearest integer, which can increase the ratio. Second, we don't allow <code>image_height</code> to be less than one, which can also change the actual aspect ratio.</p>
<p>Note that <code>aspect_ratio</code> is an ideal ratio, which we approximate as best as possible with the integer-based ratio of image width over image height. In order for our viewport proportions to exactly match our image proportions, we use the calculated image aspect ratio to determine our final viewport width.</p>
<p>Next we will define the camera center: a point in 3D space from which all scene rays will originate (this is also commonly referred to as the <em>eye point</em>). The vector from the camera center to the viewport center will be orthogonal to the viewport. We'll initially set the distance between the viewport and the camera center point to be one unit. This distance is often referred to as the <em>focal length</em>.</p>
<p>For simplicity we'll start with the camera center at \( (0,0,0) \). We'll also have the y-axis go up, the x-axis to the right, and the negative z-axis pointing in the viewing direction. (This is commonly referred to as <em>right-handed coordinates</em>.)</p>
<p><img src="chapters/rays_a_simple_camera_and_background/../../imgs/fig-1.03-cam-geom.jpg" alt="Camera geometry" /></p>
<p><strong>Figure 3:</strong> <em>Camera geometry</em></p>
<br>
<p>Now the inevitable tricky part. While our 3D space has the conventions above, this conflicts with our image coordinates, where we want to have the zeroth pixel in the top-left and work our way down to the last pixel at the bottom right. This means that our image coordinate Y-axis is inverted: Y increases going down the image.</p>
<p>As we scan our image, we will start at the upper left pixel (pixel \( 0,0 \)), scan left-to-right across each row, and then scan row-by-row, top-to-bottom. To help navigate the pixel grid, we'll use a vector from the left edge to the right edge (\( \mathbf{V_u} \)), and a vector from the upper edge to the lower edge (\( \mathbf{V_v} \)).</p>
<p>Our pixel grid will be inset from the viewport edges by half the pixel-to-pixel distance. This way, our viewport area is evenly divided into width × height identical regions. Here's what our viewport and pixel grid look like:</p>
<p><img src="chapters/rays_a_simple_camera_and_background/../../imgs/fig-1.04-pixel-grid.jpg" alt="Viewport and pixel grid" /></p>
<p><strong>Figure 4:</strong> <em>Viewport and pixel grid</em></p>
<br>
<p>In this figure, we have the viewport, the pixel grid for a 7×5 resolution image, the viewport upper left corner \( \mathbf{Q} \), the pixel \( \mathbf{P_{0,0}} \) location, the viewport vector \( \mathbf{V_u} \) (<code>viewport_u</code>), the viewport vector \( \mathbf{V_v} \) (<code>viewport_v</code>), and the pixel delta vectors \( \mathbf{\Delta u} \) and \( \mathbf{\Delta v} \).</p>
<p>Drawing from all of this, here's the code that implements the camera. We'll stub in a function <code>ray_color(const ray&amp; r)</code> that returns the color for a given scene ray — which we'll set to always return black for now.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index bb37ee6..8104ae8 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,30 +1,65 @@
</span><span class="boring">-use code::color::{Color, write_color};
</span>+use code::{
+    color::{Color, write_color},
+    ray::Ray,
+    vec3::{Point3, Vec3},
+};
+
+fn ray_color(r: Ray) -&gt; Color {
+    Color::new(0.0, 0.0, 0.0)
+}
 
 fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
     // Image
 
<span class="boring">-    const IMAGE_WIDTH: u32 = 256;
</span><span class="boring">-    const IMAGE_HEIGHT: u32 = 256;
</span>+    const ASPECT_RATIO: f64 = 16.0 / 9.0;
+    const IMAGE_WIDTH: i32 = 400;
+
+    // Calculate the image height, and ensure that it's at least 1.
+    const IMAGE_HEIGHT: i32 = {
+        let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
+        if image_height &lt; 1 { 1 } else { image_height }
+    };
+
+    // Camera
+
+    let focal_length = 1.0;
+    let viewport_height = 2.0;
+    let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
+    let camera_center = Point3::new(0.0, 0.0, 0.0);
+
+    // Calculate the vectors across the horizontal and down the vertical viewport edges.
+    let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
+    let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
+
+    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
+    let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
+    let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
+
+    // Calculate the location of the upper left pixel.
+    let viewport_upper_left =
+        camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
+    let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
 
     // Render
 
     env_logger::init();
     println!("P3");
     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
     println!("255");
 
     for j in 0..IMAGE_HEIGHT {
         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
         for i in 0..IMAGE_WIDTH {
<span class="boring">-            let pixel_color = Color::new(
</span><span class="boring">-                i as f64 / (IMAGE_WIDTH - 1) as f64,
</span><span class="boring">-                j as f64 / (IMAGE_HEIGHT - 1) as f64,
</span><span class="boring">-                0.0,
</span><span class="boring">-            );
</span>+            let pixel_center =
+                pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
+            let ray_direction = pixel_center - camera_center;
+            let r = Ray::new(camera_center, ray_direction);
+
+            let pixel_color = ray_color(r);
             write_color(std::io::stdout(), pixel_color)?;
         }
     }
     log::info!("Done.");
 
     Ok(())
 }</code></pre>
<p><strong>Listing 9:</strong> [<a href="https://github.com/goldnor/code/blob/8f5c9042f86a1a778ef557f05162e6512ef2a85f/src/main.rs">main.rs</a>] <em>Creating scene rays</em></p>
<br>
<p>Notice that in the code above, I didn't make <code>ray_direction</code> a unit vector, because I think not doing that makes for simpler and slightly faster code.</p>
<p>Now we'll fill in the <code>ray_color(ray)</code> function to implement a simple gradient. This function will linearly blend white and blue depending on the height of the \( y \) coordinate <em>after</em> scaling the ray direction to unit length (so \( -1.0 &lt; y &lt; 1.0 \)). Because we're looking at the 𝑦 height after normalizing the vector, you'll notice a horizontal gradient to the color in addition to the vertical gradient.</p>
<p>I'll use a standard graphics trick to linearly scale \( 0.0 \leq a \leq 1.0 \). When \( a = 1.0 \), I want blue. When \( a = 0.0 \), I want white. In between, I want a blend. This forms a “linear blend”, or “linear interpolation”. This is commonly referred to as a <em>lerp</em> between two values. A lerp is always of the form</p>
<p>\[ blendedValue = (1 − 𝑎) \cdot startValue + 𝑎 \cdot endValue, \]</p>
<p>with \( a \) going from zero to one.</p>
<p>Putting all this together, here's what we get:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 8104ae8..f31dc16 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,65 +1,67 @@
</span> use code::{
     color::{Color, write_color},
     ray::Ray,
<span class="boring">-    vec3::{Point3, Vec3},
</span>+    vec3::{Point3, Vec3, unit_vector},
 };
 
 fn ray_color(r: Ray) -&gt; Color {
<span class="boring">-    Color::new(0.0, 0.0, 0.0)
</span>+    let unit_direction = unit_vector(r.direction());
+    let a = 0.5 * (unit_direction.y() + 1.0);
+    (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
<span class="boring"> 
</span><span class="boring"> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     log::info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 10:</strong> [<a href="https://github.com/goldnor/code/blob/d38202d1d50207cb9ff4bd6721dd88167e06feb6/src/main.rs">main.rs</a>] <em>Rendering a blue-to-white gradient</em></p>
<br>
<p>In our case this produces:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/rays_a_simple_camera_and_background/../../imgs/img-1.02-blue-to-white.png" alt="A blue-to-white gradient depending on ray Y coordinate">
<p><strong>Image 2:</strong> <em>A blue-to-white gradient depending on ray Y coordinate</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-sphere"><a class="header" href="#adding-a-sphere">Adding a Sphere</a></h1>
<p>Let’s add a single object to our ray tracer. People often use spheres in ray tracers because calculating whether a ray hits a sphere is relatively simple.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ray-sphere-intersection"><a class="header" href="#ray-sphere-intersection">Ray-Sphere Intersection</a></h2>
<p>The equation for a sphere of radius \( r \) that is centered at the origin is an important mathematical equation:</p>
<p>\[ x^2 + y^2 + z^2 = r^2 \]</p>
<p>You can also think of this as saying that if a given point \( (x, y, z) \) is on the surface of the sphere, then \( x^2 + y^2 + z^2 = r^2 \). If a given point \( (x, y, z) \) is <em>inside</em> the sphere, then \( x^2 + y^2 + z^2 &lt; r^2 \), and if a given point \( (x, y, z) \) is <em>outside</em> the sphere, then \( x^2 + y^2 + z^2 &gt; r^2 \).</p>
<p>If we want to allow the sphere center to be at an arbitrary point \( (C_x, C_y, C_z) \), then the equation becomes a lot less nice:</p>
<p>\[ (C_x - x)^2 + (C_y - y)^2 + (C_z - z)^2 = r^2 \]</p>
<p>In graphics, you almost always want your formulas to be in terms of vectors so that all the \( x/y/z \) stuff can be simply represented using a <code>vec3</code> class. You might note that the vector from point \( \mathbf{P} = (x, y, z) \) to center \( \mathbf{C} = (C_x, C_y, C_z) \) is \( (\mathbf{C} - \mathbf{P}) \).</p>
<p>If we use the definition of the dot product:</p>
<p>\[ (\mathbf{C} - \mathbf{P}) \cdot (\mathbf{C} - \mathbf{P}) = (C_x - x)^2 + (C_y - y)^2 + (C_z - z)^2 \]
Then we can rewrite the equation of the sphere in vector form as:</p>
<p>\[ (\mathbf{C} - \mathbf{P}) \cdot (\mathbf{C} - \mathbf{P}) = r^2 \]</p>
<p>We can read this as “any point \( \mathbf{P} \)  that satisfies this equation is on the sphere”. We want to know if our ray \( \mathbf{P}(t) = \mathbf{Q} + t \mathbf{d} \) ever hits the sphere anywhere. If it does hit the sphere, there is some \( t \) for which \( \mathbf{P}(t) \) satisfies the sphere equation. So we are looking for any \( t \) where this is true:</p>
<p>\[ (\mathbf{C} - \mathbf{P}(t)) \cdot (\mathbf{C} - \mathbf{P}(t)) = r^2 \]</p>
<p>which can be found by replacing \( \mathbf{P}(t) \) with its expanded form:</p>
<p>\[ (\mathbf{C} - (\mathbf{Q} + t \mathbf{d})) \cdot (\mathbf{C} - (\mathbf{Q} + t \mathbf{d})) = r^2 \]</p>
<p>We have three vectors on the left dotted by three vectors on the right. If we solved for the full dot product we would get nine vectors. You can definitely go through and write everything out, but we don't need to work that hard. If you remember, we want to solve for \( t \), so we'll separate the terms based on whether there is a \( t \) or not:</p>
<p>\[ (-t \mathbf{d} + (\mathbf{C} - \mathbf{Q})) \cdot (-t \mathbf{d} + (\mathbf{C} - \mathbf{Q})) = r^2 \]</p>
<p>And now we follow the rules of vector algebra to distribute the dot product:</p>
<p>\[ t^2 \mathbf{d} \cdot \mathbf{d} - 2 t \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) + (\mathbf{C} - \mathbf{Q}) \cdot (\mathbf{C} - \mathbf{Q}) = r^2 \]</p>
<p>Move the square of the radius over to the left hand side:</p>
<p>\[ t^2 \mathbf{d} \cdot \mathbf{d} - 2 t \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) + (\mathbf{C} - \mathbf{Q}) \cdot (\mathbf{C} - \mathbf{Q}) - r^2 = 0 \]</p>
<p>It's hard to make out what exactly this equation is, but the vectors and \( r \) in that equation are all constant and known. Furthermore, the only vectors that we have are reduced to scalars by dot product. The only unknown is \( t \), and we have a \( t^2 \), which means that this equation is quadratic. You can solve for a quadratic equation \( ax^2 + bx + c = 0 \) by using the quadratic formula:</p>
<p>\[ \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} \]</p>
<p>So solving for \( t \) in the ray-sphere intersection equation gives us these values for \( a \), \( b \), and \( c \):</p>
<p>\[ a = \mathbf{d} \cdot \mathbf{d} \]
\[ b = -2 \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) \]
\[ c = (\mathbf{C} - \mathbf{Q}) \cdot (\mathbf{C} - \mathbf{Q}) - r^2 \]</p>
<p>Using all of the above you can solve for \( t \), but there is a square root part that can be either positive (meaning two real solutions), negative (meaning no real solutions), or zero (meaning one real solution). In graphics, the algebra almost always relates very directly to the geometry. What we have is:</p>
<p><img src="chapters/adding_a_sphere/../../imgs/fig-1.05-ray-sphere.jpg" alt="Ray-sphere intersection results" /></p>
<p><strong>Figure 5:</strong> <em>Ray-sphere intersection results</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-our-first-raytraced-image"><a class="header" href="#creating-our-first-raytraced-image">Creating Our First Raytraced Image</a></h2>
<p>If we take that math and hard-code it into our program, we can test our code by placing a small sphere at \( −1 \) on the z-axis and then coloring red any pixel that intersects it.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index f31dc16..e3d9091 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,67 +1,81 @@
</span> use code::{
     color::{Color, write_color},
     ray::Ray,
<span class="boring">-    vec3::{Point3, Vec3, unit_vector},
</span>+    vec3::{Point3, Vec3, dot, unit_vector},
 };
 
+fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; bool {
+    let oc = center - r.origin();
+    let a = dot(r.direction(), r.direction());
+    let b = -2.0 * dot(r.direction(), oc);
+    let c = dot(oc, oc) - radius * radius;
+    let discriminant = b * b - 4.0 * a * c;
+
+    discriminant &gt;= 0.0
+}
+
 fn ray_color(r: Ray) -&gt; Color {
+    if hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
+        return Color::new(1.0, 0.0, 0.0);
+    }
+
     let unit_direction = unit_vector(r.direction());
     let a = 0.5 * (unit_direction.y() + 1.0);
     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
<span class="boring"> 
</span><span class="boring"> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     log::info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 11:</strong> [<a href="https://github.com/goldnor/code/blob/2cf21871a39a309bce0edfb75464389bba9782f4/src/main.rs">main.rs</a>] <em>Rendering a red sphere</em></p>
<br>
<p>What we get is this:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/adding_a_sphere/../../imgs/img-1.03-red-sphere.png" alt="A simple red sphere">
<p><strong>Image 3:</strong> <em>A simple red sphere</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="shading-with-surface-normals"><a class="header" href="#shading-with-surface-normals">Shading with Surface Normals</a></h2>
<p>First, let’s get ourselves a surface normal so we can shade. This is a vector that is perpendicular to the surface at the point of intersection.</p>
<p>We have a key design decision to make for normal vectors in our code: whether normal vectors will have an arbitrary length, or will be normalized to unit length.</p>
<p>It is tempting to skip the expensive square root operation involved in normalizing the vector, in case it's not needed. In practice, however, there are three important observations. First, if a unit-length normal vector is <em>ever</em> required, then you might as well do it up front once, instead of over and over again “just in case” for every location where unit-length is required. Second, we <em>do</em> require unit-length normal vectors in several places. Third, if you require normal vectors to be unit length, then you can often efficiently generate that vector with an understanding of the specific geometry class, in its constructor, or in the <code>hit()</code> function. For example, sphere normals can be made unit length simply by dividing by the sphere radius, avoiding the square root entirely.</p>
<p>Given all of this, we will adopt the policy that all normal vectors will be of unit length.</p>
<p>For a sphere, the outward normal is in the direction of the hit point minus the center:</p>
<p><img src="chapters/surface_normals_and_multiple_objects/../../imgs/fig-1.06-sphere-normal.jpg" alt="Sphere surface-normal geometry" /></p>
<p><strong>Figure 6:</strong> <em>Sphere surface-normal geometry</em></p>
<br>
<p>On the earth, this means that the vector from the earth’s center to you points straight up. Let’s throw that into the code now, and shade it. We don’t have any lights or anything yet, so let’s just visualize the normals with a color map. A common trick used for visualizing normals (because it’s easy and somewhat intuitive to assume \( \mathbf{n} \) is a unit length vector — so each component is between \( −1 \) and \( 1 \)) is to map each component to the interval from \( 0 \) to \( 1 \), and then map \( (x, y, z) \) to \( (red, green, blue) \). For the normal, we need the hit point, not just whether we hit or not (which is all we're calculating at the moment). We only have one sphere in the scene, and it's directly in front of the camera, so we won't worry about negative values of \( t \) yet. We'll just assume the closest hit point (smallest \( t \)) is the one that we want. These changes in the code let us compute and visualize \( \mathbf{n} \):</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index e3d9091..405ca4b 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,81 +1,82 @@
</span> use code::{
     color::{Color, write_color},
     ray::Ray,
     vec3::{Point3, Vec3, dot, unit_vector},
 };
 
<span class="boring">-fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; bool {
</span>+fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; Option&lt;f64&gt; {
     let oc = center - r.origin();
     let a = dot(r.direction(), r.direction());
     let b = -2.0 * dot(r.direction(), oc);
     let c = dot(oc, oc) - radius * radius;
     let discriminant = b * b - 4.0 * a * c;
 
<span class="boring">-    discriminant &gt;= 0.0
</span>+    (discriminant &gt;= 0.0).then(|| (-b - f64::sqrt(discriminant)) / (2.0 * a))
 }
 
 fn ray_color(r: Ray) -&gt; Color {
<span class="boring">-    if hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
</span><span class="boring">-        return Color::new(1.0, 0.0, 0.0);
</span>+    if let Some(t) = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
+        let n = unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
+        return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
     }
 
     let unit_direction = unit_vector(r.direction());
     let a = 0.5 * (unit_direction.y() + 1.0);
     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
 
 fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
     // Image
 
     const ASPECT_RATIO: f64 = 16.0 / 9.0;
<span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     log::info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 12:</strong> [<a href="https://github.com/goldnor/code/blob/47441cbbe4cb464b6f29e82801d47aba101092f2/src/main.rs">main.rs</a>] <em>Rendering surface normals on a sphere</em></p>
<br>
<p>And that yields this picture:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/surface_normals_and_multiple_objects/../../imgs/img-1.04-normals-sphere.png" alt="A sphere colored according to its normal vectors">
<p><strong>Image 4:</strong> A sphere colored according to its normal vectors</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="simplifying-the-ray-sphere-intersection-code"><a class="header" href="#simplifying-the-ray-sphere-intersection-code">Simplifying the Ray-Sphere Intersection Code</a></h2>
<p>Let’s revisit the ray-sphere function:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use code::{
</span><span class="boring">    color::{Color, write_color},
</span><span class="boring">    ray::Ray,
</span><span class="boring">    vec3::{Point3, Vec3, dot, unit_vector},
</span><span class="boring">};
</span><span class="boring">
</span>fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; Option&lt;f64&gt; {
    let oc = center - r.origin();
    let a = dot(r.direction(), r.direction());
    let b = -2.0 * dot(r.direction(), oc);
    let c = dot(oc, oc) - radius * radius;
    let discriminant = b * b - 4.0 * a * c;

    (discriminant &gt;= 0.0).then(|| (-b - f64::sqrt(discriminant)) / (2.0 * a))
}
<span class="boring">
</span><span class="boring">fn ray_color(r: Ray) -&gt; Color {
</span><span class="boring">    if let Some(t) = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
</span><span class="boring">        let n = unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
</span><span class="boring">        return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let unit_direction = unit_vector(r.direction());
</span><span class="boring">    let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">    (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    // Image
</span><span class="boring">
</span><span class="boring">    const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">    const IMAGE_WIDTH: i32 = 400;
</span><span class="boring">
</span><span class="boring">    // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">    const IMAGE_HEIGHT: i32 = {
</span><span class="boring">        let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">        if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // Camera
</span><span class="boring">
</span><span class="boring">    let focal_length = 1.0;
</span><span class="boring">    let viewport_height = 2.0;
</span><span class="boring">    let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">    let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring">
</span><span class="boring">    // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">    let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">    let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring">
</span><span class="boring">    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">    let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">    let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring">
</span><span class="boring">    // Calculate the location of the upper left pixel.
</span><span class="boring">    let viewport_upper_left =
</span><span class="boring">        camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">    let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring">
</span><span class="boring">    // Render
</span><span class="boring">
</span><span class="boring">    env_logger::init();
</span><span class="boring">    println!("P3");
</span><span class="boring">    println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">    println!("255");
</span><span class="boring">
</span><span class="boring">    for j in 0..IMAGE_HEIGHT {
</span><span class="boring">        log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">        for i in 0..IMAGE_WIDTH {
</span><span class="boring">            let pixel_center =
</span><span class="boring">                pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">            let ray_direction = pixel_center - camera_center;
</span><span class="boring">            let r = Ray::new(camera_center, ray_direction);
</span><span class="boring">
</span><span class="boring">            let pixel_color = ray_color(r);
</span><span class="boring">            write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    log::info!("Done.");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 13:</strong> [<a href="https://github.com/goldnor/code/blob/47441cbbe4cb464b6f29e82801d47aba101092f2/src/main.rs">main.rs</a>] <em>Ray-sphere intersection code (before)</em></p>
<br>
<p>First, recall that a vector dotted with itself is equal to the squared length of that vector.</p>
<p>Second, notice how the equation for \( b \) has a factor of negative two in it. Consider what happens to the quadratic equation if \( b = 2h \):</p>
<p>\[ \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}\]
\[= \frac{-(-2h) \pm \sqrt{(-2h)^2 - 4ac}}{2a}\]
\[= \frac{2h \pm 2 \sqrt{h^2 - ac}}{2a}\]
\[= \frac{h \pm \sqrt{h^2 - ac}}{a}\]</p>
<p>This simplifies nicely, so we'll use it. So solving for \( h \):</p>
<p>\[b = -2 \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) \]
\[b = -2h \]
\[h = \frac{b}{-2} = \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) \]</p>
<p>Using these observations, we can now simplify the sphere-intersection code to this:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 405ca4b..1f26e3d 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,82 +1,82 @@
</span><span class="boring"> use code::{
</span><span class="boring">     color::{Color, write_color},
</span><span class="boring">     ray::Ray,
</span><span class="boring">     vec3::{Point3, Vec3, dot, unit_vector},
</span><span class="boring"> };
</span><span class="boring"> 
</span> fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; Option&lt;f64&gt; {
     let oc = center - r.origin();
<span class="boring">-    let a = dot(r.direction(), r.direction());
</span><span class="boring">-    let b = -2.0 * dot(r.direction(), oc);
</span><span class="boring">-    let c = dot(oc, oc) - radius * radius;
</span><span class="boring">-    let discriminant = b * b - 4.0 * a * c;
</span>+    let a = r.direction().length_squared();
+    let h = dot(r.direction(), oc);
+    let c = oc.length_squared() - radius * radius;
+    let discriminant = h * h - a * c;
 
<span class="boring">-    (discriminant &gt;= 0.0).then(|| (-b - f64::sqrt(discriminant)) / (2.0 * a))
</span>+    (discriminant &gt;= 0.0).then(|| (h - f64::sqrt(discriminant)) / a)
 }
<span class="boring"> 
</span><span class="boring"> fn ray_color(r: Ray) -&gt; Color {
</span><span class="boring">     if let Some(t) = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
</span><span class="boring">         let n = unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
</span><span class="boring">         return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     let unit_direction = unit_vector(r.direction());
</span><span class="boring">     let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     log::info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 14:</strong> [<a href="https://github.com/goldnor/code/blob/f878b49faaf7958cf88bf4748416acf7cfd61408/src/main.rs">main.rs</a>] <em>Ray-sphere intersection code (after)</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="an-abstraction-for-hittable-objects"><a class="header" href="#an-abstraction-for-hittable-objects">An Abstraction for Hittable Objects</a></h2>
<p>Now, how about more than one sphere? While it is tempting to have an array of spheres, a very clean solution is to make an “abstract class” for anything a ray might hit, and make both a sphere and a list of spheres just something that can be hit. What that class should be called is something of a quandary — calling it an “object” would be good if not for “object oriented” programming. “Surface” is often used, with the weakness being maybe we will want volumes (fog, clouds, stuff like that). “hittable” emphasizes the member function that unites them. I don’t love any of these, but we'll go with “hittable”.</p>
<p>This <code>hittable</code> abstract class will have a <code>hit</code> function that takes in a ray. <sup class="footnote-reference" id="fr-63a-1"><a href="#footnote-63a">1</a></sup> Most ray tracers have found it convenient to add a valid interval for hits \( t_{min} \) to \( t_{max} \), so the hit only “counts” if \( t_{min} &lt; t &lt; t_{max} \). For the initial rays this is positive \( t \), but as we will see, it can simplify our code to have an interval \( t_{min} \) to \( t_{max} \). One design question is whether to do things like compute the normal if we hit something. We might end up hitting something closer as we do our search, and we will only need the normal of the closest thing. I will go with the simple solution and compute a bundle of stuff I will store in some structure. Here’s the abstract class:</p>
<pre><code class="language-rust norun noplayground">use crate::{
    ray::Ray,
    vec3::{Point3, Vec3},
};

#[derive(Debug, Default, Clone, Copy)]
pub struct HitRecord {
    pub p: Point3,
    pub normal: Vec3,
    pub t: f64,
}

pub trait Hittable {
    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
}</code></pre>
<p><strong>Listing 15:</strong> [<a href="https://github.com/goldnor/code/blob/1791ddbea0fdc81c13e4ef3daaaca7e440cec404/src/hittable.rs">hittable.rs</a>] <em>The hittable class</em></p>
<br>
<p>And here’s the sphere:</p>
<pre><code class="language-rust norun noplayground">use crate::{
    hittable::{HitRecord, Hittable},
    ray::Ray,
    vec3::{Point3, dot},
};

#[derive(Debug, Clone, Copy)]
pub struct Sphere {
    center: Point3,
    radius: f64,
}

impl Sphere {
    pub fn new(center: Point3, radius: f64) -&gt; Self {
        Self {
            center,
            radius: f64::max(0.0, radius),
        }
    }
}

impl Hittable for Sphere {
    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
        let oc = self.center - r.origin();
        let a = r.direction().length_squared();
        let h = dot(r.direction(), oc);
        let c = oc.length_squared() - self.radius * self.radius;

        let discriminant = h * h - a * c;
        if discriminant &lt; 0.0 {
            return None;
        }

        let sqrtd = f64::sqrt(discriminant);

        // Find the nearest root that lies in the acceptable range.
        let mut root = (h - sqrtd) / a;
        if root &lt;= ray_tmin || ray_tmax &lt;= root {
            root = (h + sqrtd) / a;
            if root &lt;= ray_tmin || ray_tmax &lt;= root {
                return None;
            }
        }

        let t = root;
        let p = r.at(t);
        let rec = HitRecord {
            t,
            p,
            normal: (p - self.center) / self.radius,
        };

        Some(rec)
    }
}</code></pre>
<p><strong>Listing 16:</strong> [<a href="https://github.com/goldnor/code/blob/36e5e545d452e57637150a4e1a8ba2ff93aee52b/src/sphere.rs">sphere.rs</a>] <em>The sphere class</em></p>
<br>
<p>(Note here that we use the C++ standard function <code>std::fmax()</code>, which returns the maximum of the two floating-point arguments. Similarly, we will later use <code>std::fmin()</code>, which returns the minimum of the two floating-point arguments.) <sup class="footnote-reference" id="fr-63b-1"><a href="#footnote-63b">2</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-63a">
<p>A simple Rust Trait will be used instead. <a href="#fr-63a-1">↩</a></p>
</li>
<li id="footnote-63b">
<p>The Rust standard library provides the functions <code>f64::max()</code> and <code>f64::min()</code>. <a href="#fr-63b-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="front-faces-versus-back-faces"><a class="header" href="#front-faces-versus-back-faces">Front Faces Versus Back Faces</a></h2>
<p>The second design decision for normals is whether they should always point out. At present, the normal found will always be in the direction of the center to the intersection point (the normal points out). If the ray intersects the sphere from the outside, the normal points against the ray. If the ray intersects the sphere from the inside, the normal (which always points out) points with the ray. Alternatively, we can have the normal always point against the ray. If the ray is outside the sphere, the normal will point outward, but if the ray is inside the sphere, the normal will point inward.</p>
<p><img src="chapters/surface_normals_and_multiple_objects/../../imgs/fig-1.07-normal-sides.jpg" alt="Possible directions for sphere surface-normal geometry" /></p>
<p><strong>Figure 7:</strong> <em>Possible directions for sphere surface-normal geometry</em></p>
<br>
<p>We need to choose one of these possibilities because we will eventually want to determine which side of the surface that the ray is coming from. This is important for objects that are rendered differently on each side, like the text on a two-sided sheet of paper, or for objects that have an inside and an outside, like glass balls.</p>
<p>If we decide to have the normals always point out, then we will need to determine which side the ray is on when we color it. We can figure this out by comparing the ray with the normal. If the ray and the normal face in the same direction, the ray is inside the object, if the ray and the normal face in the opposite direction, then the ray is outside the object. This can be determined by taking the dot product of the two vectors, where if their dot is positive, the ray is inside the sphere.</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{
</span><span class="boring">    ray::Ray,
</span><span class="boring">    vec3::{Point3, Vec3, dot},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct HitRecord {
</span><span class="boring">    pub p: Point3,
</span><span class="boring">    pub normal: Vec3,
</span><span class="boring">    pub t: f64,
</span><span class="boring">    pub front_face: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl HitRecord {
</span><span class="boring">    pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">        // Sets the hit record normal vector.
</span><span class="boring">        // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring">
</span><span class="boring">        let normal;
</span><span class="boring">        let front_face;
</span>        if dot(r.direction(), outward_normal) &gt; 0.0 {
            // ray is inside the sphere
<span class="boring">            normal = -outward_normal;
</span><span class="boring">            front_face = false;
</span>        } else {
            // ray is outside the sphere
<span class="boring">            normal = outward_normal;
</span><span class="boring">            front_face = true;
</span>        }
<span class="boring">
</span><span class="boring">        self.front_face = front_face;
</span><span class="boring">        self.normal = normal;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub trait Hittable {
</span><span class="boring">    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 17:</strong> <em>Comparing the ray and the normal</em></p>
<br>
<p>If we decide to have the normals always point against the ray, we won't be able to use the dot product to determine which side of the surface the ray is on. Instead, we would need to store that information:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{
</span><span class="boring">    ray::Ray,
</span><span class="boring">    vec3::{Point3, Vec3, dot},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct HitRecord {
</span><span class="boring">    pub p: Point3,
</span><span class="boring">    pub normal: Vec3,
</span><span class="boring">    pub t: f64,
</span><span class="boring">    pub front_face: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl HitRecord {
</span><span class="boring">    pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">        // Sets the hit record normal vector.
</span><span class="boring">        // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring">
</span><span class="boring">        let normal;
</span>        let front_face;
        if dot(r.direction(), outward_normal) &gt; 0.0 {
            // ray is inside the sphere
            normal = -outward_normal;
            front_face = false;
        } else {
            // ray is outside the sphere
            normal = outward_normal;
            front_face = true;
        }
<span class="boring">
</span><span class="boring">        self.front_face = front_face;
</span><span class="boring">        self.normal = normal;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub trait Hittable {
</span><span class="boring">    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 18:</strong> <em>Remembering the side of the surface</em></p>
<br>
<p>We can set things up so that normals always point “outward” from the surface, or always point against the incident ray. This decision is determined by whether you want to determine the side of the surface at the time of geometry intersection or at the time of coloring. In this book we have more material types than we have geometry types, so we'll go for less work and put the determination at geometry time. This is simply a matter of preference, and you'll see both implementations in the literature.</p>
<p>We add the <code>front_face</code> bool to the <code>hit_record</code> class. We'll also add a function to solve this calculation for us: <code>set_face_normal()</code>. For convenience we will assume that the vector passed to the new <code>set_face_normal()</code> function is of unit length. We could always normalize the parameter explicitly, but it's more efficient if the geometry code does this, as it's usually easier when you know more about the specific geometry.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable.rs b/src/hittable.rs
</span><span class="boring">index b8a3fcf..8ced826 100644
</span><span class="boring">--- a/src/hittable.rs
</span><span class="boring">+++ b/src/hittable.rs
</span><span class="boring">@@ -1,15 +1,30 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     ray::Ray,
</span><span class="boring">-    vec3::{Point3, Vec3},
</span><span class="boring">+    vec3::{Point3, Vec3, dot},
</span><span class="boring"> };
</span><span class="boring"> 
</span> #[derive(Debug, Default, Clone, Copy)]
 pub struct HitRecord {
     pub p: Point3,
     pub normal: Vec3,
     pub t: f64,
+    pub front_face: bool,
+}
+
+impl HitRecord {
+    pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
+        // Sets the hit record normal vector.
+        // NOTE: the parameter `outward_normal` is assumed to have unit length.
+
+        self.front_face = dot(r.direction(), outward_normal) &lt; 0.0;
+        self.normal = if self.front_face {
+            outward_normal
+        } else {
+            -outward_normal
+        };
+    }
 }
<span class="boring"> 
</span><span class="boring"> pub trait Hittable {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 19:</strong> [<a href="https://github.com/goldnor/code/blob/a1c2d4fad73108c42bb6612c0bdb02d2a9c6a7ed/src/hittable.rs">hittable.rs</a>] <em>Adding front-face tracking to hit_record</em></p>
<br>
<p>And then we add the surface side determination to the class:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index aa651e9..86d3cbb 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,56 +1,57 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     hittable::{HitRecord, Hittable},
</span><span class="boring">     ray::Ray,
</span><span class="boring">     vec3::{Point3, dot},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Clone, Copy)]
</span><span class="boring"> pub struct Sphere {
</span><span class="boring">     center: Point3,
</span><span class="boring">     radius: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sphere {
</span><span class="boring">     pub fn new(center: Point3, radius: f64) -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             center,
</span><span class="boring">             radius: f64::max(0.0, radius),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Hittable for Sphere {
     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
<span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span><span class="boring"> 
</span><span class="boring">         // Find the nearest root that lies in the acceptable range.
</span><span class="boring">         let mut root = (h - sqrtd) / a;
</span><span class="boring">         if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span><span class="boring">             root = (h + sqrtd) / a;
</span><span class="boring">             if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span><span class="boring">                 return None;
</span><span class="boring">             }
</span><span class="boring">         }
</span> 
         let t = root;
         let p = r.at(t);
<span class="boring">-        let rec = HitRecord {
</span>+        let mut rec = HitRecord {
             t,
             p,
<span class="boring">-            normal: (p - self.center) / self.radius,
</span>             ..Default::default()
         };
+        let outward_normal = (p - self.center) / self.radius;
+        rec.set_face_normal(r, outward_normal);
 
         Some(rec)
     }
 }</code></pre>
<p><strong>Listing 20:</strong> [<a href="https://github.com/goldnor/code/blob/e54430867656af9ca129dfd3350fe4f0ead18d19/src/sphere.rs">sphere.rs</a>] <em>The sphere class with normal determination</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-list-of-hittable-objects"><a class="header" href="#a-list-of-hittable-objects">A List of Hittable Objects</a></h2>
<p>We have a generic object called a <code>hittable</code> that the ray can intersect with. We now add a class that stores a list of <code>hittables</code>:</p>
<pre><code class="language-rust norun noplayground">use std::rc::Rc;

use crate::{
    hittable::{HitRecord, Hittable},
    ray::Ray,
};

#[derive(Default)]
pub struct HittableList {
    pub objects: Vec&lt;Rc&lt;dyn Hittable&gt;&gt;,
}

impl HittableList {
    pub fn new() -&gt; Self {
        Self::default()
    }

    pub fn clear(&amp;mut self) {
        self.objects.clear();
    }

    pub fn add(&amp;mut self, object: Rc&lt;dyn Hittable&gt;) {
        self.objects.push(object);
    }
}

impl Hittable for HittableList {
    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
        self.objects
            .iter()
            .filter_map(|obj| obj.hit(r, ray_tmin, ray_tmax))
            .min_by(|a, b| a.t.partial_cmp(&amp;b.t).expect("no NaN value"))
    }
}</code></pre>
<p><strong>Listing 21:</strong> [<a href="https://github.com/goldnor/code/blob/86c110ccad16979ec62dce945725abab72499799/src/hittable_list.rs">hittable_list.rs</a>] <em>The hittable_list class</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="some-new-c-features-1"><a class="header" href="#some-new-c-features-1">Some New C++ Features <sup class="footnote-reference" id="fr-66a-1"><a href="#footnote-66a">1</a></sup></a></h2>
<p>The <code>hittable_list</code> class code uses some C++ features that may trip you up if you're not normally a C++ programmer: <code>vector</code>, <code>shared_ptr</code>, and <code>make_shared</code>. <sup class="footnote-reference" id="fr-66b-1"><a href="#footnote-66b">2</a></sup></p>
 <!-- It is possible to use `Arc` instead for `Rc` if using multithreading and insert a `Cell` type to allow for interior mutability, but since the scene is setup once and does not change over the course of the program lifetime a simple `Rc` is sufficient. -->
<p><code>shared_ptr&lt;type&gt;</code> is a pointer to some allocated type, with reference-counting semantics. Every time you assign its value to another shared pointer (usually with a simple assignment), the reference count is incremented. As shared pointers go out of scope (like at the end of a block or function), the reference count is decremented. Once the count goes to zero, the object is safely deleted. <sup class="footnote-reference" id="fr-66c-1"><a href="#footnote-66c">3</a></sup></p>
<p>Typically, a shared pointer is first initialized with a newly-allocated object, something like this:</p>
<pre><pre class="playground"><code class="language-rust norun nodiff"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let double_ptr: Rc&lt;double&gt; = Rc::new(0.37);
let vec3_ptr: Rc&lt;Vec3&gt; = Rc::new(Vec3::new(1.414214, 2.718281, 1.618034));
let sphere_ptr: Rc&lt;Sphere&gt; = Rc::new(Sphere::new(Point3::new(0.0, 0.0, 0.0), 1.0));
<span class="boring">}</span></code></pre></pre>
<p><strong>Listing 22:</strong> <em>An example allocation using shared_ptr</em></p>
<br>
<p><code>make_shared&lt;thing&gt;(thing_constructor_params ...)</code> allocates a new instance of type thing, using the constructor parameters. It returns a <code>shared_ptr&lt;thing&gt;</code>. <sup class="footnote-reference" id="fr-66d-1"><a href="#footnote-66d">4</a></sup></p>
<p>Since the type can be automatically deduced by the return type of <code>make_shared&lt;type&gt;(...)</code>, the above lines can be more simply expressed using C++'s <code>auto</code> type specifier: <sup class="footnote-reference" id="fr-66e-1"><a href="#footnote-66e">5</a></sup></p>
<pre><pre class="playground"><code class="language-rust norun nodiff"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let double_ptr = Rc::new(0.37);
let vec3_ptr = Rc::new(Vec3::new(1.414214, 2.718281, 1.618034));
let sphere_ptr = Rc::new(Sphere::new(Point3::new(0.0, 0.0, 0.0), 1.0));
<span class="boring">}</span></code></pre></pre>
<p><strong>Listing 23:</strong>  <em>An example allocation using shared_ptr with auto type</em></p>
<br>
<p>We'll use shared pointers in our code, because it allows multiple geometries to share a common instance (for example, a bunch of spheres that all use the same color material), and because it makes memory management automatic and easier to reason about.</p>
<p><code>std::shared_ptr</code> is included with the <code>&lt;memory&gt;</code> header.<sup class="footnote-reference" id="fr-66f-1"><a href="#footnote-66f">6</a></sup></p>
<p>The second C++ feature you may be unfamiliar with is <code>std::vector</code>. This is a generic array-like collection of an arbitrary type. Above, we use a collection of pointers to <code>hittable</code>. <code>std::vector</code> automatically grows as more values are added: <code>objects.push_back(object)</code> adds a value to the end of the <code>std::vector</code> member variable <code>objects</code>.</p>
<p><code>std::vector</code> is included with the ``<vector>` header. <sup class="footnote-reference" id="fr-66g-1"><a href="#footnote-66g">7</a></sup></p>
<p>Finally, the <code>using</code> statements in <a href="chapters/surface_normals_and_multiple_objects/a_list_of_hittable_objects.html">listing 21</a> tell the compiler that we'll be getting <code>shared_ptr</code> and <code>make_shared</code> from the <code>std</code> library, so we don't need to prefix these with <code>std::</code> every time we reference them.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-66a">
<p>This chapter can be safely skipped when the code of last chapter is clear. <a href="#fr-66a-1">↩</a></p>
</li>
<li id="footnote-66b">
<p>The Rust equivalents are <code>Vec</code>, <code>Rc</code> and a simple <code>new</code> method of the reference counting smart pointer. <a href="#fr-66b-1">↩</a></p>
</li>
<li id="footnote-66c">
<p>Here we use <code>Rc</code>. In contrast to the C++ <code>shared_ptr</code>, the contained value of an <code>Rc</code> is inmutable. Enclosing the value with a cell based type like for example <code>RefCell</code> would allow for interior mutability. However in this case, all objects are created on startup and do not change over the course of the program lifetime which is why a simple <code>Rc</code> is sufficient. <a href="#fr-66c-1">↩</a></p>
</li>
<li id="footnote-66d">
<p>Rust has no constructors, instead it is convention to fill structs with the <code>new</code> method, the implementation of traits like <code>Default</code>, <code>From</code> or similar, or to use any method that returns <code>Self</code>. So technically something like <code>make_shared</code> does not exist in Rust. <a href="#fr-66d-1">↩</a></p>
</li>
<li id="footnote-66e">
<p>The type annotations in the last listing were not nessecary, Rust's <code>let</code> declarations can in this case infere the types. <a href="#fr-66e-1">↩</a></p>
</li>
<li id="footnote-66f">
<p><code>Rc</code> is found in <code>std::rc::Rc</code>. <a href="#fr-66f-1">↩</a></p>
</li>
<li id="footnote-66g">
<p><code>Vec</code> is included in Rust's std prelude and does have to be included to be used. <a href="#fr-66g-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="common-constants-and-utility-functions"><a class="header" href="#common-constants-and-utility-functions">Common Constants and Utility Functions</a></h2>
<p>We need some math constants that we conveniently define in their own header file. For now we only need infinity, but we will also throw our own definition of pi in there, which we will need later. We'll also throw common useful constants and future utility functions in here. This new header, <code>rtweekend.h</code>, will be our general main header file. <sup class="footnote-reference" id="fr-67a-1"><a href="#footnote-67a">1</a></sup></p>
<pre><code class="language-rust norun noplayground">pub use log::*;

// Rust Std usings

pub use std::rc::Rc;

// Constants

pub const INFINITY: f64 = f64::INFINITY;
pub const PI: f64 = std::f64::consts::PI;

// Common Headers

pub use crate::{color::*, ray::*, vec3::*};</code></pre>
<p><strong>Listing 24:</strong> [<a href="https://github.com/goldnor/code/blob/9e1b0c216e67d1bcf41de6ee6c449758c9cc33e5/src/prelude.rs">prelude.rs</a>] <em>The rtweekend.h common header</em></p>
<br>
<p>Program files will include <code>rtweekend.h</code> first, so all other header files (where the bulk of our code will reside) can implicitly assume that <code>rtweekend.h</code> has already been included. Header files still need to explicitly include any other necessary header files. We'll make some updates with these assumptions in mind.</p>
<pre><code class="language-rust norun noplayground">// nothing changes</code></pre>
<p><strong>Listing 25:</strong> [<a href="https://github.com/goldnor/code/blob/9e1b0c216e67d1bcf41de6ee6c449758c9cc33e5/src/color.rs">color.rs</a>] <em>Assume rtweekend.h inclusion for color.h</em> <sup class="footnote-reference" id="fr-67b-1"><a href="#footnote-67b">2</a></sup></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable.rs b/src/hittable.rs
</span><span class="boring">index 8ced826..a7aab5a 100644
</span><span class="boring">--- a/src/hittable.rs
</span><span class="boring">+++ b/src/hittable.rs
</span><span class="boring">@@ -1,30 +1,27 @@
</span>-use crate::{
-    ray::Ray,
-    vec3::{Point3, Vec3, dot},
-};
+use crate::prelude::*;
<span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct HitRecord {
</span><span class="boring">     pub p: Point3,
</span><span class="boring">     pub normal: Vec3,
</span><span class="boring">     pub t: f64,
</span><span class="boring">     pub front_face: bool,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl HitRecord {
</span><span class="boring">     pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">         // Sets the hit record normal vector.
</span><span class="boring">         // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring"> 
</span><span class="boring">         self.front_face = dot(r.direction(), outward_normal) &lt; 0.0;
</span><span class="boring">         self.normal = if self.front_face {
</span><span class="boring">             outward_normal
</span><span class="boring">         } else {
</span><span class="boring">             -outward_normal
</span><span class="boring">         };
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub trait Hittable {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 26:</strong> [<a href="https://github.com/goldnor/code/blob/a83dfcb94c1741454b03fe57b8dc56e97a47c0cc/src/hittable.rs">hittable.rs</a>] <em>Assume rtweekend.h inclusion for hittable.h</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable_list.rs b/src/hittable_list.rs
</span><span class="boring">index 95c24e4..7841161 100644
</span><span class="boring">--- a/src/hittable_list.rs
</span><span class="boring">+++ b/src/hittable_list.rs
</span><span class="boring">@@ -1,34 +1,32 @@
</span>-use std::rc::Rc;
-
 use crate::{
     hittable::{HitRecord, Hittable},
-    ray::Ray,
+    prelude::*,
 };
<span class="boring"> 
</span><span class="boring"> #[derive(Default)]
</span><span class="boring"> pub struct HittableList {
</span><span class="boring">     pub objects: Vec&lt;Rc&lt;dyn Hittable&gt;&gt;,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl HittableList {
</span><span class="boring">     pub fn new() -&gt; Self {
</span><span class="boring">         Self::default()
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn clear(&amp;mut self) {
</span><span class="boring">         self.objects.clear();
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn add(&amp;mut self, object: Rc&lt;dyn Hittable&gt;) {
</span><span class="boring">         self.objects.push(object);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Hittable for HittableList {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
</span><span class="boring">         self.objects
</span><span class="boring">             .iter()
</span><span class="boring">             .filter_map(|obj| obj.hit(r, ray_tmin, ray_tmax))
</span><span class="boring">             .min_by(|a, b| a.t.partial_cmp(&amp;b.t).expect("no NaN value"))
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 27:</strong> [<a href="https://github.com/goldnor/code/blob/fd505c6bc51cd1887e71b1ce44fe0ee32a1fb198/src/hittable_list.rs">hittable_list.rs</a>] <em>Assume rtweekend.h inclusion for hittable_list.h</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index 86d3cbb..9de9f72 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,57 +1,56 @@
</span> use crate::{
     hittable::{HitRecord, Hittable},
-    ray::Ray,
-    vec3::{Point3, dot},
+    prelude::*,
 };
<span class="boring"> 
</span><span class="boring"> #[derive(Debug, Clone, Copy)]
</span><span class="boring"> pub struct Sphere {
</span><span class="boring">     center: Point3,
</span><span class="boring">     radius: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sphere {
</span><span class="boring">     pub fn new(center: Point3, radius: f64) -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             center,
</span><span class="boring">             radius: f64::max(0.0, radius),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Hittable for Sphere {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
</span><span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span><span class="boring"> 
</span><span class="boring">         // Find the nearest root that lies in the acceptable range.
</span><span class="boring">         let mut root = (h - sqrtd) / a;
</span><span class="boring">         if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span><span class="boring">             root = (h + sqrtd) / a;
</span><span class="boring">             if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span><span class="boring">                 return None;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let t = root;
</span><span class="boring">         let p = r.at(t);
</span><span class="boring">         let mut rec = HitRecord {
</span><span class="boring">             t,
</span><span class="boring">             p,
</span><span class="boring">             ..Default::default()
</span><span class="boring">         };
</span><span class="boring">         let outward_normal = (p - self.center) / self.radius;
</span><span class="boring">         rec.set_face_normal(r, outward_normal);
</span><span class="boring"> 
</span><span class="boring">         Some(rec)
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 28:</strong> [<a href="https://github.com/goldnor/code/blob/d57e0ab6d5de95b5d3105a150a69c552e4eeb167/src/sphere.rs">sphere.rs</a>] <em>Assume rtweekend.h inclusion for sphere.h</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground">// nothing changes</code></pre>
<p><strong>Listing 29:</strong> [<a href="https://github.com/goldnor/code/blob/d57e0ab6d5de95b5d3105a150a69c552e4eeb167/src/vec3.rs">vec3.rs</a>] <em>Assume rtweekend.h inclusion for vec3.h</em></p>
<br>
<p>And now the new main:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 1f26e3d..59c000b 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,82 +1,74 @@
</span>-use code::{
-    color::{Color, write_color},
-    ray::Ray,
-    vec3::{Point3, Vec3, dot, unit_vector},
-};
-
-fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; Option&lt;f64&gt; {
<span class="boring">-    let oc = center - r.origin();
</span><span class="boring">-    let a = r.direction().length_squared();
</span><span class="boring">-    let h = dot(r.direction(), oc);
</span><span class="boring">-    let c = oc.length_squared() - radius * radius;
</span><span class="boring">-    let discriminant = h * h - a * c;
</span>-
<span class="boring">-    (discriminant &gt;= 0.0).then(|| (h - f64::sqrt(discriminant)) / a)
</span>-}
+use code::{hittable::Hittable, hittable_list::HittableList, prelude::*, sphere::Sphere};
 
<span class="boring">-fn ray_color(r: Ray) -&gt; Color {
</span><span class="boring">-    if let Some(t) = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
</span><span class="boring">-        let n = unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
</span><span class="boring">-        return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
</span>+fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
+    if let Some(rec) = world.hit(r, 0.0, INFINITY) {
+        return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
     }
 
     let unit_direction = unit_vector(r.direction());
     let a = 0.5 * (unit_direction.y() + 1.0);
     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
 
 fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
     // Image
 
     const ASPECT_RATIO: f64 = 16.0 / 9.0;
     const IMAGE_WIDTH: i32 = 400;
 
     // Calculate the image height, and ensure that it's at least 1.
     const IMAGE_HEIGHT: i32 = {
         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
         if image_height &lt; 1 { 1 } else { image_height }
     };
 
+    // World
+
+    let mut world = HittableList::new();
+
+    world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
+    world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
+
     // Camera
 
     let focal_length = 1.0;
     let viewport_height = 2.0;
     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
     let camera_center = Point3::new(0.0, 0.0, 0.0);
 
     // Calculate the vectors across the horizontal and down the vertical viewport edges.
     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
 
     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
 
     // Calculate the location of the upper left pixel.
     let viewport_upper_left =
         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
 
     // Render
 
     env_logger::init();
     println!("P3");
     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
     println!("255");
 
     for j in 0..IMAGE_HEIGHT {
<span class="boring">-        log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span>+        info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
         for i in 0..IMAGE_WIDTH {
             let pixel_center =
                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
             let ray_direction = pixel_center - camera_center;
             let r = Ray::new(camera_center, ray_direction);
 
<span class="boring">-            let pixel_color = ray_color(r);
</span>+            let pixel_color = ray_color(r, &amp;world);
             write_color(std::io::stdout(), pixel_color)?;
         }
     }
<span class="boring">-    log::info!("Done.");
</span>+    info!("Done.");
 
     Ok(())
 }</code></pre>
<p><strong>Listing 30:</strong> [<a href="https://github.com/goldnor/code/blob/e19dd26432882f6c779f25632318690a3be5a4ac/src/main.rs">main.rs</a>] <em>The new main with hittables</em></p>
<br>
<p>This yields a picture that is really just a visualization of where the spheres are located along with their surface normal. This is often a great way to view any flaws or specific characteristics of a geometric model.</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/surface_normals_and_multiple_objects/../../imgs/img-1.05-normals-sphere-ground.png" alt=" Resulting render of normals-colored sphere with ground">
<p><strong>Image 5:</strong> <em>Resulting render of normals-colored sphere with ground</em></p>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-67a">
<p>In Rust it is common to create a prelude for common types, which we will do here instead. Note however, that there are at the momentan no <a href="https://github.com/rust-lang/rfcs/pull/890">plan to include a custom prelude as a language feature</a>, instead we need to import the prelude with <code>use crate::prelude::*</code>. <a href="#fr-67a-1">↩</a></p>
</li>
<li id="footnote-67b">
<p>There is no need to use the prelude in <code>color.rs</code> only for the <code>Vec3</code> struct. The listing is still included to match the numbering of the original book series. <a href="#fr-67b-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="an-interval-class"><a class="header" href="#an-interval-class">An Interval Class</a></h2>
<p>Before we continue, we'll implement an interval class to manage real-valued intervals with a minimum and a maximum. We'll end up using this class quite often as we proceed.</p>
<pre><code class="language-rust norun noplayground">#[derive(Debug, Clone, Copy)]
pub struct Interval {
    pub min: f64,
    pub max: f64,
}

impl Default for Interval {
    fn default() -&gt; Self {
        Self::EMPTY
    }
}

impl Interval {
    pub const EMPTY: Self = Self {
        min: f64::INFINITY,
        max: f64::NEG_INFINITY,
    };

    pub const UNIVERSE: Self = Self {
        min: f64::NEG_INFINITY,
        max: f64::INFINITY,
    };

    pub fn new(min: f64, max: f64) -&gt; Self {
        Self { min, max }
    }

    pub fn size(&amp;self) -&gt; f64 {
        self.max - self.min
    }

    pub fn contains(&amp;self, x: f64) -&gt; bool {
        self.min &lt;= x &amp;&amp; x &lt;= self.max
    }

    pub fn surrounds(&amp;self, x: f64) -&gt; bool {
        self.min &lt; x &amp;&amp; x &lt; self.max
    }
}</code></pre>
<p><strong>Listing 31:</strong> [<a href="https://github.com/goldnor/code/blob/b97cce927b5c04bc925b77462cef0a4ce6152d4a/src/interval.rs">interval.rs</a>] <em>Introducing the new interval class</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/prelude.rs b/src/prelude.rs
</span><span class="boring">index fcd4621..2ec9487 100644
</span><span class="boring">--- a/src/prelude.rs
</span><span class="boring">+++ b/src/prelude.rs
</span><span class="boring">@@ -1,14 +1,14 @@
</span><span class="boring"> pub use log::*;
</span><span class="boring"> 
</span><span class="boring"> // Rust Std usings
</span><span class="boring"> 
</span><span class="boring"> pub use std::rc::Rc;
</span><span class="boring"> 
</span><span class="boring"> // Constants
</span><span class="boring"> 
</span><span class="boring"> pub const INFINITY: f64 = f64::INFINITY;
</span><span class="boring"> pub const PI: f64 = std::f64::consts::PI;
</span><span class="boring"> 
</span> // Common Headers
 
<span class="boring">-pub use crate::{color::*, ray::*, vec3::*};
</span>+pub use crate::{color::*, interval::Interval, ray::*, vec3::*};</code></pre>
<p><strong>Listing 32:</strong> [<a href="https://github.com/goldnor/code/blob/7fc2aa1432889497ecb73854719905b0ed276a68/src/prelude.rs">prelude.rs</a>] <em>Including the new interval class</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable.rs b/src/hittable.rs
</span><span class="boring">index a7aab5a..1b65b92 100644
</span><span class="boring">--- a/src/hittable.rs
</span><span class="boring">+++ b/src/hittable.rs
</span><span class="boring">@@ -1,27 +1,27 @@
</span><span class="boring"> use crate::prelude::*;
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct HitRecord {
</span><span class="boring">     pub p: Point3,
</span><span class="boring">     pub normal: Vec3,
</span><span class="boring">     pub t: f64,
</span><span class="boring">     pub front_face: bool,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl HitRecord {
</span><span class="boring">     pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">         // Sets the hit record normal vector.
</span><span class="boring">         // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring"> 
</span><span class="boring">         self.front_face = dot(r.direction(), outward_normal) &lt; 0.0;
</span><span class="boring">         self.normal = if self.front_face {
</span><span class="boring">             outward_normal
</span><span class="boring">         } else {
</span><span class="boring">             -outward_normal
</span><span class="boring">         };
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> pub trait Hittable {
<span class="boring">-    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span>+    fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt;;
 }</code></pre>
<p><strong>Listing 33:</strong> [<a href="https://github.com/goldnor/code/blob/d75c2cf12d1747e49e2568b2d4718ea5efea86e5/src/hittable.rs">hittable.rs</a>] <em>hittable::hit() using interval</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable_list.rs b/src/hittable_list.rs
</span><span class="boring">index 7841161..4647aa5 100644
</span><span class="boring">--- a/src/hittable_list.rs
</span><span class="boring">+++ b/src/hittable_list.rs
</span><span class="boring">@@ -1,32 +1,32 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     hittable::{HitRecord, Hittable},
</span><span class="boring">     prelude::*,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Default)]
</span><span class="boring"> pub struct HittableList {
</span><span class="boring">     pub objects: Vec&lt;Rc&lt;dyn Hittable&gt;&gt;,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl HittableList {
</span><span class="boring">     pub fn new() -&gt; Self {
</span><span class="boring">         Self::default()
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn clear(&amp;mut self) {
</span><span class="boring">         self.objects.clear();
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn add(&amp;mut self, object: Rc&lt;dyn Hittable&gt;) {
</span><span class="boring">         self.objects.push(object);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Hittable for HittableList {
<span class="boring">-    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
</span>+    fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt; {
         self.objects
             .iter()
<span class="boring">-            .filter_map(|obj| obj.hit(r, ray_tmin, ray_tmax))
</span>+            .filter_map(|obj| obj.hit(r, ray_t))
             .min_by(|a, b| a.t.partial_cmp(&amp;b.t).expect("no NaN value"))
     }
 }</code></pre>
<p><strong>Listing 34:</strong> [<a href="https://github.com/goldnor/code/blob/d75c2cf12d1747e49e2568b2d4718ea5efea86e5/src/hittable_list.rs">hittable_list.rs</a>] <em>hittable_list::hit() using interval</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index 9de9f72..a2710b4 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,56 +1,56 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     hittable::{HitRecord, Hittable},
</span><span class="boring">     prelude::*,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Clone, Copy)]
</span><span class="boring"> pub struct Sphere {
</span><span class="boring">     center: Point3,
</span><span class="boring">     radius: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sphere {
</span><span class="boring">     pub fn new(center: Point3, radius: f64) -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             center,
</span><span class="boring">             radius: f64::max(0.0, radius),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Hittable for Sphere {
<span class="boring">-    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
</span>+    fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt; {
<span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span> 
         // Find the nearest root that lies in the acceptable range.
         let mut root = (h - sqrtd) / a;
<span class="boring">-        if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span>+        if !ray_t.surrounds(root) {
             root = (h + sqrtd) / a;
<span class="boring">-            if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span>+            if !ray_t.surrounds(root) {
                 return None;
             }
         }
 
<span class="boring">         let t = root;
</span><span class="boring">         let p = r.at(t);
</span><span class="boring">         let mut rec = HitRecord {
</span><span class="boring">             t,
</span><span class="boring">             p,
</span><span class="boring">             ..Default::default()
</span><span class="boring">         };
</span><span class="boring">         let outward_normal = (p - self.center) / self.radius;
</span><span class="boring">         rec.set_face_normal(r, outward_normal);
</span><span class="boring"> 
</span><span class="boring">         Some(rec)
</span>     }
 }</code></pre>
<p><strong>Listing 35:</strong> [<a href="https://github.com/goldnor/code/blob/d75c2cf12d1747e49e2568b2d4718ea5efea86e5/src/sphere.rs">sphere.rs</a>] <em>sphere using interval</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 59c000b..a8d3932 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,74 +1,74 @@
</span><span class="boring"> use code::{hittable::Hittable, hittable_list::HittableList, prelude::*, sphere::Sphere};
</span><span class="boring"> 
</span> fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">-    if let Some(rec) = world.hit(r, 0.0, INFINITY) {
</span>+    if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
         return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
     }
 
     let unit_direction = unit_vector(r.direction());
     let a = 0.5 * (unit_direction.y() + 1.0);
     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
<span class="boring"> 
</span><span class="boring"> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // World
</span><span class="boring"> 
</span><span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r, &amp;world);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 36:</strong> [<a href="https://github.com/goldnor/code/blob/d75c2cf12d1747e49e2568b2d4718ea5efea86e5/src/main.rs">main.rs</a>] <em>The new main using interval</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moving-camera-code-into-its-own-class"><a class="header" href="#moving-camera-code-into-its-own-class">Moving Camera Code Into Its Own Class</a></h1>
<p>Before continuing, now is a good time to consolidate our camera and scene-render code into a single new class: the <code>camera</code> class. The camera class will be responsible for two important jobs:</p>
<ol>
<li>Construct and dispatch rays into the world.</li>
<li>Use the results of these rays to construct the rendered image.</li>
</ol>
<p>In this refactoring, we'll collect the <code>ray_color()</code> function, along with the image, camera, and render sections of our main program. The new camera class will contain two public methods <code>initialize()</code> and <code>render()</code>, plus two private helper methods <code>get_ray()</code> and <code>ray_color()</code>.</p>
<p>Ultimately, the camera will follow the simplest usage pattern that we could think of: it will be default constructed no arguments, then the owning code will modify the camera's public variables through simple assignment, and finally everything is initialized by a call to the <code>initialize()</code> function. This pattern is chosen instead of the owner calling a constructor with a ton of parameters or by defining and calling a bunch of setter methods. Instead, the owning code only needs to set what it explicitly cares about. Finally, we could either have the owning code call <code>initialize()</code>, or just have the camera call this function automatically at the start of <code>render()</code>. We'll use the second approach. <sup class="footnote-reference" id="fr-7a-1"><a href="#footnote-7a">1</a></sup></p>
<p>After main creates a camera and sets default values, it will call the <code>render()</code> method. The <code>render()</code> method will prepare the <code>camera</code> for rendering and then execute the render loop.</p>
<p>Here's the skeleton of our new <code>camera</code> class:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{hittable::Hittable, prelude::*};
</span><span class="boring">
</span><span class="boring">pub struct Camera {
</span><span class="boring">    /// Ratio of image width over height
</span><span class="boring">    pub aspect_ratio: f64,
</span><span class="boring">    /// Rendered image width in pixel count
</span><span class="boring">    pub image_width: i32,
</span><span class="boring">
</span><span class="boring">    /// Rendered image height
</span><span class="boring">    image_height: i32,
</span><span class="boring">    /// Camera center
</span><span class="boring">    center: Point3,
</span><span class="boring">    /// Location of pixel 0, 0
</span><span class="boring">    pixel00_loc: Point3,
</span><span class="boring">    /// Offset to pixel to the right
</span><span class="boring">    pixel_delta_u: Vec3,
</span><span class="boring">    /// Offset to pixel below
</span><span class="boring">    pixel_delta_v: Vec3,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Camera {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            aspect_ratio: 1.0,
</span><span class="boring">            image_width: 100,
</span><span class="boring">            image_height: Default::default(),
</span><span class="boring">            center: Default::default(),
</span><span class="boring">            pixel00_loc: Default::default(),
</span><span class="boring">            pixel_delta_u: Default::default(),
</span><span class="boring">            pixel_delta_v: Default::default(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Camera {
    pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
<span class="boring">        self.aspect_ratio = aspect_ratio;
</span>
<span class="boring">        self
</span>    }

    pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
<span class="boring">        self.image_width = image_width;
</span>
<span class="boring">        self
</span>    }

    pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
<span class="boring">        self.initialize();
</span>
<span class="boring">        println!("P3");
</span><span class="boring">        println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">        println!("255");
</span><span class="boring">
</span><span class="boring">        for j in 0..self.image_height {
</span><span class="boring">            info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">            for i in 0..self.image_width {
</span><span class="boring">                let pixel_center = self.pixel00_loc
</span><span class="boring">                    + (i as f64) * self.pixel_delta_u
</span><span class="boring">                    + (j as f64) * self.pixel_delta_v;
</span><span class="boring">                let ray_direction = pixel_center - self.center;
</span><span class="boring">                let r = Ray::new(self.center, ray_direction);
</span><span class="boring">
</span><span class="boring">                let pixel_color = Self::ray_color(r, world);
</span><span class="boring">                write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        info!("Done.");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span>    }

    fn initialize(&amp;mut self) {
<span class="boring">        self.image_height = {
</span><span class="boring">            let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">            if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">        };
</span>
<span class="boring">        self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring">
</span><span class="boring">        // Determine viewport dimensions.
</span><span class="boring">        let focal_length = 1.0;
</span><span class="boring">        let viewport_height = 2.0;
</span><span class="boring">        let viewport_width =
</span><span class="boring">            viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring">
</span><span class="boring">        // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">        let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">        let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring">
</span><span class="boring">        // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">        self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">        self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring">
</span><span class="boring">        // Calculate the location of the upper left pixel.
</span><span class="boring">        let viewport_upper_left =
</span><span class="boring">            self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">        self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span>    }

    fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">        if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span><span class="boring">            return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span><span class="boring">        }
</span>
<span class="boring">        let unit_direction = unit_vector(r.direction());
</span><span class="boring">        let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">        (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>    }
}</code></pre>
<p><strong>Listing 37:</strong> [<a href="https://github.com/goldnor/code/blob/9b893f7953de35ce34fad2062845cb4d0202c21e/src/camera.rs">camera.rs</a>] <em>The camera class skeleton</em></p>
<br>
<p>To begin with, let's fill in the <code>ray_color()</code> function from <code>main.cc</code>:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{hittable::Hittable, prelude::*};
</span><span class="boring">
</span><span class="boring">pub struct Camera {
</span><span class="boring">    /// Ratio of image width over height
</span><span class="boring">    pub aspect_ratio: f64,
</span><span class="boring">    /// Rendered image width in pixel count
</span><span class="boring">    pub image_width: i32,
</span><span class="boring">
</span><span class="boring">    /// Rendered image height
</span><span class="boring">    image_height: i32,
</span><span class="boring">    /// Camera center
</span><span class="boring">    center: Point3,
</span><span class="boring">    /// Location of pixel 0, 0
</span><span class="boring">    pixel00_loc: Point3,
</span><span class="boring">    /// Offset to pixel to the right
</span><span class="boring">    pixel_delta_u: Vec3,
</span><span class="boring">    /// Offset to pixel below
</span><span class="boring">    pixel_delta_v: Vec3,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Camera {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            aspect_ratio: 1.0,
</span><span class="boring">            image_width: 100,
</span><span class="boring">            image_height: Default::default(),
</span><span class="boring">            center: Default::default(),
</span><span class="boring">            pixel00_loc: Default::default(),
</span><span class="boring">            pixel_delta_u: Default::default(),
</span><span class="boring">            pixel_delta_v: Default::default(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Camera {
<span class="boring">    pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">        self.aspect_ratio = aspect_ratio;
</span><span class="boring">
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">        self.image_width = image_width;
</span><span class="boring">
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">        self.initialize();
</span><span class="boring">
</span><span class="boring">        println!("P3");
</span><span class="boring">        println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">        println!("255");
</span><span class="boring">
</span><span class="boring">        for j in 0..self.image_height {
</span><span class="boring">            info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">            for i in 0..self.image_width {
</span><span class="boring">                let pixel_center = self.pixel00_loc
</span><span class="boring">                    + (i as f64) * self.pixel_delta_u
</span><span class="boring">                    + (j as f64) * self.pixel_delta_v;
</span><span class="boring">                let ray_direction = pixel_center - self.center;
</span><span class="boring">                let r = Ray::new(self.center, ray_direction);
</span><span class="boring">
</span><span class="boring">                let pixel_color = Self::ray_color(r, world);
</span><span class="boring">                write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        info!("Done.");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn initialize(&amp;mut self) {
</span><span class="boring">        self.image_height = {
</span><span class="boring">            let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">            if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring">
</span><span class="boring">        // Determine viewport dimensions.
</span><span class="boring">        let focal_length = 1.0;
</span><span class="boring">        let viewport_height = 2.0;
</span><span class="boring">        let viewport_width =
</span><span class="boring">            viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring">
</span><span class="boring">        // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">        let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">        let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring">
</span><span class="boring">        // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">        self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">        self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring">
</span><span class="boring">        // Calculate the location of the upper left pixel.
</span><span class="boring">        let viewport_upper_left =
</span><span class="boring">            self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">        self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
        if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
            return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
        }

        let unit_direction = unit_vector(r.direction());
        let a = 0.5 * (unit_direction.y() + 1.0);
        (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
    }
}</code></pre>
<p><strong>Listing 38:</strong> [<a href="https://github.com/goldnor/code/blob/9b893f7953de35ce34fad2062845cb4d0202c21e/src/camera.rs">camera.rs</a>] <em>The camera::ray_color function</em></p>
<br>
<p>Now we move almost everything from the <code>main()</code> function into our new camera class. The only thing remaining in the <code>main()</code> function is the world construction. Here's the camera class with newly migrated code:</p>
<pre><code class="language-rust norun noplayground">use crate::{hittable::Hittable, prelude::*};

pub struct Camera {
    /// Ratio of image width over height
    pub aspect_ratio: f64,
    /// Rendered image width in pixel count
    pub image_width: i32,

    /// Rendered image height
    image_height: i32,
    /// Camera center
    center: Point3,
    /// Location of pixel 0, 0
    pixel00_loc: Point3,
    /// Offset to pixel to the right
    pixel_delta_u: Vec3,
    /// Offset to pixel below
    pixel_delta_v: Vec3,
}

impl Default for Camera {
    fn default() -&gt; Self {
        Self {
            aspect_ratio: 1.0,
            image_width: 100,
            image_height: Default::default(),
            center: Default::default(),
            pixel00_loc: Default::default(),
            pixel_delta_u: Default::default(),
            pixel_delta_v: Default::default(),
        }
    }
}

impl Camera {
    pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
        self.aspect_ratio = aspect_ratio;

        self
    }

    pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
        self.image_width = image_width;

        self
    }

    pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
        self.initialize();

        println!("P3");
        println!("{} {}", self.image_width, self.image_height);
        println!("255");

        for j in 0..self.image_height {
            info!("Scanlines remaining: {}", self.image_height - j);
            for i in 0..self.image_width {
                let pixel_center = self.pixel00_loc
                    + (i as f64) * self.pixel_delta_u
                    + (j as f64) * self.pixel_delta_v;
                let ray_direction = pixel_center - self.center;
                let r = Ray::new(self.center, ray_direction);

                let pixel_color = Self::ray_color(r, world);
                write_color(std::io::stdout(), pixel_color)?;
            }
        }
        info!("Done.");

        Ok(())
    }

    fn initialize(&amp;mut self) {
        self.image_height = {
            let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
            if image_height &lt; 1 { 1 } else { image_height }
        };

        self.center = Point3::new(0.0, 0.0, 0.0);

        // Determine viewport dimensions.
        let focal_length = 1.0;
        let viewport_height = 2.0;
        let viewport_width =
            viewport_height * (self.image_width as f64) / (self.image_height as f64);

        // Calculate the vectors across the horizontal and down the vertical viewport edges.
        let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
        let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);

        // Calculate the horizontal and vertical delta vectors from pixel to pixel.
        self.pixel_delta_u = viewport_u / self.image_width as f64;
        self.pixel_delta_v = viewport_v / self.image_height as f64;

        // Calculate the location of the upper left pixel.
        let viewport_upper_left =
            self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
        self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
    }

    fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">        if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span><span class="boring">            return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span><span class="boring">        }
</span>
<span class="boring">        let unit_direction = unit_vector(r.direction());
</span><span class="boring">        let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">        (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>    }
}</code></pre>
<p><strong>Listing 39:</strong> [<a href="https://github.com/goldnor/code/blob/9b893f7953de35ce34fad2062845cb4d0202c21e/src/camera.rs">camera.rs</a>] <em>The working camera class</em></p>
<br>
<p>And here's the much reduced main:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index a8d3932..27377f1 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,74 +1,15 @@
</span><span class="boring">-use code::{hittable::Hittable, hittable_list::HittableList, prelude::*, sphere::Sphere};
</span><span class="boring">-
</span>-fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">-    if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span><span class="boring">-        return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span><span class="boring">-    }
</span>-
<span class="boring">-    let unit_direction = unit_vector(r.direction());
</span><span class="boring">-    let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">-    (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>-}
-
<span class="boring">-fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">-    // Image
</span><span class="boring">-
</span><span class="boring">-    const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">-    const IMAGE_WIDTH: i32 = 400;
</span><span class="boring">-
</span><span class="boring">-    // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">-    const IMAGE_HEIGHT: i32 = {
</span><span class="boring">-        let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">-        if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">-    };
</span><span class="boring">-
</span><span class="boring">-    // World
</span>+use code::{camera::Camera, hittable_list::HittableList, prelude::*, sphere::Sphere};
 
+fn main() -&gt; std::io::Result&lt;()&gt; {
     let mut world = HittableList::new();
 
     world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
     world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
 
<span class="boring">-    // Camera
</span><span class="boring">-
</span><span class="boring">-    let focal_length = 1.0;
</span><span class="boring">-    let viewport_height = 2.0;
</span><span class="boring">-    let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">-    let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring">-
</span><span class="boring">-    // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">-    let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">-    let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring">-
</span><span class="boring">-    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">-    let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">-    let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring">-
</span><span class="boring">-    // Calculate the location of the upper left pixel.
</span><span class="boring">-    let viewport_upper_left =
</span><span class="boring">-        camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">-    let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring">-
</span><span class="boring">-    // Render
</span><span class="boring">-
</span>     env_logger::init();
<span class="boring">-    println!("P3");
</span><span class="boring">-    println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">-    println!("255");
</span><span class="boring">-
</span><span class="boring">-    for j in 0..IMAGE_HEIGHT {
</span><span class="boring">-        info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">-        for i in 0..IMAGE_WIDTH {
</span><span class="boring">-            let pixel_center =
</span><span class="boring">-                pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">-            let ray_direction = pixel_center - camera_center;
</span><span class="boring">-            let r = Ray::new(camera_center, ray_direction);
</span><span class="boring">-
</span><span class="boring">-            let pixel_color = ray_color(r, &amp;world);
</span><span class="boring">-            write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">-        }
</span><span class="boring">-    }
</span><span class="boring">-    info!("Done.");
</span> 
<span class="boring">-    Ok(())
</span>+    Camera::default()
+        .with_aspect_ratio(16.0 / 9.0)
+        .with_image_width(400)
+        .render(&amp;world)
 }
</code></pre>
<p><strong>Listing 40:</strong> [<a href="https://github.com/goldnor/code/blob/1ffb3c6125e9e07efe10f448e9f1adc0b5800a1d/src/main.rs">main.rs</a>] <em>The new main, using the new camera</em></p>
<br>
<p>Running this newly refactored program should give us the same rendered image as before.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-7a">
<p>The idiomatic Rust solution for this type of problem is the builder pattern. Important parameters can be set either directly with struct access or via a convenient method chain in the owning code. <a href="#fr-7a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="antialiasing"><a class="header" href="#antialiasing">Antialiasing</a></h1>
<p>If you zoom into the rendered images so far, you might notice the harsh “stair step” nature of edges in our rendered images. This stair-stepping is commonly referred to as “aliasing”, or “jaggies”. When a real camera takes a picture, there are usually no jaggies along edges, because the edge pixels are a blend of some foreground and some background. Consider that unlike our rendered images, a true image of the world is continuous. Put another way, the world (and any true image of it) has effectively infinite resolution. We can get the same effect by averaging a bunch of samples for each pixel.</p>
<p>With a single ray through the center of each pixel, we are performing what is commonly called <em>point sampling</em>. The problem with point sampling can be illustrated by rendering a small checkerboard far away. If this checkerboard consists of an 8×8 grid of black and white tiles, but only four rays hit it, then all four rays might intersect only white tiles, or only black, or some odd combination. In the real world, when we perceive a checkerboard far away with our eyes, we perceive it as a gray color, instead of sharp points of black and white. That's because our eyes are naturally doing what we want our ray tracer to do: integrate the (continuous function of) light falling on a particular (discrete) region of our rendered image.</p>
<p>Clearly we don't gain anything by just resampling the same ray through the pixel center multiple times — we'd just get the same result each time. Instead, we want to sample the light falling <em>around</em> the pixel, and then integrate those samples to approximate the true continuous result. So, how do we integrate the light falling around the pixel?</p>
<p>We'll adopt the simplest model: sampling the square region centered at the pixel that extends halfway to each of the four neighboring pixels. This is not the optimal approach, but it is the most straight-forward. (See <a href="https://www.researchgate.net/publication/244986797_A_Pixel_Is_Not_A_Little_Square_A_Pixel_Is_Not_A_Little_Square_A_Pixel_Is_Not_A_Little_Square">A Pixel is Not a Little Square</a> for a deeper dive into this topic.)</p>
<p><img src="chapters/antialiasing/../../imgs/fig-1.08-pixel-samples.jpg" alt="Pixel samples" /></p>
<p><strong>Figure 8:</strong> <em>Pixel samples</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="some-random-number-utilities-1"><a class="header" href="#some-random-number-utilities-1">Some Random Number Utilities <sup class="footnote-reference" id="fr-81a-1"><a href="#footnote-81a">1</a></sup></a></h2>
<p>We're going to need a random number generator that returns real random numbers. This function should return a canonical random number, which by convention falls in the range \( 0 \le n &lt; 1 \). The “less than” before the \( 1 \) is important, as we will sometimes take advantage of that.</p>
<p>A simple approach to this is to use the <code>std::rand()</code> function that can be found in <code>&lt;cstdlib&gt;</code>, which returns a random integer in the range <code>0</code> and <code>RAND_MAX</code>. Hence we can get a real random number as desired with the following code snippet, added to <code>rtweekend.h</code>:</p>
<pre><code class="language-rust norun noplayground">// Utility Functions

#[inline]
pub fn degrees_to_radians(degrees: f64) -&gt; f64 {
    degrees.to_radians()
}

#[inline]
pub fn random_double() -&gt; f64 {
    // Returns a random real in [0,1).
    rand::random::&lt;i32&gt;() as f64 / (i32::MAX as f64 + 1.0)
}

#[inline]
pub fn random_double_range(min: f64, max: f64) -&gt; f64 {
    // Returns a random real in [min,max).
    min + (max - min) * random_double()
}</code></pre>
<p><strong>Listing 41:</strong> [<a href="https://github.com/goldnor/code/blob/48d27302c1d726208b8f952050bcca45e53dc756/src/prelude.rs">prelude.rs</a>] <em>random_double() functions</em></p>
<p>C++ did not traditionally have a standard random number generator, but newer versions of C++ have addressed this issue with the <code>&lt;random&gt;</code> header (if imperfectly according to some experts). <sup class="footnote-reference" id="fr-81b-1"><a href="#footnote-81b">2</a></sup> If you want to use this, you can obtain a random number with the conditions we need as follows:</p>
<p><a name="l42"></a></p>
<pre><code class="language-rust norun noplayground">// Utility Functions

#[inline]
pub fn degrees_to_radians(degrees: f64) -&gt; f64 {
    degrees.to_radians()
}

#[inline]
pub fn random_double() -&gt; f64 {
    // Returns a random real in [0,1).
    rand::random()
}

#[inline]
pub fn random_double_range(min: f64, max: f64) -&gt; f64 {
    // Returns a random real in [min,max).
    rand::random_range(min..max)
}</code></pre>
<p><strong>Listing 42:</strong> [<a href="https://github.com/goldnor/code/blob/48d27302c1d726208b8f952050bcca45e53dc756/src/prelude.rs">prelude.rs</a>] <em>random_double() functions</em></p>
<hr>
<ol class="footnote-definition"><li id="footnote-81a">
<p>The utility functions, such as <code>degrees_to_radians</code>, were not mentioned in <a href="chapters/antialiasing/../surface_normals_and_multiple_objects/common_constants_and_utility_functions.html">chapter 6.7</a> since Rust already provides this functionality by default. The utility functions for randomness described in this chapter will also not be included in the code, as they only wrap functions implemented in the Rust <a href="https://crates.io/crates/rand">rand crate</a> (see <a href="chapters/antialiasing/some_random_number_utilities.html#l42">listing 42</a>). <a href="#fr-81a-1">↩</a></p>
</li>
<li id="footnote-81b">
<p>As far as I am aware, the Rust implementation is perfectly fine. <a href="#fr-81b-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="generating-pixels-with-multiple-samples"><a class="header" href="#generating-pixels-with-multiple-samples">Generating Pixels with Multiple Samples</a></h2>
<p>For a single pixel composed of multiple samples, we'll select samples from the area surrounding the pixel and average the resulting light (color) values together.</p>
<p>First we'll update the <code>write_color()</code> function to account for the number of samples we use: we need to find the average across all of the samples that we take. To do this, we'll add the full color from each iteration, and then finish with a single division (by the number of samples) at the end, before writing out the color. To ensure that the color components of the final result remain within the proper \( [0,1] \) bounds, we'll add and use a small helper function: <code>interval::clamp(x)</code>. <sup class="footnote-reference" id="fr-82a-1"><a href="#footnote-82a">1</a></sup> <sup class="footnote-reference" id="fr-82b-1"><a href="#footnote-82b">2</a></sup></p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/interval.rs b/src/interval.rs
</span><span class="boring">index 509fddf..482d922 100644
</span><span class="boring">--- a/src/interval.rs
</span><span class="boring">+++ b/src/interval.rs
</span><span class="boring">@@ -1,39 +1,43 @@
</span><span class="boring"> #[derive(Debug, Clone, Copy)]
</span><span class="boring"> pub struct Interval {
</span><span class="boring">     pub min: f64,
</span><span class="boring">     pub max: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Default for Interval {
</span><span class="boring">     fn default() -&gt; Self {
</span><span class="boring">         Self::EMPTY
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Interval {
<span class="boring">     pub const EMPTY: Self = Self {
</span><span class="boring">         min: f64::INFINITY,
</span><span class="boring">         max: f64::NEG_INFINITY,
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     pub const UNIVERSE: Self = Self {
</span><span class="boring">         min: f64::NEG_INFINITY,
</span><span class="boring">         max: f64::INFINITY,
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">-    pub fn new(min: f64, max: f64) -&gt; Self {
</span><span class="boring">+    pub const fn new(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Self { min, max }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn size(&amp;self) -&gt; f64 {
</span><span class="boring">         self.max - self.min
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn contains(&amp;self, x: f64) -&gt; bool {
</span><span class="boring">         self.min &lt;= x &amp;&amp; x &lt;= self.max
</span><span class="boring">     }
</span> 
     pub fn surrounds(&amp;self, x: f64) -&gt; bool {
         self.min &lt; x &amp;&amp; x &lt; self.max
     }
+
+    pub const fn clamp(&amp;self, x: f64) -&gt; f64 {
+        x.clamp(self.min, self.max)
+    }
 }</code></pre>
<p><strong>Listing 43:</strong> [<a href="https://github.com/goldnor/code/blob/c2937087b619981d108b6774b790af1d59316329/src/interval.rs">interval.rs</a>] <em>The interval::clamp() utility function</em></p>
<br>
<p>Here's the updated <code>write_color()</code> function that incorporates the interval clamping function:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/color.rs b/src/color.rs
</span><span class="boring">index c645ca2..1615d55 100644
</span><span class="boring">--- a/src/color.rs
</span><span class="boring">+++ b/src/color.rs
</span><span class="boring">@@ -1,15 +1,18 @@
</span><span class="boring">-use crate::vec3::Vec3;
</span>+use crate::prelude::*;
 
 pub type Color = Vec3;
 
 pub fn write_color(mut out: impl std::io::Write, pixel_color: Color) -&gt; std::io::Result&lt;()&gt; {
     let r = pixel_color.x();
     let g = pixel_color.y();
     let b = pixel_color.z();
 
<span class="boring">-    let rbyte = (255.999 * r) as i32;
</span><span class="boring">-    let gbyte = (255.999 * g) as i32;
</span><span class="boring">-    let bbyte = (255.999 * b) as i32;
</span>+    // Translate the [0,1] component values to the byte range [0,255].
+    const INTENSITY: Interval = Interval::new(0.000, 0.999);
+    let rbyte = (256.0 * INTENSITY.clamp(r)) as i32;
+    let gbyte = (256.0 * INTENSITY.clamp(g)) as i32;
+    let bbyte = (256.0 * INTENSITY.clamp(b)) as i32;
 
+    // Write out the pixel color components.
     writeln!(out, "{rbyte} {gbyte} {bbyte}")
 }</code></pre>
<p><strong>Listing 44:</strong> [<a href="https://github.com/goldnor/code/blob/f9b02376bc5c4d4f7337d6fef6903506086925da/src/color.rs">color.rs</a>] <em>The multi-sample write_color() function</em></p>
<br>
<p>Now let's update the camera class to define and use a new <code>camera::get_ray(i,j)</code> function, which will generate different samples for each pixel. This function will use a new helper function <code>sample_square()</code> that generates a random sample point within the unit square centered at the origin. We then transform the random sample from this ideal square back to the particular pixel we're currently sampling.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index 73dc5cc..f181b03 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,110 +1,151 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span> pub struct Camera {
     /// Ratio of image width over height
     pub aspect_ratio: f64,
     /// Rendered image width in pixel count
     pub image_width: i32,
+    // Count of random samples for each pixel
+    pub samples_per_pixel: i32,
 
     /// Rendered image height
     image_height: i32,
+    // Color scale factor for a sum of pixel samples
+    pixel_samples_scale: f64,
     /// Camera center
     center: Point3,
     /// Location of pixel 0, 0
     pixel00_loc: Point3,
     /// Offset to pixel to the right
     pixel_delta_u: Vec3,
     /// Offset to pixel below
     pixel_delta_v: Vec3,
 }
 
 impl Default for Camera {
     fn default() -&gt; Self {
         Self {
             aspect_ratio: 1.0,
             image_width: 100,
+            samples_per_pixel: 10,
             image_height: Default::default(),
+            pixel_samples_scale: Default::default(),
             center: Default::default(),
             pixel00_loc: Default::default(),
             pixel_delta_u: Default::default(),
             pixel_delta_v: Default::default(),
         }
     }
 }
 
 impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span> 
+    pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
+        self.samples_per_pixel = samples_per_pixel;
+
+        self
+    }
+
     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
         self.initialize();
 
         println!("P3");
         println!("{} {}", self.image_width, self.image_height);
         println!("255");
 
         for j in 0..self.image_height {
             info!("Scanlines remaining: {}", self.image_height - j);
             for i in 0..self.image_width {
<span class="boring">-                let pixel_center = self.pixel00_loc
</span><span class="boring">-                    + (i as f64) * self.pixel_delta_u
</span><span class="boring">-                    + (j as f64) * self.pixel_delta_v;
</span><span class="boring">-                let ray_direction = pixel_center - self.center;
</span><span class="boring">-                let r = Ray::new(self.center, ray_direction);
</span><span class="boring">-
</span><span class="boring">-                let pixel_color = Self::ray_color(r, world);
</span><span class="boring">-                write_color(std::io::stdout(), pixel_color)?;
</span>+                let mut pixel_color = Color::new(0.0, 0.0, 0.0);
+                for _sample in 0..self.samples_per_pixel {
+                    let r = self.get_ray(i, j);
+                    pixel_color += Self::ray_color(r, world);
+                }
+                write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
             }
         }
         info!("Done.");
 
         Ok(())
     }
 
     fn initialize(&amp;mut self) {
         self.image_height = {
             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
             if image_height &lt; 1 { 1 } else { image_height }
         };
 
+        self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
+
         self.center = Point3::new(0.0, 0.0, 0.0);
 
<span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span>     }
 
+    fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
+        // Construct a camera ray originating from the origin and directed at randomly sampled
+        // point around the pixel location i, j.
+
+        let offset = Self::sample_square();
+        let pixel_sample = self.pixel00_loc
+            + ((i as f64 + offset.x()) * self.pixel_delta_u)
+            + ((j as f64 + offset.y()) * self.pixel_delta_v);
+
+        let ray_origin = self.center;
+        let ray_direction = pixel_sample - ray_origin;
+
+        Ray::new(ray_origin, ray_direction)
+    }
+
+    fn sample_square() -&gt; Vec3 {
+        // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
+        Vec3::new(
+            rand::random::&lt;f64&gt;() - 0.5,
+            rand::random::&lt;f64&gt;() - 0.5,
+            0.0,
+        )
+    }
+
<span class="boring">+    fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">+        // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">+        radius * random_in_unit_disk()
</span><span class="boring">+    }
</span><span class="boring">+
</span>     fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">         if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span><span class="boring">             return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span><span class="boring">         }
</span> 
<span class="boring">         let unit_direction = unit_vector(r.direction());
</span><span class="boring">         let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>     }
 }</code></pre>
<p><strong>Listing 45:</strong> [<a href="https://github.com/goldnor/code/blob/8f64151623f1e58e249d00f11a8cac23523fec1b/src/camera.rs">camera.rs</a>] <em>Camera with samples-per-pixel parameter</em></p>
<br>
<p>(In addition to the new <code>sample_square()</code> function above, you'll also find the function <code>sample_disk()</code> in the Github source code. This is included in case you'd like to experiment with non-square pixels, but we won't be using it in this book. sample_disk() depends on the function random_in_unit_disk() which is defined later on.)</p>
<p>Main is updated to set the new camera parameter.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 27377f1..9f08807 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,15 +1,16 @@
</span><span class="boring"> use code::{camera::Camera, hittable_list::HittableList, prelude::*, sphere::Sphere};
</span><span class="boring"> 
</span> fn main() -&gt; std::io::Result&lt;()&gt; {
<span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span> 
     Camera::default()
         .with_aspect_ratio(16.0 / 9.0)
         .with_image_width(400)
+        .with_samples_per_pixel(100)
         .render(&amp;world)
 }</code></pre>
<p><strong>Listing 46:</strong> [<a href="https://github.com/goldnor/code/blob/d4b3a2498a7ed1a3a51ade2c425683a7ff4ad018/src/main.rs">main.rs</a>] <em>Setting the new samples-per-pixel parameter</em></p>
<br>
<p>Zooming into the image that is produced, we can see the difference in edge pixels.</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/antialiasing/../../imgs/img-1.06-antialias-before-after.png" alt="Before and after antialiasing">
<!-- ![x](../../imgs/img-1.06-antialias-before-after.png) -->
<p><strong>Image 6:</strong> <em>Before and after antialiasing</em></p>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-82a">
<p>For this purpose, version 1.50 of Rust introduced the <code>f64::clamp(self, min, max)</code> <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.clamp">function</a> (the C++17 standard introduced a similar <a href="https://en.cppreference.com/w/cpp/algorithm/clamp.html">function</a> called <code>std::clamp(v, lo, hi)</code>). <a href="#fr-82a-1">↩</a></p>
</li>
<li id="footnote-82b">
<p>The function is const, meaning it can be used to initialise const variables. This will be demonstrated in the next listing. <a href="#fr-82b-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="diffuse-materials"><a class="header" href="#diffuse-materials">Diffuse Materials</a></h1>
<p>Now that we have objects and multiple rays per pixel, we can make some realistic looking materials. We’ll start with diffuse materials (also called <em>matte</em>).</p>
<p>One question is whether we mix and match geometry and materials (so that we can assign a material to multiple spheres, or vice versa) or if geometry and materials are tightly bound (which could be useful for procedural objects where the geometry and material are linked). We’ll go with separate — which is usual in most renderers — but do be aware that there are alternative approaches.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-simple-diffuse-material"><a class="header" href="#a-simple-diffuse-material">A Simple Diffuse Material</a></h2>
<p>Diffuse objects that don’t emit their own light merely take on the color of their surroundings, but they do modulate that with their own intrinsic color. Light that reflects off a diffuse surface has its direction randomized, so, if we send three rays into a crack between two diffuse surfaces they will each have different random behavior:</p>
<p><img src="chapters/diffuse_materials/../../imgs/fig-1.09-light-bounce.jpg" alt="Light ray bounces" /></p>
<p><strong>Figure 9:</strong> <em>Light ray bounces</em></p>
<br>
<p>They might also be absorbed rather than reflected. The darker the surface, the more likely the ray is absorbed (that’s why it's dark!). Really any algorithm that randomizes direction will produce surfaces that look matte. Let's start with the most intuitive: a surface that randomly bounces a ray equally in all directions. For this material, a ray that hits the surface has an equal probability of bouncing in any direction away from the surface.</p>
<p><img src="chapters/diffuse_materials/../../imgs/fig-1.10-random-vec-horizon.jpg" alt="Equal reflection above the horizon" /></p>
<p><strong>Figure 10:</strong> <em>Equal reflection above the horizon</em></p>
<br>
<p>This very intuitive material is the simplest kind of diffuse and — indeed — many of the first raytracing papers used this diffuse method (before adopting a more accurate method that we'll be implementing a little bit later). We don't currently have a way to randomly reflect a ray, so we'll need to add a few functions to our vector utility header. The first thing we need is the ability to generate arbitrary random vectors:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index d4352e1..f9228ac 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,190 +1,202 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span> impl Vec3 {
<span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length_squared(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
</span><span class="boring">     }
</span>+
+    pub fn random() -&gt; Self {
+        Vec3 { e: rand::random() }
+    }
+
+    pub fn random_range(min: f64, max: f64) -&gt; Self {
+        Vec3::new(
+            rand::random_range(min..max),
+            rand::random_range(min..max),
+            rand::random_range(min..max),
+        )
+    }
 }
 
<span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn unit_vector(v: Vec3) -&gt; Vec3 {
</span><span class="boring">     v / v.length()
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_in_unit_disk() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::new(
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             0.0,
</span><span class="boring">         );
</span><span class="boring">         if p.length_squared() &lt; 1.0 {
</span><span class="boring">             return p;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 47:</strong> [<a href="https://github.com/goldnor/code/blob/e486826f6cf6e4b50e5ac2f23f9797ae39c3f99d/src/vec3.rs">vec3.rs</a>] <em>vec3 random utility functions</em></p>
<br>
<p>Then we need to figure out how to manipulate a random vector so that we only get results that are on the surface of a hemisphere. There are analytical methods of doing this, but they are actually surprisingly complicated to understand, and quite a bit complicated to implement. Instead, we'll use what is typically the easiest algorithm: A rejection method. A rejection method works by repeatedly generating random samples until we produce a sample that meets the desired criteria. In other words, keep rejecting bad samples until you find a good one.</p>
<p>There are many equally valid ways of generating a random vector on a hemisphere using the rejection method, but for our purposes we will go with the simplest, which is:</p>
<ol>
<li>Generate a random vector inside the unit sphere</li>
<li>Normalize this vector to extend it to the sphere surface</li>
<li>Invert the normalized vector if it falls onto the wrong hemisphere</li>
</ol>
<p>First, we will use a rejection method to generate the random vector inside the unit sphere (that is, a sphere of radius \( 1 \)). Pick a random point inside the cube enclosing the unit sphere (that is, where \( 𝑥 \), \( 𝑦 \), and \( 𝑧 \) are all in the range \( [−1,+1] \)). If this point lies outside the unit sphere, then generate a new one until we find one that lies inside or on the unit sphere.</p>
<p><img src="chapters/diffuse_materials/../../imgs/fig-1.11-sphere-vec.jpg" alt="Two vectors were rejected before finding a good one (pre-normalization)" /></p>
<p><strong>Figure 11:</strong> <em>Two vectors were rejected before finding a good one (pre-normalization)</em></p>
<br>
<p><img src="chapters/diffuse_materials/../../imgs/fig-1.12-sphere-unit-vec.jpg" alt="The accepted random vector is normalized to produce a unit vector" /></p>
<p><strong>Figure 12:</strong> <em>The accepted random vector is normalized to produce a unit vector</em></p>
<br>
<p>Here's our first draft of the function:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index f9228ac..e3ee3ea 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,202 +1,213 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span><span class="boring"> impl Vec3 {
</span><span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length_squared(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random() -&gt; Self {
</span><span class="boring">         Vec3 { e: rand::random() }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random_range(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn unit_vector(v: Vec3) -&gt; Vec3 {
</span><span class="boring">     v / v.length()
</span><span class="boring"> }
</span><span class="boring"> 
</span> #[inline]
+pub fn random_unit_vector() -&gt; Vec3 {
+    loop {
+        let p = Vec3::random_range(-1.0, 1.0);
+        let lensq = p.length_squared();
+        if lensq &lt;= 1.0 {
+            return p / f64::sqrt(lensq);
+        }
+    }
+}
<span class="boring">+
</span><span class="boring">+#[inline]
</span><span class="boring"> pub fn random_in_unit_disk() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::new(
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             0.0,
</span><span class="boring">         );
</span><span class="boring">         if p.length_squared() &lt; 1.0 {
</span><span class="boring">             return p;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 48:</strong> [<a href="https://github.com/goldnor/code/blob/7f3d292868eea2acfcbcc87b7fb42341c59c55e1/src/vec3.rs">vec3.rs</a>] <em>The random_unit_vector() function, version one</em></p>
<br>
<p>Sadly, we have a small floating-point abstraction leak to deal with. Since floating-point numbers have finite precision, a very small value can underflow to zero when squared. So if all three coordinates are small enough (that is, very near the center of the sphere), the norm of the vector will be zero, and thus normalizing will yield the bogus vector \( [\pm \infty, \pm \infty, \pm \infty] \). To fix this, we'll also reject points that lie inside this “black hole” around the center. With double precision (64-bit floats), we can safely support values greater than 10−160.</p>
<p>Here's our more robust function:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index e3ee3ea..ba86acc 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,213 +1,213 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span><span class="boring"> impl Vec3 {
</span><span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length_squared(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random() -&gt; Self {
</span><span class="boring">         Vec3 { e: rand::random() }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random_range(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn unit_vector(v: Vec3) -&gt; Vec3 {
</span><span class="boring">     v / v.length()
</span><span class="boring"> }
</span><span class="boring"> 
</span> #[inline]
 pub fn random_unit_vector() -&gt; Vec3 {
     loop {
         let p = Vec3::random_range(-1.0, 1.0);
         let lensq = p.length_squared();
<span class="boring">-        if lensq &lt;= 1.0 {
</span>+        if 1e-160 &lt; lensq &amp;&amp; lensq &lt;= 1.0 {
             return p / f64::sqrt(lensq);
         }
     }
 }
<span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_in_unit_disk() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::new(
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             0.0,
</span><span class="boring">         );
</span><span class="boring">         if p.length_squared() &lt; 1.0 {
</span><span class="boring">             return p;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 49:</strong> [<a href="https://github.com/goldnor/code/blob/ad94c6aff825a9cf5c9a0983bfefc7a5e3900725/src/vec3.rs">vec3.rs</a>] <em>The random_unit_vector() function, version two</em></p>
<br>
<p>Now that we have a random unit vector, we can determine if it is on the correct hemisphere by comparing against the surface normal:</p>
<p><img src="chapters/diffuse_materials/../../imgs/fig-1.13-surface-normal.jpg" alt="The normal vector tells us which hemisphere we need" /></p>
<p><strong>Figure 13:</strong> <em>The normal vector tells us which hemisphere we need</em></p>
<br>
<p>We can take the dot product of the surface normal and our random vector to determine if it's in the correct hemisphere. If the dot product is positive, then the vector is in the correct hemisphere. If the dot product is negative, then we need to invert the vector.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index ba86acc..4cb969b 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,213 +1,223 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span><span class="boring"> impl Vec3 {
</span><span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length_squared(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random() -&gt; Self {
</span><span class="boring">         Vec3 { e: rand::random() }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random_range(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn unit_vector(v: Vec3) -&gt; Vec3 {
</span><span class="boring">     v / v.length()
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_unit_vector() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::random_range(-1.0, 1.0);
</span><span class="boring">         let lensq = p.length_squared();
</span><span class="boring">         if 1e-160 &lt; lensq &amp;&amp; lensq &lt;= 1.0 {
</span><span class="boring">             return p / f64::sqrt(lensq);
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> #[inline]
+pub fn random_on_hemisphere(normal: Vec3) -&gt; Vec3 {
+    let on_unit_sphere = random_unit_vector();
+    if dot(on_unit_sphere, normal) &gt; 0.0 {
+        on_unit_sphere
+    } else {
+        -on_unit_sphere
+    }
+}
<span class="boring">+
</span><span class="boring">+#[inline]
</span><span class="boring"> pub fn random_in_unit_disk() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::new(
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             0.0,
</span><span class="boring">         );
</span><span class="boring">         if p.length_squared() &lt; 1.0 {
</span><span class="boring">             return p;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 50:</strong> [<a href="https://github.com/goldnor/code/blob/ed6876bfb6d8535e8c38b088f219963a12040a42/src/vec3.rs">vec3.rs</a>] <em>The random_on_hemisphere() function</em></p>
<br>
<p>If a ray bounces off of a material and keeps 100% of its color, then we say that the material is <em>white</em>. If a ray bounces off of a material and keeps 0% of its color, then we say that the material is black. As a first demonstration of our new diffuse material we'll set the <code>ray_color</code> function to return 50% of the color from a bounce. We should expect to get a nice gray color.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index f181b03..181eb64 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,151 +1,152 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub struct Camera {
</span><span class="boring">     /// Ratio of image width over height
</span><span class="boring">     pub aspect_ratio: f64,
</span><span class="boring">     /// Rendered image width in pixel count
</span><span class="boring">     pub image_width: i32,
</span><span class="boring">     // Count of random samples for each pixel
</span><span class="boring">     pub samples_per_pixel: i32,
</span><span class="boring"> 
</span><span class="boring">     /// Rendered image height
</span><span class="boring">     image_height: i32,
</span><span class="boring">     // Color scale factor for a sum of pixel samples
</span><span class="boring">     pixel_samples_scale: f64,
</span><span class="boring">     /// Camera center
</span><span class="boring">     center: Point3,
</span><span class="boring">     /// Location of pixel 0, 0
</span><span class="boring">     pixel00_loc: Point3,
</span><span class="boring">     /// Offset to pixel to the right
</span><span class="boring">     pixel_delta_u: Vec3,
</span><span class="boring">     /// Offset to pixel below
</span><span class="boring">     pixel_delta_v: Vec3,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Default for Camera {
</span><span class="boring">     fn default() -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             aspect_ratio: 1.0,
</span><span class="boring">             image_width: 100,
</span><span class="boring">             samples_per_pixel: 10,
</span><span class="boring">             image_height: Default::default(),
</span><span class="boring">             pixel_samples_scale: Default::default(),
</span><span class="boring">             center: Default::default(),
</span><span class="boring">             pixel00_loc: Default::default(),
</span><span class="boring">             pixel_delta_u: Default::default(),
</span><span class="boring">             pixel_delta_v: Default::default(),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn initialize(&amp;mut self) {
</span><span class="boring">         self.image_height = {
</span><span class="boring">             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">             if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">         };
</span><span class="boring"> 
</span><span class="boring">         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
</span><span class="boring"> 
</span><span class="boring">         self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span> 
     fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
         if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
<span class="boring">-            return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span>+            let direction = random_on_hemisphere(rec.normal);
+            return 0.5 * Self::ray_color(Ray::new(rec.p, direction), world);
         }
 
         let unit_direction = unit_vector(r.direction());
         let a = 0.5 * (unit_direction.y() + 1.0);
         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
     }
 }</code></pre>
<p><strong>Listing 51:</strong> [<a href="https://github.com/goldnor/code/blob/6add135dade4bf646ea0543faade188411b1df81/src/camera.rs">camera.rs</a>] <em>ray_color() using a random ray direction</em></p>
<br>
<p>... Indeed we do get rather nice gray spheres:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/diffuse_materials/../../imgs/img-1.07-first-diffuse.png" alt="First render of a diffuse sphere">
<p><strong>Image 7:</strong> <em>First render of a diffuse sphere</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="limiting-the-number-of-child-rays"><a class="header" href="#limiting-the-number-of-child-rays">Limiting the Number of Child Rays</a></h2>
<p>There's one potential problem lurking here. Notice that the <code>ray_color</code> function is recursive. When will it stop recursing? When it fails to hit anything. In some cases, however, that may be a long time — long enough to blow the stack. To guard against that, let's limit the maximum recursion depth, returning no light contribution at the maximum depth:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index 181eb64..2abb78e 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,152 +1,166 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span> pub struct Camera {
     /// Ratio of image width over height
     pub aspect_ratio: f64,
     /// Rendered image width in pixel count
     pub image_width: i32,
     // Count of random samples for each pixel
     pub samples_per_pixel: i32,
+    // Maximum number of ray bounces into scene
+    pub max_depth: i32,
 
     /// Rendered image height
     image_height: i32,
     // Color scale factor for a sum of pixel samples
     pixel_samples_scale: f64,
     /// Camera center
     center: Point3,
     /// Location of pixel 0, 0
     pixel00_loc: Point3,
     /// Offset to pixel to the right
     pixel_delta_u: Vec3,
     /// Offset to pixel below
     pixel_delta_v: Vec3,
 }
 
 impl Default for Camera {
     fn default() -&gt; Self {
         Self {
             aspect_ratio: 1.0,
             image_width: 100,
             samples_per_pixel: 10,
+            max_depth: 10,
             image_height: Default::default(),
             pixel_samples_scale: Default::default(),
             center: Default::default(),
             pixel00_loc: Default::default(),
             pixel_delta_u: Default::default(),
             pixel_delta_v: Default::default(),
         }
     }
 }
 
 impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span> 
+    pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
+        self.max_depth = max_depth;
+
+        self
+    }
+
     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
         self.initialize();
 
         println!("P3");
         println!("{} {}", self.image_width, self.image_height);
         println!("255");
 
         for j in 0..self.image_height {
             info!("Scanlines remaining: {}", self.image_height - j);
             for i in 0..self.image_width {
                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
                 for _sample in 0..self.samples_per_pixel {
                     let r = self.get_ray(i, j);
<span class="boring">-                    pixel_color += Self::ray_color(r, world);
</span>+                    pixel_color += Self::ray_color(r, self.max_depth, world);
                 }
                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
             }
         }
         info!("Done.");
 
         Ok(())
     }
<span class="boring"> 
</span><span class="boring">     fn initialize(&amp;mut self) {
</span><span class="boring">         self.image_height = {
</span><span class="boring">             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">             if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">         };
</span><span class="boring"> 
</span><span class="boring">         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
</span><span class="boring"> 
</span><span class="boring">         self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span> 
<span class="boring">-    fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
</span>+    fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
+        // If we've exceeded the ray bounce limit, no more light is gathered.
+        if depth &lt;= 0 {
+            return Color::new(0.0, 0.0, 0.0);
+        }
+
         if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
             let direction = random_on_hemisphere(rec.normal);
<span class="boring">-            return 0.5 * Self::ray_color(Ray::new(rec.p, direction), world);
</span>+            return 0.5 * Self::ray_color(Ray::new(rec.p, direction), depth - 1, world);
         }
 
         let unit_direction = unit_vector(r.direction());
         let a = 0.5 * (unit_direction.y() + 1.0);
         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
     }
 }</code></pre>
<p><strong>Listing 52:</strong> [<a href="https://github.com/goldnor/code/blob/36edc44f5198d8ed04f5b50641cccd792f435f26/src/camera.rs">camera.rs</a>] <em>camera::ray_color() with depth limiting</em></p>
<br>
<p>Update the main() function to use this new depth limit:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 9f08807..a016213 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,16 +1,17 @@
</span><span class="boring"> use code::{camera::Camera, hittable_list::HittableList, prelude::*, sphere::Sphere};
</span><span class="boring"> 
</span> fn main() -&gt; std::io::Result&lt;()&gt; {
<span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span> 
     Camera::default()
         .with_aspect_ratio(16.0 / 9.0)
         .with_image_width(400)
         .with_samples_per_pixel(100)
+        .with_max_depth(50)
         .render(&amp;world)
 }</code></pre>
<p><strong>Listing 53:</strong> [<a href="https://github.com/goldnor/code/blob/7be08e72109304cab1df8c2d9d6a9a17fe9a936b/src/main.rs">main.rs</a>] <em>Using the new ray depth limiting</em></p>
<br>
<p>For this very simple scene we should get basically the same result:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/diffuse_materials/../../imgs/img-1.08-second-diffuse.png" alt="Second render of a diffuse sphere with limited bounces">
<p><strong>Image 8:</strong> <em>Second render of a diffuse sphere with limited bounces</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fixing-shadow-acne"><a class="header" href="#fixing-shadow-acne">Fixing Shadow Acne</a></h2>
<p>There’s also a subtle bug that we need to address. A ray will attempt to accurately calculate the intersection point when it intersects with a surface. Unfortunately for us, this calculation is susceptible to floating point rounding errors which can cause the intersection point to be ever so slightly off. This means that the origin of the next ray, the ray that is randomly scattered off of the surface, is unlikely to be perfectly flush with the surface. It might be just above the surface. It might be just below the surface. If the ray's origin is just below the surface then it could intersect with that surface again. Which means that it will find the nearest surface at \( 𝑡 = 0.00000001 \) or whatever floating point approximation the hit function gives us. The simplest hack to address this is just to ignore hits that are very close to the calculated intersection point:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index 2abb78e..eea2b1f 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,166 +1,166 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub struct Camera {
</span><span class="boring">     /// Ratio of image width over height
</span><span class="boring">     pub aspect_ratio: f64,
</span><span class="boring">     /// Rendered image width in pixel count
</span><span class="boring">     pub image_width: i32,
</span><span class="boring">     // Count of random samples for each pixel
</span><span class="boring">     pub samples_per_pixel: i32,
</span><span class="boring">     // Maximum number of ray bounces into scene
</span><span class="boring">     pub max_depth: i32,
</span><span class="boring"> 
</span><span class="boring">     /// Rendered image height
</span><span class="boring">     image_height: i32,
</span><span class="boring">     // Color scale factor for a sum of pixel samples
</span><span class="boring">     pixel_samples_scale: f64,
</span><span class="boring">     /// Camera center
</span><span class="boring">     center: Point3,
</span><span class="boring">     /// Location of pixel 0, 0
</span><span class="boring">     pixel00_loc: Point3,
</span><span class="boring">     /// Offset to pixel to the right
</span><span class="boring">     pixel_delta_u: Vec3,
</span><span class="boring">     /// Offset to pixel below
</span><span class="boring">     pixel_delta_v: Vec3,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Default for Camera {
</span><span class="boring">     fn default() -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             aspect_ratio: 1.0,
</span><span class="boring">             image_width: 100,
</span><span class="boring">             samples_per_pixel: 10,
</span><span class="boring">             max_depth: 10,
</span><span class="boring">             image_height: Default::default(),
</span><span class="boring">             pixel_samples_scale: Default::default(),
</span><span class="boring">             center: Default::default(),
</span><span class="boring">             pixel00_loc: Default::default(),
</span><span class="boring">             pixel_delta_u: Default::default(),
</span><span class="boring">             pixel_delta_v: Default::default(),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
</span><span class="boring">         self.max_depth = max_depth;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, self.max_depth, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn initialize(&amp;mut self) {
</span><span class="boring">         self.image_height = {
</span><span class="boring">             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">             if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">         };
</span><span class="boring"> 
</span><span class="boring">         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
</span><span class="boring"> 
</span><span class="boring">         self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span> 
     fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
         // If we've exceeded the ray bounce limit, no more light is gathered.
         if depth &lt;= 0 {
             return Color::new(0.0, 0.0, 0.0);
         }
 
<span class="boring">-        if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span>+        if let Some(rec) = world.hit(r, Interval::new(0.001, INFINITY)) {
             let direction = random_on_hemisphere(rec.normal);
             return 0.5 * Self::ray_color(Ray::new(rec.p, direction), depth - 1, world);
         }
 
         let unit_direction = unit_vector(r.direction());
         let a = 0.5 * (unit_direction.y() + 1.0);
         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
     }
 }</code></pre>
<p><strong>Listing 54:</strong> [<a href="chapters/diffuse_materials/TODO">camera.rs</a>] <em>Calculating reflected ray origins with tolerance</em></p>
<br>
<p>This gets rid of the shadow acne problem. Yes it is really called that. Here's the result:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/diffuse_materials/../../imgs/img-1.09-no-acne.png" alt="Diffuse sphere with no shadow acne">
<p><strong>Image 9:</strong> <em>Diffuse sphere with no shadow acne</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="true-lambertian-reflection"><a class="header" href="#true-lambertian-reflection">True Lambertian Reflection</a></h2>
<p>Scattering reflected rays evenly about the hemisphere produces a nice soft diffuse model, but we can definitely do better. A more accurate representation of real diffuse objects is the <em>Lambertian</em> distribution. This distribution scatters reflected rays in a manner that is proportional to \( cos(\phi) \), where \( \phi \) is the angle between the reflected ray and the surface normal. This means that a reflected ray is most likely to scatter in a direction near the surface normal, and less likely to scatter in directions away from the normal. This non-uniform Lambertian distribution does a better job of modeling material reflection in the real world than our previous uniform scattering.</p>
<p>We can create this distribution by adding a random unit vector to the normal vector. At the point of intersection on a surface there is the hit point, \( \mathbf{p} \), and there is the normal of the surface, \( \mathbf{n} \). At the point of intersection, this surface has exactly two sides, so there can only be two unique unit spheres tangent to any intersection point (one unique sphere for each side of the surface). These two unit spheres will be displaced from the surface by the length of their radius, which is exactly one for a unit sphere.</p>
<p>One sphere will be displaced in the direction of the surface's normal (\( \mathbf{n} \)) and one sphere will be displaced in the opposite direction (\( -\mathbf{n} \)). This leaves us with two spheres of unit size that will only be just touching the surface at the intersection point. From this, one of the spheres will have its center at \( (\mathbf{P} + \mathbf{n}) \) and the other sphere will have its center at \( (\mathbf{P} - \mathbf{n}) \). The sphere with a center at \( (\mathbf{P} - \mathbf{n}) \) is considered inside the surface, whereas the sphere with center \( (\mathbf{P} + \mathbf{n}) \) is considered outside the surface.</p>
<p>We want to select the tangent unit sphere that is on the same side of the surface as the ray origin. Pick a random point \( \mathbf{S} \) on this unit radius sphere and send a ray from the hit point \( \mathbf{P} \) to the random point \( \mathbf{S} \) (this is the vector \( (\mathbf{S} - \mathbf{P}) \):</p>
<p><img src="chapters/diffuse_materials/../../imgs/fig-1.14-rand-unitvec.jpg" alt="Randomly generating a vector according to Lambertian distribution" /></p>
<p><strong>Figure 14:</strong> <em>Randomly generating a vector according to Lambertian distribution</em></p>
<br>
<p>The change is actually fairly minimal:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index eea2b1f..3a2e772 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,166 +1,166 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub struct Camera {
</span><span class="boring">     /// Ratio of image width over height
</span><span class="boring">     pub aspect_ratio: f64,
</span><span class="boring">     /// Rendered image width in pixel count
</span><span class="boring">     pub image_width: i32,
</span><span class="boring">     // Count of random samples for each pixel
</span><span class="boring">     pub samples_per_pixel: i32,
</span><span class="boring">     // Maximum number of ray bounces into scene
</span><span class="boring">     pub max_depth: i32,
</span><span class="boring"> 
</span><span class="boring">     /// Rendered image height
</span><span class="boring">     image_height: i32,
</span><span class="boring">     // Color scale factor for a sum of pixel samples
</span><span class="boring">     pixel_samples_scale: f64,
</span><span class="boring">     /// Camera center
</span><span class="boring">     center: Point3,
</span><span class="boring">     /// Location of pixel 0, 0
</span><span class="boring">     pixel00_loc: Point3,
</span><span class="boring">     /// Offset to pixel to the right
</span><span class="boring">     pixel_delta_u: Vec3,
</span><span class="boring">     /// Offset to pixel below
</span><span class="boring">     pixel_delta_v: Vec3,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Default for Camera {
</span><span class="boring">     fn default() -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             aspect_ratio: 1.0,
</span><span class="boring">             image_width: 100,
</span><span class="boring">             samples_per_pixel: 10,
</span><span class="boring">             max_depth: 10,
</span><span class="boring">             image_height: Default::default(),
</span><span class="boring">             pixel_samples_scale: Default::default(),
</span><span class="boring">             center: Default::default(),
</span><span class="boring">             pixel00_loc: Default::default(),
</span><span class="boring">             pixel_delta_u: Default::default(),
</span><span class="boring">             pixel_delta_v: Default::default(),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
</span><span class="boring">         self.max_depth = max_depth;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, self.max_depth, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn initialize(&amp;mut self) {
</span><span class="boring">         self.image_height = {
</span><span class="boring">             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">             if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">         };
</span><span class="boring"> 
</span><span class="boring">         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
</span><span class="boring"> 
</span><span class="boring">         self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span> 
     fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
         // If we've exceeded the ray bounce limit, no more light is gathered.
         if depth &lt;= 0 {
             return Color::new(0.0, 0.0, 0.0);
         }
 
         if let Some(rec) = world.hit(r, Interval::new(0.001, INFINITY)) {
<span class="boring">-            let direction = random_on_hemisphere(rec.normal);
</span>+            let direction = rec.normal + random_unit_vector();
             return 0.5 * Self::ray_color(Ray::new(rec.p, direction), depth - 1, world);
         }
 
         let unit_direction = unit_vector(r.direction());
         let a = 0.5 * (unit_direction.y() + 1.0);
         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
     }
 }</code></pre>
<p><strong>Listing 55:</strong> [<a href="https://github.com/goldnor/code/blob/2b7ff0c812b41279018742c656ee5fa894bf50c3/src/camera.rs">camera.rs</a>] <em>ray_color() with replacement diffuse</em></p>
<br>
<p>After rendering we get a similar image:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/diffuse_materials/../../imgs/img-1.10-correct-lambertian.png" alt="Correct rendering of Lambertian spheres">
<p><strong>Image 10:</strong> <em>Correct rendering of Lambertian spheres</em></p>
<br>
<p>It's hard to tell the difference between these two diffuse methods, given that our scene of two spheres is so simple, but you should be able to notice two important visual differences:</p>
<ol>
<li>The shadows are more pronounced after the change</li>
<li>Both spheres are tinted blue from the sky after the change</li>
</ol>
<p>Both of these changes are due to the less uniform scattering of the light rays—more rays are scattering toward the normal. This means that for diffuse objects, they will appear <em>darker</em> because less light bounces toward the camera. For the shadows, more light bounces straight-up, so the area underneath the sphere is darker.</p>
<p>Not a lot of common, everyday objects are perfectly diffuse, so our visual intuition of how these objects behave under light can be poorly formed. As scenes become more complicated over the course of the book, you are encouraged to switch between the different diffuse renderers presented here. Most scenes of interest will contain a large amount of diffuse materials. You can gain valuable insight by understanding the effect of different diffuse methods on the lighting of a scene.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-gamma-correction-for-accurate-color-intensity"><a class="header" href="#using-gamma-correction-for-accurate-color-intensity">Using Gamma Correction for Accurate Color Intensity</a></h2>
<p>Note the shadowing under the sphere. The picture is very dark, but our spheres only absorb half the energy of each bounce, so they are 50% reflectors. The spheres should look pretty bright (in real life, a light grey) but they appear to be rather dark. We can see this more clearly if we walk through the full brightness gamut for our diffuse material. We start by setting the reflectance of the <code>ray_color</code> function from <code>0.5</code> (50%) to <code>0.1</code> (10%):</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index 3a2e772..e6c60c3 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,166 +1,166 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub struct Camera {
</span><span class="boring">     /// Ratio of image width over height
</span><span class="boring">     pub aspect_ratio: f64,
</span><span class="boring">     /// Rendered image width in pixel count
</span><span class="boring">     pub image_width: i32,
</span><span class="boring">     // Count of random samples for each pixel
</span><span class="boring">     pub samples_per_pixel: i32,
</span><span class="boring">     // Maximum number of ray bounces into scene
</span><span class="boring">     pub max_depth: i32,
</span><span class="boring"> 
</span><span class="boring">     /// Rendered image height
</span><span class="boring">     image_height: i32,
</span><span class="boring">     // Color scale factor for a sum of pixel samples
</span><span class="boring">     pixel_samples_scale: f64,
</span><span class="boring">     /// Camera center
</span><span class="boring">     center: Point3,
</span><span class="boring">     /// Location of pixel 0, 0
</span><span class="boring">     pixel00_loc: Point3,
</span><span class="boring">     /// Offset to pixel to the right
</span><span class="boring">     pixel_delta_u: Vec3,
</span><span class="boring">     /// Offset to pixel below
</span><span class="boring">     pixel_delta_v: Vec3,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Default for Camera {
</span><span class="boring">     fn default() -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             aspect_ratio: 1.0,
</span><span class="boring">             image_width: 100,
</span><span class="boring">             samples_per_pixel: 10,
</span><span class="boring">             max_depth: 10,
</span><span class="boring">             image_height: Default::default(),
</span><span class="boring">             pixel_samples_scale: Default::default(),
</span><span class="boring">             center: Default::default(),
</span><span class="boring">             pixel00_loc: Default::default(),
</span><span class="boring">             pixel_delta_u: Default::default(),
</span><span class="boring">             pixel_delta_v: Default::default(),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
</span><span class="boring">         self.max_depth = max_depth;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, self.max_depth, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn initialize(&amp;mut self) {
</span><span class="boring">         self.image_height = {
</span><span class="boring">             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">             if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">         };
</span><span class="boring"> 
</span><span class="boring">         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
</span><span class="boring"> 
</span><span class="boring">         self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span> 
     fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
         // If we've exceeded the ray bounce limit, no more light is gathered.
         if depth &lt;= 0 {
             return Color::new(0.0, 0.0, 0.0);
         }
 
         if let Some(rec) = world.hit(r, Interval::new(0.001, INFINITY)) {
             let direction = rec.normal + random_unit_vector();
<span class="boring">-            return 0.5 * Self::ray_color(Ray::new(rec.p, direction), depth - 1, world);
</span>+            return 0.1 * Self::ray_color(Ray::new(rec.p, direction), depth - 1, world);
         }
 
         let unit_direction = unit_vector(r.direction());
         let a = 0.5 * (unit_direction.y() + 1.0);
         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
     }
 }</code></pre>
<p><strong>Listing 56:</strong> [<a href="https://github.com/goldnor/code/blob/b01ae43747d7bcf10be39364d907ab708701d2db/src/camera.rs">camera.rs</a>] <em>ray_color() with 10% reflectance</em></p>
<br>
<p>We render out at this new 10% reflectance. We then set reflectance to 30% and render again. We repeat for 50%, 70%, and finally 90%. You can overlay these images from left to right in the photo editor of your choice and you should get a very nice visual representation of the increasing brightness of your chosen gamut. This is the one that we've been working with so far:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/diffuse_materials/../../imgs/img-1.11-linear-gamut.png" alt="The gamut of our renderer so far">
<p><strong>Image 11:</strong> <em>The gamut of our renderer so far</em></p>
<br>
<p>f you look closely, or if you use a color picker, you should notice that the 50% reflectance render (the one in the middle) is far too dark to be half-way between white and black (middle-gray). Indeed, the 70% reflector is closer to middle-gray. The reason for this is that almost all computer programs assume that an image is “gamma corrected” before being written into an image file. This means that the 0 to 1 values have some transform applied before being stored as a byte. Images with data that are written without being transformed are said to be in <em>linear space</em>, whereas images that are transformed are said to be in <em>gamma space</em>. It is likely that the image viewer you are using is expecting an image in gamma space, but we are giving it an image in linear space. This is the reason why our image appears inaccurately dark.</p>
<p>There are many good reasons for why images should be stored in gamma space, but for our purposes we just need to be aware of it. We are going to transform our data into gamma space so that our image viewer can more accurately display our image. As a simple approximation, we can use “gamma 2” as our transform, which is the power that you use when going from gamma space to linear space. We need to go from linear space to gamma space, which means taking the inverse of “gamma 2", which means an exponent of \( 1/gamma \), which is just the square-root. We'll also want to ensure that we robustly handle negative inputs.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/color.rs b/src/color.rs
</span><span class="boring">index 1615d55..d69fd1d 100644
</span><span class="boring">--- a/src/color.rs
</span><span class="boring">+++ b/src/color.rs
</span><span class="boring">@@ -1,18 +1,32 @@
</span><span class="boring"> use crate::prelude::*;
</span><span class="boring"> 
</span><span class="boring"> pub type Color = Vec3;
</span><span class="boring"> 
</span>+#[inline]
+pub fn linear_to_gamma(linear_component: f64) -&gt; f64 {
+    if linear_component &gt; 0.0 {
+        f64::sqrt(linear_component)
+    } else {
+        0.0
+    }
+}
+
 pub fn write_color(mut out: impl std::io::Write, pixel_color: Color) -&gt; std::io::Result&lt;()&gt; {
     let r = pixel_color.x();
     let g = pixel_color.y();
     let b = pixel_color.z();
 
+    // Apply a linear to gamma transform for gamma 2
+    let r = linear_to_gamma(r);
+    let g = linear_to_gamma(g);
+    let b = linear_to_gamma(b);
+
     // Translate the [0,1] component values to the byte range [0,255].
     const INTENSITY: Interval = Interval::new(0.000, 0.999);
     let rbyte = (256.0 * INTENSITY.clamp(r)) as i32;
     let gbyte = (256.0 * INTENSITY.clamp(g)) as i32;
     let bbyte = (256.0 * INTENSITY.clamp(b)) as i32;
 
     // Write out the pixel color components.
     writeln!(out, "{rbyte} {gbyte} {bbyte}")
 }</code></pre>
<p><strong>Listing 57:</strong> [<a href="https://github.com/goldnor/code/blob/39f58a27fa6c25081163b184082bc7805a2dabcd/src/color.rs">color.rs</a>] <em>write_color(), with gamma correction</em></p>
<br>
<p>Using this gamma correction, we now get a much more consistent ramp from darkness to lightness:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/diffuse_materials/../../imgs/img-1.12-gamma-gamut.png" alt="The gamut of our renderer, gamma-corrected">
<p><strong>Image 12:</strong> <em>The gamut of our renderer, gamma-corrected</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="an-abstract-class-for-materials"><a class="header" href="#an-abstract-class-for-materials">An Abstract Class for Materials</a></h2>
<p>If we want different objects to have different materials, we have a design decision. We could have a universal material type with lots of parameters so any individual material type could just ignore the parameters that don't affect it. This is not a bad approach. Or we could have an abstract material class that encapsulates unique behavior. I am a fan of the latter approach. For our program the material needs to do two things:</p>
<ol>
<li>Produce a scattered ray (or say it absorbed the incident ray).</li>
<li>If scattered, say how much the ray should be attenuated.</li>
</ol>
<p>This suggests the abstract class:</p>
<pre><code class="language-rust norun noplayground">use crate::{hittable::HitRecord, prelude::*};

pub trait Material {
    fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
        None
    }
}</code></pre>
<p><strong>Listing 58:</strong> [<a href="https://github.com/goldnor/code/blob/9e2b407ffc6f22c19f7e3e60baf638c5797f15e2/src/material.rs">material.rs</a>] <em>The material class</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-data-structure-to-describe-ray-object-intersections"><a class="header" href="#a-data-structure-to-describe-ray-object-intersections">A Data Structure to Describe Ray-Object Intersections</a></h2>
<p>The <code>hit_record</code> is to avoid a bunch of arguments so we can stuff whatever info we want in there. You can use arguments instead of an encapsulated type, it’s just a matter of taste. Hittables and materials need to be able to reference the other's type in code so there is some circularity of the references. In C++ we add the line class material; to tell the compiler that material is a class that will be defined later. Since we're just specifying a pointer to the class, the compiler doesn't need to know the details of the class, solving the circular reference issue. <sup class="footnote-reference" id="fr-102a-1"><a href="#footnote-102a">1</a></sup></p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable.rs b/src/hittable.rs
</span><span class="boring">index 1b65b92..000dc1d 100644
</span><span class="boring">--- a/src/hittable.rs
</span><span class="boring">+++ b/src/hittable.rs
</span><span class="boring">@@ -1,27 +1,43 @@
</span><span class="boring">-use crate::prelude::*;
</span>+use crate::{
+    material::{Lambertian, Material},
+    prelude::*,
+};
 
-#[derive(Debug, Default, Clone, Copy)]
+#[derive(Clone)]
 pub struct HitRecord {
     pub p: Point3,
     pub normal: Vec3,
+    pub mat: Rc&lt;dyn Material&gt;,
     pub t: f64,
     pub front_face: bool,
 }
 
+impl Default for HitRecord {
+    fn default() -&gt; Self {
+        Self {
+            p: Default::default(),
+            normal: Default::default(),
+            mat: Rc::new(Lambertian::default()),
+            t: Default::default(),
+            front_face: Default::default(),
+        }
+    }
+}
<span class="boring">+
</span><span class="boring"> impl HitRecord {
</span><span class="boring">     pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">         // Sets the hit record normal vector.
</span><span class="boring">         // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring"> 
</span><span class="boring">         self.front_face = dot(r.direction(), outward_normal) &lt; 0.0;
</span><span class="boring">         self.normal = if self.front_face {
</span><span class="boring">             outward_normal
</span><span class="boring">         } else {
</span><span class="boring">             -outward_normal
</span><span class="boring">         };
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub trait Hittable {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 59:</strong> [<a href="https://github.com/goldnor/code/blob/c2bd376435e53106f8045a293708f0e5c0f2d549/src/hittable.rs">hittable.rs</a>] <em>Hit record with added material pointer</em> <sup class="footnote-reference" id="fr-102b-1"><a href="#footnote-102b">2</a></sup></p>
<br>
<p><code>hit_record</code> is just a way to stuff a bunch of arguments into a class so we can send them as a group. When a ray hits a surface (a particular sphere for example), the material pointer in the <code>hit_record</code> will be set to point at the material pointer the sphere was given when it was set up in <code>main()</code> when we start. When the <code>ray_color()</code> routine gets the <code>hit_record</code> it can call member functions of the material pointer to find out what ray, if any, is scattered.</p>
<p>To achieve this, <code>hit_record</code> needs to be told the material that is assigned to the sphere.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index a2710b4..2b0026a 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,56 +1,61 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     hittable::{HitRecord, Hittable},
</span><span class="boring">+    material::{Lambertian, Material},
</span><span class="boring">     prelude::*,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring">-#[derive(Debug, Clone, Copy)]
</span>+#[derive(Clone)]
 pub struct Sphere {
     center: Point3,
     radius: f64,
+    mat: Rc&lt;dyn Material&gt;,
 }
 
 impl Sphere {
     pub fn new(center: Point3, radius: f64) -&gt; Self {
         Self {
             center,
             radius: f64::max(0.0, radius),
+            // TODO: Initialize the material pointer `mat`.
<span class="boring">+            mat: Rc::new(Lambertian::default()),
</span>         }
     }
 }
 
 impl Hittable for Sphere {
     fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt; {
<span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span><span class="boring"> 
</span><span class="boring">         // Find the nearest root that lies in the acceptable range.
</span><span class="boring">         let mut root = (h - sqrtd) / a;
</span><span class="boring">         if !ray_t.surrounds(root) {
</span><span class="boring">             root = (h + sqrtd) / a;
</span><span class="boring">             if !ray_t.surrounds(root) {
</span><span class="boring">                 return None;
</span><span class="boring">             }
</span><span class="boring">         }
</span> 
         let t = root;
         let p = r.at(t);
         let mut rec = HitRecord {
             t,
             p,
+            mat: self.mat.clone(),
             ..Default::default()
         };
         let outward_normal = (p - self.center) / self.radius;
         rec.set_face_normal(r, outward_normal);
 
         Some(rec)
     }
 }</code></pre>
<p><strong>Listing 60:</strong> [<a href="https://github.com/goldnor/code/blob/157464117d578d98dfb765727c52c7b1e176dd22/src/sphere.rs">sphere.rs</a>] <em>Ray-sphere intersection with added material information</em></p>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-102a">
<p>In Rust traits needs to be imported using the <code>use</code> keyword. Circular references are not a problem in Rust, since the <code>use</code> keyword does <em>not</em> simply copy the header file in comparison to the C++ <code>include</code> macro. <a href="#fr-102a-1">↩</a></p>
</li>
<li id="footnote-102b">
<p><code>HitRecord</code> can no longer derive <code>Default</code> since <code>Rc&lt;dyn Material&gt;</code> can not implement <code>Default</code>. Instead, the default material is set to a Lambertian. <a href="#fr-102b-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="modeling-light-scatter-and-reflectance"><a class="header" href="#modeling-light-scatter-and-reflectance">Modeling Light Scatter and Reflectance</a></h2>
<p>Here and throughout these books we will use the term <em>albedo</em> (Latin for “whiteness”). Albedo is a precise technical term in some disciplines, but in all cases it is used to define some form of <em>fractional reflectance</em>. Albedo will vary with material color and (as we will later implement for glass materials) can also vary with incident viewing direction (the direction of the incoming ray).</p>
<p>Lambertian (diffuse) reflectance can either always scatter and attenuate light according to its reflectance \( \mathbf{R} \), or it can sometimes scatter (with probability \( (1 - \mathbf{R}) \)) with no attenuation (where a ray that isn't scattered is just absorbed into the material). It could also be a mixture of both those strategies. We will choose to always scatter, so implementing Lambertian materials becomes a simple task:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/material.rs b/src/material.rs
</span><span class="boring">index 13b34c3..5702b9c 100644
</span><span class="boring">--- a/src/material.rs
</span><span class="boring">+++ b/src/material.rs
</span><span class="boring">@@ -1,7 +1,28 @@
</span><span class="boring"> use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub trait Material {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         None
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring">+
</span>+#[derive(Debug, Default, Clone, Copy)]
+pub struct Lambertian {
+    albedo: Color,
+}
+
+impl Lambertian {
+    pub fn new(albedo: Color) -&gt; Self {
+        Self { albedo }
+    }
+}
+
+impl Material for Lambertian {
+    fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
+        let scatter_direction = rec.normal + random_unit_vector();
+        let scattered = Ray::new(rec.p, scatter_direction);
+        let attenuation = self.albedo;
+
+        Some((scattered, attenuation))
+    }
+}</code></pre>
<p><strong>Listing 61:</strong> [<a href="https://github.com/goldnor/code/blob/c2bd376435e53106f8045a293708f0e5c0f2d549/src/material.rs">material.rs</a>] <em>The new lambertian material class</em></p>
<br>
<p>Note the third option: we could scatter with some fixed probability \( p \) and have attenuation be \( albedo/p \). Your choice.</p>
<p>If you read the code above carefully, you'll notice a small chance of mischief. If the random unit vector we generate is exactly opposite the normal vector, the two will sum to zero, which will result in a zero scatter direction vector. This leads to bad scenarios later on (infinities and NaNs), so we need to intercept the condition before we pass it on.</p>
<p>In service of this, we'll create a new vector method — <code>vec3::near_zero()</code> — that returns true if the vector is very close to zero in all dimensions.</p>
<p>The following changes will use the C++ standard library function <code>std::fabs</code>, which returns the absolute value of its input. <sup class="footnote-reference" id="fr-103a-1"><a href="#footnote-103a">1</a></sup></p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index 4cb969b..3348fef 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,223 +1,229 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span> impl Vec3 {
<span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span> 
     pub fn length_squared(&amp;self) -&gt; f64 {
         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
     }
 
+    pub fn near_zero(&amp;self) -&gt; bool {
+        // Return true if the vector is close to zero in all dimensions.
+        const S: f64 = 1e-8;
+        self.e[0].abs() &lt; S &amp;&amp; self.e[1].abs() &lt; S &amp;&amp; self.e[2].abs() &lt; S
+    }
+
<span class="boring">     pub fn random() -&gt; Self {
</span><span class="boring">         Vec3 { e: rand::random() }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random_range(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">         )
</span><span class="boring">     }
</span> }
<span class="boring"> 
</span><span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn unit_vector(v: Vec3) -&gt; Vec3 {
</span><span class="boring">     v / v.length()
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_unit_vector() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::random_range(-1.0, 1.0);
</span><span class="boring">         let lensq = p.length_squared();
</span><span class="boring">         if 1e-160 &lt; lensq &amp;&amp; lensq &lt;= 1.0 {
</span><span class="boring">             return p / f64::sqrt(lensq);
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_on_hemisphere(normal: Vec3) -&gt; Vec3 {
</span><span class="boring">     let on_unit_sphere = random_unit_vector();
</span><span class="boring">     if dot(on_unit_sphere, normal) &gt; 0.0 {
</span><span class="boring">         on_unit_sphere
</span><span class="boring">     } else {
</span><span class="boring">         -on_unit_sphere
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_in_unit_disk() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::new(
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             0.0,
</span><span class="boring">         );
</span><span class="boring">         if p.length_squared() &lt; 1.0 {
</span><span class="boring">             return p;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 62:</strong> [<a href="https://github.com/goldnor/code/blob/e811cea593ba76384389c842fc0210124998c5e2/src/vec3.rs">vec3.rs</a>] <em>The vec3::near_zero() method</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/material.rs b/src/material.rs
</span><span class="boring">index 5702b9c..1b49e15 100644
</span><span class="boring">--- a/src/material.rs
</span><span class="boring">+++ b/src/material.rs
</span><span class="boring">@@ -1,28 +1,34 @@
</span><span class="boring"> use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub trait Material {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         None
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Lambertian {
</span><span class="boring">     albedo: Color,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Lambertian {
</span><span class="boring">     pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">         Self { albedo }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Material for Lambertian {
     fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
<span class="boring">-        let scatter_direction = rec.normal + random_unit_vector();
</span>+        let mut scatter_direction = rec.normal + random_unit_vector();
+
+        // Catch degenerate scatter direction
+        if scatter_direction.near_zero() {
+            scatter_direction = rec.normal;
+        }
+
         let scattered = Ray::new(rec.p, scatter_direction);
         let attenuation = self.albedo;
 
         Some((scattered, attenuation))
     }
 }</code></pre>
<p><strong>Listing 63:</strong> [<a href="https://github.com/goldnor/code/blob/5230c29a2d01fd09e037b9c6c326ec4cd88ef791/src/material.rs">material.rs</a>] <em>Lambertian scatter, bullet-proof</em></p>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-103a">
<p>Rust version is <code>f64::abs</code>. <a href="#fr-103a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="mirrored-light-reflection"><a class="header" href="#mirrored-light-reflection">Mirrored Light Reflection</a></h2>
<p>For polished metals the ray won’t be randomly scattered. The key question is: How does a ray get reflected from a metal mirror? Vector math is our friend here:</p>
<p><img src="chapters/metal/../../imgs/fig-1.15-reflection.jpg" alt="Ray reflection" /></p>
<p><strong>Figure 15:</strong> <em>Ray reflection</em></p>
<br>
<p>The reflected ray direction in red is just \( \mathbf{v} + 2 \mathbf{b} \). In our design, \( \mathbf{n} \) is a unit vector (length one), but \( \mathbf{v} \) may not be. To get the vector \( \mathbf{b} \), we scale the normal vector by the length of the projection of \( \mathbf{v} \) onto \( \mathbf{n} \), which is given by the dot product \( \mathbf{v} \cdot \mathbf{n} \). (If \( \mathbf{n} \) were not a unit vector, we would also need to divide this dot product by the length of \( \mathbf{n} \).) Finally, because \( \mathbf{b} \) points <em>into</em> the surface, and we want \( \mathbf{b} \) to point <em>out</em> of the surface, we need to negate this projection length.</p>
<p>Putting everything together, we get the following computation of the reflected vector:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index 3348fef..4cb0b6f 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,229 +1,234 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span><span class="boring"> impl Vec3 {
</span><span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length_squared(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn near_zero(&amp;self) -&gt; bool {
</span><span class="boring">         // Return true if the vector is close to zero in all dimensions.
</span><span class="boring">         const S: f64 = 1e-8;
</span><span class="boring">         self.e[0].abs() &lt; S &amp;&amp; self.e[1].abs() &lt; S &amp;&amp; self.e[2].abs() &lt; S
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random() -&gt; Self {
</span><span class="boring">         Vec3 { e: rand::random() }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random_range(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn unit_vector(v: Vec3) -&gt; Vec3 {
</span><span class="boring">     v / v.length()
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_unit_vector() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::random_range(-1.0, 1.0);
</span><span class="boring">         let lensq = p.length_squared();
</span><span class="boring">         if 1e-160 &lt; lensq &amp;&amp; lensq &lt;= 1.0 {
</span><span class="boring">             return p / f64::sqrt(lensq);
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> #[inline]
 pub fn random_on_hemisphere(normal: Vec3) -&gt; Vec3 {
<span class="boring">     let on_unit_sphere = random_unit_vector();
</span><span class="boring">     if dot(on_unit_sphere, normal) &gt; 0.0 {
</span><span class="boring">         on_unit_sphere
</span><span class="boring">     } else {
</span><span class="boring">         -on_unit_sphere
</span><span class="boring">     }
</span> }
 
 #[inline]
+pub fn reflect(v: Vec3, n: Vec3) -&gt; Vec3 {
+    v - 2.0 * dot(v, n) * n
+}
<span class="boring">+
</span><span class="boring">+#[inline]
</span><span class="boring"> pub fn random_in_unit_disk() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::new(
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             0.0,
</span><span class="boring">         );
</span><span class="boring">         if p.length_squared() &lt; 1.0 {
</span><span class="boring">             return p;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 64:</strong> [<a href="https://github.com/goldnor/code/blob/5454ed7161f531954e1b14fb97bd52d11b7331a4/src/vec3.rs">vec3.rs</a>] <em>vec3 reflection function</em></p>
<br>
<p>The metal material just reflects rays using that formula:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/material.rs b/src/material.rs
</span><span class="boring">index 1b49e15..8475d17 100644
</span><span class="boring">--- a/src/material.rs
</span><span class="boring">+++ b/src/material.rs
</span><span class="boring">@@ -1,34 +1,55 @@
</span><span class="boring"> use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub trait Material {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         None
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Lambertian {
</span><span class="boring">     albedo: Color,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Lambertian {
</span><span class="boring">     pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">         Self { albedo }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Material for Lambertian {
<span class="boring">     fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut scatter_direction = rec.normal + random_unit_vector();
</span> 
<span class="boring">         // Catch degenerate scatter direction
</span><span class="boring">         if scatter_direction.near_zero() {
</span><span class="boring">             scatter_direction = rec.normal;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let scattered = Ray::new(rec.p, scatter_direction);
</span><span class="boring">         let attenuation = self.albedo;
</span><span class="boring"> 
</span><span class="boring">         Some((scattered, attenuation))
</span><span class="boring">     }
</span> }
+
+#[derive(Debug, Default, Clone, Copy)]
+pub struct Metal {
+    albedo: Color,
+}
+
+impl Metal {
+    pub fn new(albedo: Color) -&gt; Self {
+        Self { albedo }
+    }
+}
+
+impl Material for Metal {
+    fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
+        let reflected = reflect(r_in.direction(), rec.normal);
+        let scattered = Ray::new(rec.p, reflected);
+        let attenuation = self.albedo;
+
+        Some((scattered, attenuation))
+    }
+}</code></pre>
<p><strong>Listing 65:</strong> [<a href="https://github.com/goldnor/code/blob/c5fbfbf8809f5009c7c5953bcb1bcae1493267de/src/material.rs">material.rs</a>] <em>Metal material with reflectance function</em></p>
<br>
<p>We need to modify the <code>ray_color()</code> function for all of our changes:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index e6c60c3..1927898 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,166 +1,168 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub struct Camera {
</span><span class="boring">     /// Ratio of image width over height
</span><span class="boring">     pub aspect_ratio: f64,
</span><span class="boring">     /// Rendered image width in pixel count
</span><span class="boring">     pub image_width: i32,
</span><span class="boring">     // Count of random samples for each pixel
</span><span class="boring">     pub samples_per_pixel: i32,
</span><span class="boring">     // Maximum number of ray bounces into scene
</span><span class="boring">     pub max_depth: i32,
</span><span class="boring"> 
</span><span class="boring">     /// Rendered image height
</span><span class="boring">     image_height: i32,
</span><span class="boring">     // Color scale factor for a sum of pixel samples
</span><span class="boring">     pixel_samples_scale: f64,
</span><span class="boring">     /// Camera center
</span><span class="boring">     center: Point3,
</span><span class="boring">     /// Location of pixel 0, 0
</span><span class="boring">     pixel00_loc: Point3,
</span><span class="boring">     /// Offset to pixel to the right
</span><span class="boring">     pixel_delta_u: Vec3,
</span><span class="boring">     /// Offset to pixel below
</span><span class="boring">     pixel_delta_v: Vec3,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Default for Camera {
</span><span class="boring">     fn default() -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             aspect_ratio: 1.0,
</span><span class="boring">             image_width: 100,
</span><span class="boring">             samples_per_pixel: 10,
</span><span class="boring">             max_depth: 10,
</span><span class="boring">             image_height: Default::default(),
</span><span class="boring">             pixel_samples_scale: Default::default(),
</span><span class="boring">             center: Default::default(),
</span><span class="boring">             pixel00_loc: Default::default(),
</span><span class="boring">             pixel_delta_u: Default::default(),
</span><span class="boring">             pixel_delta_v: Default::default(),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
</span><span class="boring">         self.max_depth = max_depth;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, self.max_depth, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn initialize(&amp;mut self) {
</span><span class="boring">         self.image_height = {
</span><span class="boring">             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">             if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">         };
</span><span class="boring"> 
</span><span class="boring">         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
</span><span class="boring"> 
</span><span class="boring">         self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span> 
     fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
         // If we've exceeded the ray bounce limit, no more light is gathered.
         if depth &lt;= 0 {
             return Color::new(0.0, 0.0, 0.0);
         }
 
         if let Some(rec) = world.hit(r, Interval::new(0.001, INFINITY)) {
<span class="boring">-            let direction = rec.normal + random_unit_vector();
</span><span class="boring">-            return 0.1 * Self::ray_color(Ray::new(rec.p, direction), depth - 1, world);
</span>+            if let Some((scattered, attenuation)) = rec.mat.scatter(r, rec.clone()) {
+                return attenuation * Self::ray_color(scattered, depth - 1, world);
+            }
+            return Color::new(0.0, 0.0, 0.0);
         }
 
         let unit_direction = unit_vector(r.direction());
         let a = 0.5 * (unit_direction.y() + 1.0);
         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
     }
 }</code></pre>
<p><strong>Listing 66:</strong> [<a href="https://github.com/goldnor/code/blob/6e7548e7e604786c7ee88cc924ef6015cb6b49d7/src/camera.rs">camera.rs</a>] <em>Ray color with scattered reflectance</em></p>
<br>
<p>Now we'll update the sphere constructor to initialize the material pointer <code>mat</code>:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index 2b0026a..2a6b2ce 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,61 +1,60 @@
</span> use crate::{
     hittable::{HitRecord, Hittable},
<span class="boring">-    material::{Lambertian, Material},
</span>+    material::Material,
     prelude::*,
 };
<span class="boring"> 
</span><span class="boring"> #[derive(Clone)]
</span><span class="boring"> pub struct Sphere {
</span><span class="boring">     center: Point3,
</span><span class="boring">     radius: f64,
</span><span class="boring">     mat: Rc&lt;dyn Material&gt;,
</span><span class="boring"> }
</span> 
 impl Sphere {
<span class="boring">-    pub fn new(center: Point3, radius: f64) -&gt; Self {
</span>+    pub fn new(center: Point3, radius: f64, mat: Rc&lt;dyn Material&gt;) -&gt; Self {
         Self {
             center,
             radius: f64::max(0.0, radius),
<span class="boring">-            // TODO: Initialize the material pointer `mat`.
</span><span class="boring">-            mat: Rc::new(Lambertian::default()),
</span>+            mat,
         }
     }
 }
<span class="boring"> 
</span><span class="boring"> impl Hittable for Sphere {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt; {
</span><span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span><span class="boring"> 
</span><span class="boring">         // Find the nearest root that lies in the acceptable range.
</span><span class="boring">         let mut root = (h - sqrtd) / a;
</span><span class="boring">         if !ray_t.surrounds(root) {
</span><span class="boring">             root = (h + sqrtd) / a;
</span><span class="boring">             if !ray_t.surrounds(root) {
</span><span class="boring">                 return None;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let t = root;
</span><span class="boring">         let p = r.at(t);
</span><span class="boring">         let mut rec = HitRecord {
</span><span class="boring">             t,
</span><span class="boring">             p,
</span><span class="boring">             mat: self.mat.clone(),
</span><span class="boring">             ..Default::default()
</span><span class="boring">         };
</span><span class="boring">         let outward_normal = (p - self.center) / self.radius;
</span><span class="boring">         rec.set_face_normal(r, outward_normal);
</span><span class="boring"> 
</span><span class="boring">         Some(rec)
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 67:</strong> [<a href="https://github.com/goldnor/code/blob/29d828944db9e970983d3e7a5b2b3ad827e3991b/src/sphere.rs">sphere.rs</a>] <em>Initializing sphere with a material</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-scene-with-metal-spheres"><a class="header" href="#a-scene-with-metal-spheres">A Scene with Metal Spheres</a></h2>
<p>Now let’s add some metal spheres to our scene:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index a016213..4f0fceb 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,17 +1,46 @@
</span><span class="boring">-use code::{camera::Camera, hittable_list::HittableList, prelude::*, sphere::Sphere};
</span>+use code::{
+    camera::Camera,
+    hittable_list::HittableList,
+    material::{Lambertian, Metal},
+    prelude::*,
+    sphere::Sphere,
+};
 
 fn main() -&gt; std::io::Result&lt;()&gt; {
     let mut world = HittableList::new();
 
<span class="boring">-    world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
</span><span class="boring">-    world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
</span>+    let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
+    let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
+    let material_left = Rc::new(Metal::new(Color::new(0.8, 0.8, 0.8)));
+    let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2)));
+
+    world.add(Rc::new(Sphere::new(
+        Point3::new(0.0, -100.5, -1.0),
+        100.0,
+        material_ground,
+    )));
+    world.add(Rc::new(Sphere::new(
+        Point3::new(0.0, 0.0, -1.2),
+        0.5,
+        material_center,
+    )));
+    world.add(Rc::new(Sphere::new(
+        Point3::new(-1.0, 0.0, -1.0),
+        0.5,
+        material_left,
+    )));
+    world.add(Rc::new(Sphere::new(
+        Point3::new(1.0, 0.0, -1.0),
+        0.5,
+        material_right,
+    )));
 
     env_logger::init();
 
     Camera::default()
         .with_aspect_ratio(16.0 / 9.0)
         .with_image_width(400)
         .with_samples_per_pixel(100)
         .with_max_depth(50)
         .render(&amp;world)
 }</code></pre>
<p><strong>Listing 68:</strong> [<a href="https://github.com/goldnor/code/blob/29d828944db9e970983d3e7a5b2b3ad827e3991b/src/main.rs">main.rs</a>] <em>Scene with metal spheres</em></p>
<br>
<p>Which gives:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/metal/../../imgs/img-1.13-metal-shiny.png" alt="Shiny metal">
<p><strong>Image 13:</strong> <em>Shiny metal</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fuzzy-reflection"><a class="header" href="#fuzzy-reflection">Fuzzy Reflection</a></h2>
<p>We can also randomize the reflected direction by using a small sphere and choosing a new endpoint for the ray. We'll use a random point from the surface of a sphere centered on the original endpoint, scaled by the fuzz factor.</p>
<p><img src="chapters/metal/../../imgs/fig-1.16-reflect-fuzzy.jpg" alt="Generating fuzzed reflection rays" /></p>
<p><strong>Figure 16:</strong> <em>Generating fuzzed reflection rays</em></p>
<br>
<p>The bigger the fuzz sphere, the fuzzier the reflections will be. This suggests adding a fuzziness parameter that is just the radius of the sphere (so zero is no perturbation). The catch is that for big spheres or grazing rays, we may scatter below the surface. We can just have the surface absorb those.</p>
<p>Also note that in order for the fuzz sphere to make sense, it needs to be consistently scaled compared to the reflection vector, which can vary in length arbitrarily. To address this, we need to normalize the reflected ray.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/material.rs b/src/material.rs
</span><span class="boring">index 8475d17..e52f6f3 100644
</span><span class="boring">--- a/src/material.rs
</span><span class="boring">+++ b/src/material.rs
</span><span class="boring">@@ -1,55 +1,58 @@
</span><span class="boring"> use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub trait Material {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         None
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Lambertian {
</span><span class="boring">     albedo: Color,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Lambertian {
</span><span class="boring">     pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">         Self { albedo }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Material for Lambertian {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut scatter_direction = rec.normal + random_unit_vector();
</span><span class="boring"> 
</span><span class="boring">         // Catch degenerate scatter direction
</span><span class="boring">         if scatter_direction.near_zero() {
</span><span class="boring">             scatter_direction = rec.normal;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let scattered = Ray::new(rec.p, scatter_direction);
</span><span class="boring">         let attenuation = self.albedo;
</span><span class="boring"> 
</span><span class="boring">         Some((scattered, attenuation))
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> #[derive(Debug, Default, Clone, Copy)]
 pub struct Metal {
     albedo: Color,
+    fuzz: f64,
 }
 
 impl Metal {
<span class="boring">-    pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">-        Self { albedo }
</span>+    pub fn new(albedo: Color, fuzz: f64) -&gt; Self {
+        let fuzz = if fuzz &lt; 1.0 { fuzz } else { 1.0 };
+        Self { albedo, fuzz }
     }
 }
 
 impl Material for Metal {
     fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
<span class="boring">-        let reflected = reflect(r_in.direction(), rec.normal);
</span>+        let mut reflected = reflect(r_in.direction(), rec.normal);
+        reflected = unit_vector(reflected) + (self.fuzz * random_unit_vector());
         let scattered = Ray::new(rec.p, reflected);
         let attenuation = self.albedo;
 
<span class="boring">-        Some((scattered, attenuation))
</span>+        (dot(scattered.direction(), rec.normal) &gt; 0.0).then(|| (scattered, attenuation))
     }
 }</code></pre>
<p><strong>Listing 69:</strong> [<a href="https://github.com/goldnor/code/blob/1546be13df8bf1a655398e2b6b27045d63281290/src/material.rs">material.rs</a>] <em>Metal material fuzziness</em></p>
<br>
<p>We can try that out by adding fuzziness 0.3 and 1.0 to the metals:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 4f0fceb..a705a06 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,46 +1,46 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">     material::{Lambertian, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span> fn main() -&gt; std::io::Result&lt;()&gt; {
<span class="boring">     let mut world = HittableList::new();
</span> 
     let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
     let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
<span class="boring">-    let material_left = Rc::new(Metal::new(Color::new(0.8, 0.8, 0.8)));
</span><span class="boring">-    let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2)));
</span>+    let material_left = Rc::new(Metal::new(Color::new(0.8, 0.8, 0.8), 0.3));
+    let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
 
<span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, -100.5, -1.0),
</span><span class="boring">         100.0,
</span><span class="boring">         material_ground,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, 0.0, -1.2),
</span><span class="boring">         0.5,
</span><span class="boring">         material_center,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_left,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_right,
</span><span class="boring">     )));
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring"> 
</span><span class="boring">     Camera::default()
</span><span class="boring">         .with_aspect_ratio(16.0 / 9.0)
</span><span class="boring">         .with_image_width(400)
</span><span class="boring">         .with_samples_per_pixel(100)
</span><span class="boring">         .with_max_depth(50)
</span><span class="boring">         .render(&amp;world)
</span> }</code></pre>
<p><strong>Listing 70:</strong> [<a href="https://github.com/goldnor/code/blob/1546be13df8bf1a655398e2b6b27045d63281290/src/main.rs">main.rs</a>] <em>Metal spheres with fuzziness</em></p>
<br>
<img style="width: 100%; image-rendering: pixelated" src="chapters/metal/../../imgs/img-1.14-metal-fuzz.png" alt="Fuzzed metal">
<p><strong>Image 14:</strong> <em>Fuzzed metal</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dielectrics"><a class="header" href="#dielectrics">Dielectrics</a></h1>
<p>Clear materials such as water, glass, and diamond are dielectrics. When a light ray hits them, it splits into a reflected ray and a refracted (transmitted) ray. We’ll handle that by randomly choosing between reflection and refraction, only generating one scattered ray per interaction.</p>
<p>As a quick review of terms, a <em>reflected</em> ray hits a surface and then “bounces” off in a new direction.</p>
<p>A <em>refracted</em> ray bends as it transitions from a material's surroundings into the material itself (as with glass or water). This is why a pencil looks bent when partially inserted in water.</p>
<p>The amount that a refracted ray bends is determined by the material's <em>refractive index</em>. Generally, this is a single value that describes how much light bends when entering a material from a vacuum. Glass has a refractive index of something like 1.5–1.7, diamond is around 2.4, and air has a small refractive index of 1.000293.</p>
<p>When a transparent material is embedded in a different transparent material, you can describe the refraction with a relative refraction index: the refractive index of the object's material divided by the refractive index of the surrounding material. For example, if you want to render a glass ball under water, then the glass ball would have an effective refractive index of 1.125. This is given by the refractive index of glass (1.5) divided by the refractive index of water (1.333).</p>
<p>You can find the refractive index of most common materials with a quick internet search.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refraction"><a class="header" href="#refraction">Refraction</a></h2>
<p>The hardest part to debug is the refracted ray. I usually first just have all the light refract if there is a refraction ray at all. For this project, I tried to put two glass balls in our scene, and I got this (I have not told you how to do this right or wrong yet, but soon!):</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/dielectrics/../../imgs/img-1.15-glass-first.png" alt="Glass first">
<p><strong>Image 15:</strong> <em>Glass first</em></p>
<br>
<p>Is that right? Glass balls look odd in real life. But no, it isn’t right. The world should be flipped upside down and no weird black stuff. I just printed out the ray straight through the middle of the image and it was clearly wrong. That often does the job.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="snells-law"><a class="header" href="#snells-law">Snell's Law</a></h2>
<p>The refraction is described by Snell’s law:</p>
<p>\[ \eta \cdot \sin \theta = \eta' \cdot \sin \theta'  \]</p>
<p>Where \( \theta \) and \( \theta' \) are the angles from the normal, and \( \eta \) and \( \eta' \) (pronounced “eta” and “eta prime”) are the refractive indices. The geometry is:</p>
<p><img src="chapters/dielectrics/../../imgs/fig-1.17-refraction.jpg" alt="Ray refraction" /></p>
<p><strong>Figure 17:</strong> <em>Ray refraction</em></p>
<br>
<p>In order to determine the direction of the refracted ray, we have to solve for \( \sin \theta' \):</p>
<p>\[ \sin \theta' = \frac{\eta}{\eta'} \cdot \sin \theta \]</p>
<p>On the refracted side of the surface there is a refracted ray \( \mathbf{R}' \) and a normal \( \mathbf{n}' \), and there exists an angle, \( \theta' \), between them. We can split \( \mathbf{R}' \) into the parts of the ray that are perpendicular to \( \mathbf{n}' \) and parallel to \( \mathbf{n}' \):</p>
<p>\[ \mathbf{R}' = \mathbf{R}' _ {\bot}  + \mathbf{R}'_{\|} \]</p>
<p>If we solve for \( \mathbf{R}' _ {\bot} \)  and \( \mathbf{R}'_{\|} \) we get:</p>
<p>\[ \mathbf{R}' _ {\bot} = \frac{\eta}{\eta'} (\mathbf{R} + |\mathbf{R}| \cos( \theta ) \mathbf{n} )  \]</p>
<p>\[ \mathbf{R}'_{\|} = - \sqrt{1 - |\mathbf{R}' _ {\bot}|^2 } \mathbf{n} \]</p>
<p>You can go ahead and prove this for yourself if you want, but we will treat it as fact and move on. The rest of the book will not require you to understand the proof.</p>
<p>We know the value of every term on the right-hand side except for \( \cos \theta \). It is well known that the dot product of two vectors can be explained in terms of the cosine of the angle between them:</p>
<p>\[ \mathbf{𝐚} \cdot \mathbf{b} = |\mathbf{a}| |\mathbf{b}| \cos \theta \]</p>
<p>If we restrict \( \mathbf{a} \) and \( \mathbf{b} \) to be unit vectors:</p>
<p>\[ \mathbf{𝐚} \cdot \mathbf{b} = \cos \theta \]</p>
<p>We can now rewrite \( \mathbf{R}' _ {\bot} \) in terms of known quantities:</p>
<p>\[ \mathbf{R}' _ {\bot} = \frac{\eta}{\eta'} (\mathbf{R} + (- \mathbf{R} \cdot \mathbf{n} ) \mathbf{n} )  \]</p>
<p>When we combine them back together, we can write a function to calculate \( \mathbf{R}' \):</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index 4cb0b6f..62afd80 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,234 +1,243 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span><span class="boring"> impl Vec3 {
</span><span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length_squared(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn near_zero(&amp;self) -&gt; bool {
</span><span class="boring">         // Return true if the vector is close to zero in all dimensions.
</span><span class="boring">         const S: f64 = 1e-8;
</span><span class="boring">         self.e[0].abs() &lt; S &amp;&amp; self.e[1].abs() &lt; S &amp;&amp; self.e[2].abs() &lt; S
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random() -&gt; Self {
</span><span class="boring">         Vec3 { e: rand::random() }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random_range(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn unit_vector(v: Vec3) -&gt; Vec3 {
</span><span class="boring">     v / v.length()
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_unit_vector() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::random_range(-1.0, 1.0);
</span><span class="boring">         let lensq = p.length_squared();
</span><span class="boring">         if 1e-160 &lt; lensq &amp;&amp; lensq &lt;= 1.0 {
</span><span class="boring">             return p / f64::sqrt(lensq);
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_on_hemisphere(normal: Vec3) -&gt; Vec3 {
</span><span class="boring">     let on_unit_sphere = random_unit_vector();
</span><span class="boring">     if dot(on_unit_sphere, normal) &gt; 0.0 {
</span><span class="boring">         on_unit_sphere
</span><span class="boring">     } else {
</span><span class="boring">         -on_unit_sphere
</span><span class="boring">     }
</span><span class="boring"> }
</span> 
 #[inline]
 pub fn reflect(v: Vec3, n: Vec3) -&gt; Vec3 {
     v - 2.0 * dot(v, n) * n
 }
 
 #[inline]
+pub fn refract(uv: Vec3, n: Vec3, etai_over_etat: f64) -&gt; Vec3 {
+    let cos_theta = f64::min(dot(-uv, n), 1.0);
+    let r_out_perp = etai_over_etat * (uv + cos_theta * n);
+    let r_out_parallel = -f64::sqrt(f64::abs(1.0 - r_out_perp.length_squared())) * n;
+
+    r_out_perp + r_out_parallel
+}
<span class="boring">+
</span><span class="boring">+#[inline]
</span><span class="boring"> pub fn random_in_unit_disk() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::new(
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             0.0,
</span><span class="boring">         );
</span><span class="boring">         if p.length_squared() &lt; 1.0 {
</span><span class="boring">             return p;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 71:</strong> [<a href="https://github.com/goldnor/code/blob/e8bbb4e688c7e3a8b3fc4f20c650cf43c5b9f71c/src/vec3.rs">vec3.rs</a>] <em>Refraction function</em></p>
<br>
<p>And the dielectric material that always refracts is:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/material.rs b/src/material.rs
</span><span class="boring">index e52f6f3..090a4f6 100644
</span><span class="boring">--- a/src/material.rs
</span><span class="boring">+++ b/src/material.rs
</span><span class="boring">@@ -1,58 +1,89 @@
</span><span class="boring"> use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub trait Material {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         None
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Lambertian {
</span><span class="boring">     albedo: Color,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Lambertian {
</span><span class="boring">     pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">         Self { albedo }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Material for Lambertian {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut scatter_direction = rec.normal + random_unit_vector();
</span><span class="boring"> 
</span><span class="boring">         // Catch degenerate scatter direction
</span><span class="boring">         if scatter_direction.near_zero() {
</span><span class="boring">             scatter_direction = rec.normal;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let scattered = Ray::new(rec.p, scatter_direction);
</span><span class="boring">         let attenuation = self.albedo;
</span><span class="boring"> 
</span><span class="boring">         Some((scattered, attenuation))
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Metal {
</span><span class="boring">     albedo: Color,
</span><span class="boring">     fuzz: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Metal {
</span><span class="boring">     pub fn new(albedo: Color, fuzz: f64) -&gt; Self {
</span><span class="boring">         let fuzz = if fuzz &lt; 1.0 { fuzz } else { 1.0 };
</span><span class="boring">         Self { albedo, fuzz }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Material for Metal {
<span class="boring">     fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut reflected = reflect(r_in.direction(), rec.normal);
</span><span class="boring">         reflected = unit_vector(reflected) + (self.fuzz * random_unit_vector());
</span><span class="boring">         let scattered = Ray::new(rec.p, reflected);
</span><span class="boring">         let attenuation = self.albedo;
</span> 
<span class="boring">         (dot(scattered.direction(), rec.normal) &gt; 0.0).then(|| (scattered, attenuation))
</span><span class="boring">     }
</span> }
+
+#[derive(Debug, Default, Clone, Copy)]
+pub struct Dielectric {
+    /// Refractive index in vacuum or air, or the ratio of the material's refractive index over
+    /// the refractive index of the enclosing media
+    refraction_index: f64,
+}
+
+impl Dielectric {
+    pub fn new(refraction_index: f64) -&gt; Self {
+        Self { refraction_index }
+    }
+}
+
+impl Material for Dielectric {
+    fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
+        let attenuation = Color::new(1.0, 1.0, 1.0);
+        let ri = if rec.front_face {
+            1.0 / self.refraction_index
+        } else {
+            self.refraction_index
+        };
+
+        let unit_direction = unit_vector(r_in.direction());
+        let refracted = refract(unit_direction, rec.normal, ri);
+
+        let scattered = Ray::new(rec.p, refracted);
+
+        Some((scattered, attenuation))
+    }
+}</code></pre>
<p><strong>Listing 72:</strong> [<a href="https://github.com/goldnor/code/blob/90798de9cb5e9f59ce5222972c0cb5b2390ce1f4/src/material.rs">material.rs</a>] <em>Dielectric material class that always refracts</em></p>
<br>
<p>Now we'll update the scene to illustrate refraction by changing the left sphere to glass, which has an index of refraction of approximately 1.5.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index a705a06..3894014 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,46 +1,46 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">-    material::{Lambertian, Metal},
</span><span class="boring">+    material::{Dielectric, Lambertian, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> fn main() -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span>     let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
     let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
<span class="boring">-    let material_left = Rc::new(Metal::new(Color::new(0.8, 0.8, 0.8), 0.3));
</span>+    let material_left = Rc::new(Dielectric::new(1.5));
     let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
<span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, -100.5, -1.0),
</span><span class="boring">         100.0,
</span><span class="boring">         material_ground,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, 0.0, -1.2),
</span><span class="boring">         0.5,
</span><span class="boring">         material_center,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_left,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_right,
</span><span class="boring">     )));
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring"> 
</span><span class="boring">     Camera::default()
</span><span class="boring">         .with_aspect_ratio(16.0 / 9.0)
</span><span class="boring">         .with_image_width(400)
</span><span class="boring">         .with_samples_per_pixel(100)
</span><span class="boring">         .with_max_depth(50)
</span><span class="boring">         .render(&amp;world)
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 73:</strong> [<a href="https://github.com/goldnor/code/blob/e7d30179cee4fc7242cc3a887dc6d7a7eb6b86f0&amp;src/main.rs">main.rs</a>] <em>Changing the left sphere to glass</em></p>
<br>
<p>This gives us the following result:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/dielectrics/../../imgs/img-1.16-glass-always-refract.png" alt="Glass sphere that always refracts">
<p><strong>Image 16:</strong> <em>Glass sphere that always refracts</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="total-internal-reflection"><a class="header" href="#total-internal-reflection">Total Internal Reflection</a></h2>
<p>One troublesome practical issue with refraction is that there are ray angles for which no solution is possible using Snell's law. When a ray enters a medium of lower index of refraction at a sufficiently glancing angle, it can refract with an angle greater than 90°. If we refer back to Snell's law and the derivation of \( \sin \theta' \):</p>
<p>\[ \sin \theta' = \frac{\eta}{\eta'} \cdot \sin \theta \]</p>
<p>If the ray is inside glass and outside is air (\( \eta = 1.5 \) and \( \eta' = 1.0 \)):</p>
<p>\[ \sin \theta' = \frac{1.5}{1.0} \cdot \sin \theta \]</p>
<p>The value of \( \sin \theta' \) cannot be greater than 1. So, if,</p>
<p>\[ \frac{1.5}{1.0} \cdot \sin \theta &gt; 1.0 \]</p>
<p>the equality between the two sides of the equation is broken, and a solution cannot exist. If a solution does not exist, the glass cannot refract, and therefore must reflect the ray:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring">
</span><span class="boring">pub trait Material {
</span><span class="boring">    fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct Lambertian {
</span><span class="boring">    albedo: Color,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Lambertian {
</span><span class="boring">    pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">        Self { albedo }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Material for Lambertian {
</span><span class="boring">    fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">        let mut scatter_direction = rec.normal + random_unit_vector();
</span><span class="boring">
</span><span class="boring">        // Catch degenerate scatter direction
</span><span class="boring">        if scatter_direction.near_zero() {
</span><span class="boring">            scatter_direction = rec.normal;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let scattered = Ray::new(rec.p, scatter_direction);
</span><span class="boring">        let attenuation = self.albedo;
</span><span class="boring">
</span><span class="boring">        Some((scattered, attenuation))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct Metal {
</span><span class="boring">    albedo: Color,
</span><span class="boring">    fuzz: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Metal {
</span><span class="boring">    pub fn new(albedo: Color, fuzz: f64) -&gt; Self {
</span><span class="boring">        let fuzz = if fuzz &lt; 1.0 { fuzz } else { 1.0 };
</span><span class="boring">        Self { albedo, fuzz }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Material for Metal {
</span><span class="boring">    fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">        let mut reflected = reflect(r_in.direction(), rec.normal);
</span><span class="boring">        reflected = unit_vector(reflected) + (self.fuzz * random_unit_vector());
</span><span class="boring">        let scattered = Ray::new(rec.p, reflected);
</span><span class="boring">        let attenuation = self.albedo;
</span><span class="boring">
</span><span class="boring">        (dot(scattered.direction(), rec.normal) &gt; 0.0).then(|| (scattered, attenuation))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct Dielectric {
</span><span class="boring">    /// Refractive index in vacuum or air, or the ratio of the material's refractive index over
</span><span class="boring">    /// the refractive index of the enclosing media
</span><span class="boring">    refraction_index: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Dielectric {
</span><span class="boring">    pub fn new(refraction_index: f64) -&gt; Self {
</span><span class="boring">        Self { refraction_index }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Material for Dielectric {
</span><span class="boring">    fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">        let attenuation = Color::new(1.0, 1.0, 1.0);
</span><span class="boring">        let ri = if rec.front_face {
</span><span class="boring">            1.0 / self.refraction_index
</span><span class="boring">        } else {
</span><span class="boring">            self.refraction_index
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let unit_direction = unit_vector(r_in.direction());
</span><span class="boring">        let direction;
</span><span class="boring">
</span><span class="boring">        let cos_theta = f64::min(dot(-unit_direction, rec.normal), 1.0);
</span><span class="boring">        let sin_theta = f64::sqrt(1.0 - cos_theta * cos_theta);
</span><span class="boring">
</span>        if ri * sin_theta &gt; 1.0 {
            // Must Reflect
<span class="boring">            direction = reflect(unit_direction, rec.normal);
</span>        } else {
            // Can Refract
<span class="boring">            direction = refract(unit_direction, rec.normal, ri);
</span>        }
<span class="boring">
</span><span class="boring">        let scattered = Ray::new(rec.p, direction);
</span><span class="boring">
</span><span class="boring">        Some((scattered, attenuation))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 74:</strong> [<a href="https://github.com/goldnor/code/blob/c5841df4f85f94dc87ccaadc6f50eb63ec71d868/src/material.rs">material.rs</a>] <em>Determining if the ray can refract</em></p>
<br>
<p>Here all the light is reflected, and because in practice that is usually inside solid objects, it is called <em>total internal reflection</em>. This is why sometimes the water-to-air boundary acts as a perfect mirror when you are submerged — if you're under water looking up, you can see things above the water, but when you are close to the surface and looking sideways, the water surface looks like a mirror.</p>
<p>We can solve for <code>sin_theta</code> using the trigonometric identities:</p>
<p>\[ \sin \theta = \sqrt{ 1 - \cos^2 \theta } \]</p>
<p>and</p>
<p>\[ \cos \theta = \mathbf{R} \cdot \mathbf{n} \]</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring">
</span><span class="boring">pub trait Material {
</span><span class="boring">    fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct Lambertian {
</span><span class="boring">    albedo: Color,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Lambertian {
</span><span class="boring">    pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">        Self { albedo }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Material for Lambertian {
</span><span class="boring">    fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">        let mut scatter_direction = rec.normal + random_unit_vector();
</span><span class="boring">
</span><span class="boring">        // Catch degenerate scatter direction
</span><span class="boring">        if scatter_direction.near_zero() {
</span><span class="boring">            scatter_direction = rec.normal;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let scattered = Ray::new(rec.p, scatter_direction);
</span><span class="boring">        let attenuation = self.albedo;
</span><span class="boring">
</span><span class="boring">        Some((scattered, attenuation))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct Metal {
</span><span class="boring">    albedo: Color,
</span><span class="boring">    fuzz: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Metal {
</span><span class="boring">    pub fn new(albedo: Color, fuzz: f64) -&gt; Self {
</span><span class="boring">        let fuzz = if fuzz &lt; 1.0 { fuzz } else { 1.0 };
</span><span class="boring">        Self { albedo, fuzz }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Material for Metal {
</span><span class="boring">    fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">        let mut reflected = reflect(r_in.direction(), rec.normal);
</span><span class="boring">        reflected = unit_vector(reflected) + (self.fuzz * random_unit_vector());
</span><span class="boring">        let scattered = Ray::new(rec.p, reflected);
</span><span class="boring">        let attenuation = self.albedo;
</span><span class="boring">
</span><span class="boring">        (dot(scattered.direction(), rec.normal) &gt; 0.0).then(|| (scattered, attenuation))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct Dielectric {
</span><span class="boring">    /// Refractive index in vacuum or air, or the ratio of the material's refractive index over
</span><span class="boring">    /// the refractive index of the enclosing media
</span><span class="boring">    refraction_index: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Dielectric {
</span><span class="boring">    pub fn new(refraction_index: f64) -&gt; Self {
</span><span class="boring">        Self { refraction_index }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Material for Dielectric {
</span><span class="boring">    fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">        let attenuation = Color::new(1.0, 1.0, 1.0);
</span><span class="boring">        let ri = if rec.front_face {
</span><span class="boring">            1.0 / self.refraction_index
</span><span class="boring">        } else {
</span><span class="boring">            self.refraction_index
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let unit_direction = unit_vector(r_in.direction());
</span><span class="boring">        let direction;
</span><span class="boring">
</span>        let cos_theta = f64::min(dot(-unit_direction, rec.normal), 1.0);
        let sin_theta = f64::sqrt(1.0 - cos_theta * cos_theta);

        if ri * sin_theta &gt; 1.0 {
            // Must Reflect
<span class="boring">            direction = reflect(unit_direction, rec.normal);
</span>        } else {
            // Can Refract
<span class="boring">            direction = refract(unit_direction, rec.normal, ri);
</span>        }
<span class="boring">
</span><span class="boring">        let scattered = Ray::new(rec.p, direction);
</span><span class="boring">
</span><span class="boring">        Some((scattered, attenuation))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 75:</strong> [<a href="https://github.com/goldnor/code/blob/c5841df4f85f94dc87ccaadc6f50eb63ec71d868/src/material.rs">material.rs</a>] <em>Determining if the ray can refract</em></p>
<br>
<p>And the dielectric material that always refracts (when possible) is:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/material.rs b/src/material.rs
</span><span class="boring">index 090a4f6..951f550 100644
</span><span class="boring">--- a/src/material.rs
</span><span class="boring">+++ b/src/material.rs
</span><span class="boring">@@ -1,89 +1,97 @@
</span><span class="boring"> use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub trait Material {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         None
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Lambertian {
</span><span class="boring">     albedo: Color,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Lambertian {
</span><span class="boring">     pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">         Self { albedo }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Material for Lambertian {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut scatter_direction = rec.normal + random_unit_vector();
</span><span class="boring"> 
</span><span class="boring">         // Catch degenerate scatter direction
</span><span class="boring">         if scatter_direction.near_zero() {
</span><span class="boring">             scatter_direction = rec.normal;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let scattered = Ray::new(rec.p, scatter_direction);
</span><span class="boring">         let attenuation = self.albedo;
</span><span class="boring"> 
</span><span class="boring">         Some((scattered, attenuation))
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Metal {
</span><span class="boring">     albedo: Color,
</span><span class="boring">     fuzz: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Metal {
</span><span class="boring">     pub fn new(albedo: Color, fuzz: f64) -&gt; Self {
</span><span class="boring">         let fuzz = if fuzz &lt; 1.0 { fuzz } else { 1.0 };
</span><span class="boring">         Self { albedo, fuzz }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Material for Metal {
</span><span class="boring">     fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut reflected = reflect(r_in.direction(), rec.normal);
</span><span class="boring">         reflected = unit_vector(reflected) + (self.fuzz * random_unit_vector());
</span><span class="boring">         let scattered = Ray::new(rec.p, reflected);
</span><span class="boring">         let attenuation = self.albedo;
</span><span class="boring"> 
</span><span class="boring">         (dot(scattered.direction(), rec.normal) &gt; 0.0).then(|| (scattered, attenuation))
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Dielectric {
</span><span class="boring">     /// Refractive index in vacuum or air, or the ratio of the material's refractive index over
</span><span class="boring">     /// the refractive index of the enclosing media
</span><span class="boring">     refraction_index: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Dielectric {
</span><span class="boring">     pub fn new(refraction_index: f64) -&gt; Self {
</span><span class="boring">         Self { refraction_index }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Material for Dielectric {
     fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
         let attenuation = Color::new(1.0, 1.0, 1.0);
         let ri = if rec.front_face {
             1.0 / self.refraction_index
         } else {
             self.refraction_index
         };
 
         let unit_direction = unit_vector(r_in.direction());
<span class="boring">-        let refracted = refract(unit_direction, rec.normal, ri);
</span>+        let cos_theta = f64::min(dot(-unit_direction, rec.normal), 1.0);
+        let sin_theta = f64::sqrt(1.0 - cos_theta * cos_theta);
 
<span class="boring">-        let scattered = Ray::new(rec.p, refracted);
</span>+        let cannot_refract = ri * sin_theta &gt; 1.0;
+        let direction = if cannot_refract {
+            reflect(unit_direction, rec.normal)
+        } else {
+            refract(unit_direction, rec.normal, ri)
+        };
+
+        let scattered = Ray::new(rec.p, direction);
 
         Some((scattered, attenuation))
     }
 }</code></pre>
<p><strong>Listing 76:</strong> [<a href="https://github.com/goldnor/code/blob/2a5e5e9ad9a9e5481fbc28a40c14c707af2cea51/src/material.rs">material.rs</a>] <em>Dielectric material class with reflection</em></p>
<br>
<p>Attenuation is always 1 — the glass surface absorbs nothing.</p>
<p>If we render the prior scene with the new <code>dielectric::scatter()</code> function, we see … no change. Huh?</p>
<p>Well, it turns out that given a sphere of material with an index of refraction greater than air, there's no incident angle that will yield total internal reflection — neither at the ray-sphere entrance point nor at the ray exit. This is due to the geometry of spheres, as a grazing incoming ray will always be bent to a smaller angle, and then bent back to the original angle on exit.</p>
<p>So how can we illustrate total internal reflection? Well, if the sphere has an index of refraction less than the medium it's in, then we can hit it with shallow grazing angles, getting total external reflection. That should be good enough to observe the effect.</p>
<p>We'll model a world filled with water (index of refraction approximately 1.33), and change the sphere material to air (index of refraction 1.00) — an air bubble! To do this, change the left sphere material's index of refraction to</p>
<p>\[ \frac{\text{index of refraction of air}}{\text{index of refraction of water}} \]</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 3894014..6e42461 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,46 +1,46 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">     material::{Dielectric, Lambertian, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> fn main() -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span>     let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
     let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
<span class="boring">-    let material_left = Rc::new(Dielectric::new(1.5));
</span>+    let material_left = Rc::new(Dielectric::new(1.0 / 1.33));
     let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
<span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, -100.5, -1.0),
</span><span class="boring">         100.0,
</span><span class="boring">         material_ground,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, 0.0, -1.2),
</span><span class="boring">         0.5,
</span><span class="boring">         material_center,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_left,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_right,
</span><span class="boring">     )));
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring"> 
</span><span class="boring">     Camera::default()
</span><span class="boring">         .with_aspect_ratio(16.0 / 9.0)
</span><span class="boring">         .with_image_width(400)
</span><span class="boring">         .with_samples_per_pixel(100)
</span><span class="boring">         .with_max_depth(50)
</span><span class="boring">         .render(&amp;world)
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 77:</strong> [<a href="https://github.com/goldnor/code/blob/4f80203ca763361671fcf137bb1e996c54954705/src/main.rs">main.rs</a>] <em>Left sphere is an air bubble in water</em></p>
<br>
<p>This change yields the following render:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/dielectrics/../../imgs/img-1.17-air-bubble-total-reflection.png" alt="Air bubble sometimes refracts, sometimes reflects">
<p><strong>Image 17:</strong> <em>Air bubble sometimes refracts, sometimes reflects</em></p>
<br>
<p>Here you can see that more-or-less direct rays refract, while glancing rays reflect.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="schlick-approximation"><a class="header" href="#schlick-approximation">Schlick Approximation</a></h2>
<p>Now real glass has reflectivity that varies with angle — look at a window at a steep angle and it becomes a mirror. There is a big ugly equation for that, but almost everybody uses a cheap and surprisingly accurate polynomial approximation by Christophe Schlick. This yields our full glass material:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/material.rs b/src/material.rs
</span><span class="boring">index 951f550..20477f9 100644
</span><span class="boring">--- a/src/material.rs
</span><span class="boring">+++ b/src/material.rs
</span><span class="boring">@@ -1,97 +1,104 @@
</span><span class="boring"> use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub trait Material {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         None
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Lambertian {
</span><span class="boring">     albedo: Color,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Lambertian {
</span><span class="boring">     pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">         Self { albedo }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Material for Lambertian {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut scatter_direction = rec.normal + random_unit_vector();
</span><span class="boring"> 
</span><span class="boring">         // Catch degenerate scatter direction
</span><span class="boring">         if scatter_direction.near_zero() {
</span><span class="boring">             scatter_direction = rec.normal;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let scattered = Ray::new(rec.p, scatter_direction);
</span><span class="boring">         let attenuation = self.albedo;
</span><span class="boring"> 
</span><span class="boring">         Some((scattered, attenuation))
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Metal {
</span><span class="boring">     albedo: Color,
</span><span class="boring">     fuzz: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Metal {
</span><span class="boring">     pub fn new(albedo: Color, fuzz: f64) -&gt; Self {
</span><span class="boring">         let fuzz = if fuzz &lt; 1.0 { fuzz } else { 1.0 };
</span><span class="boring">         Self { albedo, fuzz }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Material for Metal {
</span><span class="boring">     fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut reflected = reflect(r_in.direction(), rec.normal);
</span><span class="boring">         reflected = unit_vector(reflected) + (self.fuzz * random_unit_vector());
</span><span class="boring">         let scattered = Ray::new(rec.p, reflected);
</span><span class="boring">         let attenuation = self.albedo;
</span><span class="boring"> 
</span><span class="boring">         (dot(scattered.direction(), rec.normal) &gt; 0.0).then(|| (scattered, attenuation))
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> #[derive(Debug, Default, Clone, Copy)]
 pub struct Dielectric {
     /// Refractive index in vacuum or air, or the ratio of the material's refractive index over
     /// the refractive index of the enclosing media
     refraction_index: f64,
 }
 
 impl Dielectric {
     pub fn new(refraction_index: f64) -&gt; Self {
         Self { refraction_index }
     }
+
+    fn reflectance(cosine: f64, refraction_index: f64) -&gt; f64 {
+        let r0 = (1.0 - refraction_index) / (1.0 + refraction_index);
+        let r0 = r0 * r0;
+        r0 + (1.0 - r0) * f64::powi(1.0 - cosine, 5)
+    }
 }
 
 impl Material for Dielectric {
     fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
         let attenuation = Color::new(1.0, 1.0, 1.0);
         let ri = if rec.front_face {
             1.0 / self.refraction_index
         } else {
             self.refraction_index
         };
 
         let unit_direction = unit_vector(r_in.direction());
         let cos_theta = f64::min(dot(-unit_direction, rec.normal), 1.0);
         let sin_theta = f64::sqrt(1.0 - cos_theta * cos_theta);
 
         let cannot_refract = ri * sin_theta &gt; 1.0;
<span class="boring">-        let direction = if cannot_refract {
</span>+        let direction = if cannot_refract || Dielectric::reflectance(cos_theta, ri) &gt; rand::random()
+        {
             reflect(unit_direction, rec.normal)
         } else {
             refract(unit_direction, rec.normal, ri)
         };
 
         let scattered = Ray::new(rec.p, direction);
 
         Some((scattered, attenuation))
     }
 }</code></pre>
<p><strong>Listing 78:</strong> [<a href="https://github.com/goldnor/code/blob/bdb3324e3e3a832a0aa528a60ecffb1a2b5eb862/src/material.rs">material.rs</a>] <em>Full glass material</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modeling-a-hollow-glass-sphere"><a class="header" href="#modeling-a-hollow-glass-sphere">Modeling a Hollow Glass Sphere</a></h2>
<p>Let's model a hollow glass sphere. This is a sphere of some thickness with another sphere of air inside it. If you think about the path of a ray going through such an object, it will hit the outer sphere, refract, hit the inner sphere (assuming we do hit it), refract a second time, and travel through the air inside. Then it will continue on, hit the inside surface of the inner sphere, refract back, then hit the inside surface of the outer sphere, and finally refract and exit back into the scene atmosphere.</p>
<p>The outer sphere is just modeled with a standard glass sphere, with a refractive index of around 1.50 (modeling a refraction from the outside air into glass). The inner sphere is a bit different because <em>its</em> refractive index should be relative to the material of the surrounding outer sphere, thus modeling a transition from glass into the inner air.</p>
<p>This is actually simple to specify, as the <code>refraction_index</code> parameter to the dielectric material can be interpreted as the <em>ratio</em> of the refractive index of the object divided by the refractive index of the enclosing medium. In this case, the inner sphere would have an refractive index of air (the inner sphere material) over the index of refraction of glass (the enclosing medium), or \( 1.00/1.50=0.67 \).</p>
<p>Here's the code:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 6e42461..c0d6703 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,46 +1,52 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">     material::{Dielectric, Lambertian, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> fn main() -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">     let mut world = HittableList::new();
</span> 
     let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
     let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
<span class="boring">-    let material_left = Rc::new(Dielectric::new(1.0 / 1.33));
</span>+    let material_left = Rc::new(Dielectric::new(1.5));
+    let material_bubble = Rc::new(Dielectric::new(1.0 / 1.5));
     let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
 
     world.add(Rc::new(Sphere::new(
         Point3::new(0.0, -100.5, -1.0),
         100.0,
         material_ground,
     )));
     world.add(Rc::new(Sphere::new(
         Point3::new(0.0, 0.0, -1.2),
         0.5,
         material_center,
     )));
     world.add(Rc::new(Sphere::new(
         Point3::new(-1.0, 0.0, -1.0),
         0.5,
         material_left,
     )));
     world.add(Rc::new(Sphere::new(
+        Point3::new(-1.0, 0.0, -1.0),
+        0.4,
+        material_bubble,
+    )));
+    world.add(Rc::new(Sphere::new(
         Point3::new(1.0, 0.0, -1.0),
         0.5,
         material_right,
     )));
 
<span class="boring">     env_logger::init();
</span><span class="boring"> 
</span><span class="boring">     Camera::default()
</span><span class="boring">         .with_aspect_ratio(16.0 / 9.0)
</span><span class="boring">         .with_image_width(400)
</span><span class="boring">         .with_samples_per_pixel(100)
</span><span class="boring">         .with_max_depth(50)
</span><span class="boring">         .render(&amp;world)
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 79:</strong> [<a href="https://github.com/goldnor/code/blob/3d2dfe52b90bf3d6bc1287c0b5bcbbbb998b1d47/src/main.rs">main.rs</a>] <em>Scene with hollow glass sphere</em></p>
<br>
<p>And here's the result:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/dielectrics/../../imgs/img-1.18-glass-hollow.png" alt="A hollow glass sphere">
<p><strong>Image 18:</strong> <em>A hollow glass sphere</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="positionable-camera"><a class="header" href="#positionable-camera">Positionable Camera</a></h1>
<p>Cameras, like dielectrics, are a pain to debug, so I always develop mine incrementally. First, let’s allow for an adjustable field of view (<em>fov</em>). This is the visual angle from edge to edge of the rendered image. Since our image is not square, the fov is different horizontally and vertically. I always use vertical fov. I also usually specify it in degrees and change to radians inside a constructor — a matter of personal taste.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="camera-viewing-geometry"><a class="header" href="#camera-viewing-geometry">Camera Viewing Geometry</a></h2>
<p>First, we'll keep the rays coming from the origin and heading to the \( z = -1\) plane. We could make it the \( z = -2 \) plane, or whatever, as long as we made ℎ a ratio to that distance. Here is our setup:</p>
<p><img src="chapters/positionable_camera/../../imgs/fig-1.18-cam-view-geom.jpg" alt="Camera viewing geometry (from the side)" /></p>
<p><strong>Figure 18:</strong> <em>Camera viewing geometry (from the side)</em></p>
<br>
<p>This implies \( h = \tan (\frac{\theta}{2}) \). Our camera now becomes:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index 1927898..8e256aa 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,168 +1,179 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span> pub struct Camera {
     /// Ratio of image width over height
     pub aspect_ratio: f64,
     /// Rendered image width in pixel count
     pub image_width: i32,
     // Count of random samples for each pixel
     pub samples_per_pixel: i32,
     // Maximum number of ray bounces into scene
     pub max_depth: i32,
+    // Vertical view angle (field of view)
+    pub vfov: f64,
 
     /// Rendered image height
     image_height: i32,
     // Color scale factor for a sum of pixel samples
     pixel_samples_scale: f64,
     /// Camera center
     center: Point3,
     /// Location of pixel 0, 0
     pixel00_loc: Point3,
     /// Offset to pixel to the right
     pixel_delta_u: Vec3,
     /// Offset to pixel below
     pixel_delta_v: Vec3,
 }
 
 impl Default for Camera {
     fn default() -&gt; Self {
         Self {
             aspect_ratio: 1.0,
             image_width: 100,
             samples_per_pixel: 10,
             max_depth: 10,
+            vfov: 90.0,
             image_height: Default::default(),
             pixel_samples_scale: Default::default(),
             center: Default::default(),
             pixel00_loc: Default::default(),
             pixel_delta_u: Default::default(),
             pixel_delta_v: Default::default(),
         }
     }
 }
 
 impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
</span><span class="boring">         self.max_depth = max_depth;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span> 
+    pub fn with_vfov(mut self, vfov: f64) -&gt; Self {
+        self.vfov = vfov;
+
+        self
+    }
+
<span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, self.max_depth, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span>     fn initialize(&amp;mut self) {
         self.image_height = {
             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
             if image_height &lt; 1 { 1 } else { image_height }
         };
 
         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
 
         self.center = Point3::new(0.0, 0.0, 0.0);
 
         // Determine viewport dimensions.
         let focal_length = 1.0;
<span class="boring">-        let viewport_height = 2.0;
</span>+        let theta = self.vfov.to_radians();
+        let h = f64::tan(theta / 2.0);
+        let viewport_height = 2.0 * h * focal_length;
         let viewport_width =
             viewport_height * (self.image_width as f64) / (self.image_height as f64);
 
         // Calculate the vectors across the horizontal and down the vertical viewport edges.
         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
 
         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
         self.pixel_delta_u = viewport_u / self.image_width as f64;
         self.pixel_delta_v = viewport_v / self.image_height as f64;
 
         // Calculate the location of the upper left pixel.
         let viewport_upper_left =
             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
     }
 
<span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
</span><span class="boring">         // If we've exceeded the ray bounce limit, no more light is gathered.
</span><span class="boring">         if depth &lt;= 0 {
</span><span class="boring">             return Color::new(0.0, 0.0, 0.0);
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         if let Some(rec) = world.hit(r, Interval::new(0.001, INFINITY)) {
</span><span class="boring">             if let Some((scattered, attenuation)) = rec.mat.scatter(r, rec.clone()) {
</span><span class="boring">                 return attenuation * Self::ray_color(scattered, depth - 1, world);
</span><span class="boring">             }
</span><span class="boring">             return Color::new(0.0, 0.0, 0.0);
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let unit_direction = unit_vector(r.direction());
</span><span class="boring">         let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span><span class="boring">     }
</span> }</code></pre>
<p><strong>Listing 80:</strong> [<a href="https://github.com/goldnor/code/blob/4927dc70bdac3e6a5f2b3ecf174ee2c4b70a2c65/src/camera.rs">camera.rs</a>] <em>Camera with adjustable field-of-view (fov)</em></p>
<br>
<p>We'll test out these changes with a simple scene of two touching spheres, using a 90° field of view.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index c0d6703..e906c8c 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,52 +1,37 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">     material::{Dielectric, Lambertian, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span> fn main() -&gt; std::io::Result&lt;()&gt; {
     let mut world = HittableList::new();
 
<span class="boring">-    let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
</span><span class="boring">-    let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
</span><span class="boring">-    let material_left = Rc::new(Dielectric::new(1.5));
</span><span class="boring">-    let material_bubble = Rc::new(Dielectric::new(1.0 / 1.5));
</span><span class="boring">-    let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
</span>+    let r = f64::cos(PI / 4.0);
+
+    let material_left = Rc::new(Lambertian::new(Color::new(0.0, 0.0, 1.0)));
+    let material_right = Rc::new(Lambertian::new(Color::new(1.0, 0.0, 0.0)));
 
     world.add(Rc::new(Sphere::new(
<span class="boring">-        Point3::new(0.0, -100.5, -1.0),
</span><span class="boring">-        100.0,
</span><span class="boring">-        material_ground,
</span><span class="boring">-    )));
</span><span class="boring">-    world.add(Rc::new(Sphere::new(
</span><span class="boring">-        Point3::new(0.0, 0.0, -1.2),
</span><span class="boring">-        0.5,
</span><span class="boring">-        material_center,
</span><span class="boring">-    )));
</span><span class="boring">-    world.add(Rc::new(Sphere::new(
</span><span class="boring">-        Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">-        0.5,
</span>+        Point3::new(-r, 0.0, -1.0),
+        r,
         material_left,
     )));
     world.add(Rc::new(Sphere::new(
<span class="boring">-        Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">-        0.4,
</span><span class="boring">-        material_bubble,
</span><span class="boring">-    )));
</span><span class="boring">-    world.add(Rc::new(Sphere::new(
</span><span class="boring">-        Point3::new(1.0, 0.0, -1.0),
</span><span class="boring">-        0.5,
</span>+        Point3::new(r, 0.0, -1.0),
+        r,
         material_right,
     )));
 
     env_logger::init();
 
     Camera::default()
         .with_aspect_ratio(16.0 / 9.0)
         .with_image_width(400)
         .with_samples_per_pixel(100)
         .with_max_depth(50)
+        .with_vfov(90.0)
         .render(&amp;world)
 }</code></pre>
<p><strong>Listing 81:</strong> [<a href="https://github.com/goldnor/code/blob/52ee7bbdb1a7614b145e3821c1ab91fd010ed7ce/src/main.rs">main.rs</a>] <em>Scene with wide-angle camera</em></p>
<br>
<p>This gives us the rendering:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/positionable_camera/../../imgs/img-1.19-wide-view.png" alt="A wide-angle view">
<p><strong>Image 19:</strong> <em>A wide-angle view</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="positioning-and-orienting-the-camera"><a class="header" href="#positioning-and-orienting-the-camera">Positioning and Orienting the Camera</a></h2>
<p>To get an arbitrary viewpoint, let’s first name the points we care about. We’ll call the position where we place the camera <em>lookfrom</em>, and the point we look at <em>lookat</em>. (Later, if you want, you could define a direction to look in instead of a point to look at.)</p>
<p>We also need a way to specify the roll, or sideways tilt, of the camera: the rotation around the lookat-lookfrom axis. Another way to think about it is that even if you keep <code>lookfrom</code> and <code>lookat</code> constant, you can still rotate your head around your nose. What we need is a way to specify an “up” vector for the camera.</p>
<p><img src="chapters/positionable_camera/../../imgs/fig-1.19-cam-view-dir.jpg" alt="Camera view direction" /></p>
<p><strong>Figure 19:</strong> <em>Camera view direction</em></p>
<br>
<p>We can specify any up vector we want, as long as it's not parallel to the view direction. Project this up vector onto the plane orthogonal to the view direction to get a camera-relative up vector. I use the common convention of naming this the “view up” (<em>vup</em>) vector. After a few cross products and vector normalizations, we now have a complete orthonormal basis \( (u, v, w) \) to describe our camera’s orientation. \( u \) will be the unit vector pointing to camera right, \( v \) is the unit vector pointing to camera up, \( w \) is the unit vector pointing opposite the view direction (since we use right-hand coordinates), and the camera center is at the origin.</p>
<p><img src="chapters/positionable_camera/../../imgs/fig-1.20-cam-view-up.jpg" alt="Camera view up direction" /></p>
<p><strong>Figure 20:</strong> <em>Camera view up direction</em></p>
<br>
<p>Like before, when our fixed camera faced \( -Z \), our arbitrary view camera faces \( -w \). Keep in mind that we can — but we don’t have to — use world up \( (0, 1, 0) \) to specify vup. This is convenient and will naturally keep your camera horizontally level until you decide to experiment with crazy camera angles.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index 8e256aa..44da965 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,179 +1,220 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span> pub struct Camera {
     /// Ratio of image width over height
     pub aspect_ratio: f64,
     /// Rendered image width in pixel count
     pub image_width: i32,
     // Count of random samples for each pixel
     pub samples_per_pixel: i32,
     // Maximum number of ray bounces into scene
     pub max_depth: i32,
     // Vertical view angle (field of view)
     pub vfov: f64,
+    /// Point camera is looking from
+    pub lookfrom: Point3,
+    /// Point camera is looking at
+    pub lookat: Point3,
+    /// Camera-relative "up" direction
+    pub vup: Vec3,
 
     /// Rendered image height
     image_height: i32,
     // Color scale factor for a sum of pixel samples
     pixel_samples_scale: f64,
     /// Camera center
     center: Point3,
     /// Location of pixel 0, 0
     pixel00_loc: Point3,
     /// Offset to pixel to the right
     pixel_delta_u: Vec3,
     /// Offset to pixel below
     pixel_delta_v: Vec3,
+    /// Camera frame basis vector - right
+    u: Vec3,
+    /// Camera frame basis vector - up
+    v: Vec3,
+    /// Camera frame basis vector - opposite view direction
+    w: Vec3,
 }
 
 impl Default for Camera {
     fn default() -&gt; Self {
         Self {
             aspect_ratio: 1.0,
             image_width: 100,
             samples_per_pixel: 10,
             max_depth: 10,
             vfov: 90.0,
+            lookfrom: Point3::new(0.0, 0.0, 0.0),
+            lookat: Point3::new(0.0, 0.0, -1.0),
+            vup: Point3::new(0.0, 1.0, 0.0),
             image_height: Default::default(),
             pixel_samples_scale: Default::default(),
             center: Default::default(),
             pixel00_loc: Default::default(),
             pixel_delta_u: Default::default(),
             pixel_delta_v: Default::default(),
+            u: Default::default(),
+            v: Default::default(),
+            w: Default::default(),
         }
     }
 }
 
 impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
</span><span class="boring">         self.max_depth = max_depth;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_vfov(mut self, vfov: f64) -&gt; Self {
</span><span class="boring">         self.vfov = vfov;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span> 
+    pub fn with_lookfrom(mut self, lookfrom: Point3) -&gt; Self {
+        self.lookfrom = lookfrom;
+
+        self
+    }
+
+    pub fn with_lookat(mut self, lookat: Point3) -&gt; Self {
+        self.lookat = lookat;
+
+        self
+    }
+
+    pub fn with_vup(mut self, vup: Vec3) -&gt; Self {
+        self.vup = vup;
+
+        self
+    }
+
<span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, self.max_depth, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span>     fn initialize(&amp;mut self) {
         self.image_height = {
             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
             if image_height &lt; 1 { 1 } else { image_height }
         };
 
         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
 
<span class="boring">-        self.center = Point3::new(0.0, 0.0, 0.0);
</span>+        self.center = self.lookfrom;
 
         // Determine viewport dimensions.
<span class="boring">-        let focal_length = 1.0;
</span>+        let focal_length = (self.lookfrom - self.lookat).length();
         let theta = self.vfov.to_radians();
         let h = f64::tan(theta / 2.0);
         let viewport_height = 2.0 * h * focal_length;
         let viewport_width =
             viewport_height * (self.image_width as f64) / (self.image_height as f64);
 
+        // Calculate the u,v,w unit basis vectors for the camera coordinate frame.
+        self.w = unit_vector(self.lookfrom - self.lookat);
+        self.u = unit_vector(cross(self.vup, self.w));
+        self.v = cross(self.w, self.u);
+
         // Calculate the vectors across the horizontal and down the vertical viewport edges.
<span class="boring">-        let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">-        let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span>+        let viewport_u = viewport_width * self.u; // Vector across viewport horizontal edge
+        let viewport_v = viewport_height * -self.v; // Vector down viewport vertical edge
 
         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
         self.pixel_delta_u = viewport_u / self.image_width as f64;
         self.pixel_delta_v = viewport_v / self.image_height as f64;
 
         // Calculate the location of the upper left pixel.
         let viewport_upper_left =
<span class="boring">-            self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span>+            self.center - (focal_length * self.w) - viewport_u / 2.0 - viewport_v / 2.0;
         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
     }
 
<span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
</span><span class="boring">         // If we've exceeded the ray bounce limit, no more light is gathered.
</span><span class="boring">         if depth &lt;= 0 {
</span><span class="boring">             return Color::new(0.0, 0.0, 0.0);
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         if let Some(rec) = world.hit(r, Interval::new(0.001, INFINITY)) {
</span><span class="boring">             if let Some((scattered, attenuation)) = rec.mat.scatter(r, rec.clone()) {
</span><span class="boring">                 return attenuation * Self::ray_color(scattered, depth - 1, world);
</span><span class="boring">             }
</span><span class="boring">             return Color::new(0.0, 0.0, 0.0);
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let unit_direction = unit_vector(r.direction());
</span><span class="boring">         let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span><span class="boring">     }
</span> }</code></pre>
<p><strong>Listing 82:</strong> [<a href="https://github.com/goldnor/code/blob/c331ea145b761c687d5ce9fc257aefdbbcf7de51/src/camera.rs">camera.rs</a>] <em>Positionable and orientable camera</em></p>
<br>
<p>We'll change back to the prior scene, and use the new viewpoint:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index e906c8c..2e30baf 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,37 +1,56 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">     material::{Dielectric, Lambertian, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span> fn main() -&gt; std::io::Result&lt;()&gt; {
     let mut world = HittableList::new();
 
<span class="boring">-    let r = f64::cos(PI / 4.0);
</span><span class="boring">-
</span><span class="boring">-    let material_left = Rc::new(Lambertian::new(Color::new(0.0, 0.0, 1.0)));
</span><span class="boring">-    let material_right = Rc::new(Lambertian::new(Color::new(1.0, 0.0, 0.0)));
</span>+    let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
+    let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
+    let material_left = Rc::new(Dielectric::new(1.5));
+    let material_bubble = Rc::new(Dielectric::new(1.0 / 1.5));
+    let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
 
     world.add(Rc::new(Sphere::new(
<span class="boring">-        Point3::new(-r, 0.0, -1.0),
</span><span class="boring">-        r,
</span>+        Point3::new(0.0, -100.5, -1.0),
+        100.0,
+        material_ground,
+    )));
+    world.add(Rc::new(Sphere::new(
+        Point3::new(0.0, 0.0, -1.2),
+        0.5,
+        material_center,
+    )));
+    world.add(Rc::new(Sphere::new(
+        Point3::new(-1.0, 0.0, -1.0),
+        0.5,
         material_left,
     )));
     world.add(Rc::new(Sphere::new(
<span class="boring">-        Point3::new(r, 0.0, -1.0),
</span><span class="boring">-        r,
</span>+        Point3::new(-1.0, 0.0, -1.0),
+        0.4,
+        material_bubble,
+    )));
+    world.add(Rc::new(Sphere::new(
+        Point3::new(1.0, 0.0, -1.0),
+        0.5,
         material_right,
     )));
 
     env_logger::init();
 
     Camera::default()
         .with_aspect_ratio(16.0 / 9.0)
         .with_image_width(400)
         .with_samples_per_pixel(100)
         .with_max_depth(50)
         .with_vfov(90.0)
+        .with_lookfrom(Point3::new(-2.0, 2.0, 1.0))
+        .with_lookat(Point3::new(0.0, 0.0, -1.0))
+        .with_vup(Point3::new(0.0, 1.0, 0.0))
         .render(&amp;world)
 }</code></pre>
<p><strong>Listing 83:</strong> [<a href="https://github.com/goldnor/code/blob/c702619b19462b2bff877076a01333fd974613fe/src/main.rs">main.rs</a>] <em>Scene with alternate viewpoint</em></p>
<br>
<p>to get:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/positionable_camera/../../imgs/img-1.20-view-distant.png" alt="A distant view">
<p><strong>Image 20:</strong> <em>A distant view</em></p>
<br>
<p>And we can change field of view:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 2e30baf..f7deb5e 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,56 +1,56 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">     material::{Dielectric, Lambertian, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> fn main() -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span><span class="boring">     let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
</span><span class="boring">     let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
</span><span class="boring">     let material_left = Rc::new(Dielectric::new(1.5));
</span><span class="boring">     let material_bubble = Rc::new(Dielectric::new(1.0 / 1.5));
</span><span class="boring">     let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
</span><span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, -100.5, -1.0),
</span><span class="boring">         100.0,
</span><span class="boring">         material_ground,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, 0.0, -1.2),
</span><span class="boring">         0.5,
</span><span class="boring">         material_center,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_left,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">         0.4,
</span><span class="boring">         material_bubble,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_right,
</span><span class="boring">     )));
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring"> 
</span><span class="boring">     Camera::default()
</span><span class="boring">         .with_aspect_ratio(16.0 / 9.0)
</span><span class="boring">         .with_image_width(400)
</span><span class="boring">         .with_samples_per_pixel(100)
</span><span class="boring">         .with_max_depth(50)
</span><span class="boring">-        .with_vfov(90.0)
</span>+        .with_vfov(20.0)
<span class="boring">         .with_lookfrom(Point3::new(-2.0, 2.0, 1.0))
</span><span class="boring">         .with_lookat(Point3::new(0.0, 0.0, -1.0))
</span><span class="boring">         .with_vup(Point3::new(0.0, 1.0, 0.0))
</span><span class="boring">         .render(&amp;world)
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 84:</strong> [<a href="https://github.com/goldnor/code/blob/409a0091e1b14c4a64af91b19dc405ab78f32862/src/main.rs">main.rs</a>] <em>Change field of view</em></p>
<br>
<p>to get:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/positionable_camera/../../imgs/img-1.21-view-zoom.png" alt="Zooming in">
<p><strong>Image 21:</strong> <em>Zooming in</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defocus-blur"><a class="header" href="#defocus-blur">Defocus Blur</a></h1>
<p>Now our final feature: <em>defocus blur</em>. Note, photographers call this <em>depth of field</em>, so be sure to only use the term <em>defocus blur</em> among your raytracing friends.</p>
<p>The reason we have defocus blur in real cameras is because they need a big hole (rather than just a pinhole) through which to gather light. A large hole would defocus everything, but if we stick a lens in front of the film/sensor, there will be a certain distance at which everything is in focus. Objects placed at that distance will appear in focus and will linearly appear blurrier the further they are from that distance. You can think of a lens this way: all light rays coming <em>from</em> a specific point at the focus distance — and that hit the lens — will be bent back <em>to</em> a single point on the image sensor.</p>
<p>We call the distance between the camera center and the plane where everything is in perfect focus the <em>focus distance</em>. Be aware that the focus distance is not usually the same as the focal length — the <em>focal length</em> is the distance between the camera center and the image plane. For our model, however, these two will have the same value, as we will put our pixel grid right on the focus plane, which is <em>focus distance</em> away from the camera center.</p>
<p>In a physical camera, the focus distance is controlled by the distance between the lens and the film/sensor. That is why you see the lens move relative to the camera when you change what is in focus (that may happen in your phone camera too, but the sensor moves). The “aperture” is a hole to control how big the lens is effectively. For a real camera, if you need more light you make the aperture bigger, and will get more blur for objects away from the focus distance. For our virtual camera, we can have a perfect sensor and never need more light, so we only use an aperture when we want defocus blur.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-thin-lens-approximation"><a class="header" href="#a-thin-lens-approximation">A Thin Lens Approximation</a></h2>
<p>A real camera has a complicated compound lens. For our code, we could simulate the order: sensor, then lens, then aperture. Then we could figure out where to send the rays, and flip the image after it's computed (the image is projected upside down on the film). Graphics people, however, usually use a thin lens approximation:</p>
<p><img src="chapters/defocus_blur/../../imgs/fig-1.21-cam-lens.jpg" alt="Camera lens model" /></p>
<p><strong>Figure 21:</strong> <em>Camera lens model</em></p>
<br>
<p>We don’t need to simulate any of the inside of the camera — for the purposes of rendering an image outside the camera, that would be unnecessary complexity. Instead, I usually start rays from an infinitely thin circular “lens”, and send them toward the pixel of interest on the focus plane (<code>focal_length</code> away from the lens), where everything on that plane in the 3D world is in perfect focus.</p>
<p>In practice, we accomplish this by placing the viewport in this plane. Putting everything together:</p>
<ol>
<li>The focus plane is orthogonal to the camera view direction.</li>
<li>The focus distance is the distance between the camera center and the focus plane.</li>
<li>The viewport lies on the focus plane, centered on the camera view direction vector.</li>
<li>The grid of pixel locations lies inside the viewport (located in the 3D world).</li>
<li>Random image sample locations are chosen from the region around the current pixel location.</li>
<li>The camera fires rays from random points on the lens through the current image sample location.</li>
</ol>
<p><img src="chapters/defocus_blur/../../imgs/fig-1.22-cam-film-plane.jpg" alt="Camera focus plane" /></p>
<p><strong>Figure 22:</strong> <em>Camera focus plane</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generating-sample-rays"><a class="header" href="#generating-sample-rays">Generating Sample Rays</a></h2>
<p>Without defocus blur, all scene rays originate from the camera center (or <code>lookfrom</code>). In order to accomplish defocus blur, we construct a disk centered at the camera center. The larger the radius, the greater the defocus blur. You can think of our original camera as having a defocus disk of radius zero (no blur at all), so all rays originated at the disk center (<code>lookfrom</code>).</p>
<p>So, how large should the defocus disk be? Since the size of this disk controls how much defocus blur we get, that should be a parameter of the camera class. We could just take the radius of the disk as a camera parameter, but the blur would vary depending on the projection distance. A slightly easier parameter is to specify the angle of the cone with apex at viewport center and base (defocus disk) at the camera center. This should give you more consistent results as you vary the focus distance for a given shot.</p>
<p>Since we'll be choosing random points from the defocus disk, we'll need a function to do that: <code>random_in_unit_disk()</code>. This function works using the same kind of method we use in <code>random_unit_vector()</code>, just for two dimensions.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index df0939e..d4352e1 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,176 +1,190 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span><span class="boring"> impl Vec3 {
</span><span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length_squared(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span> 
 #[inline]
 pub fn unit_vector(v: Vec3) -&gt; Vec3 {
     v / v.length()
 }
+
+#[inline]
+pub fn random_in_unit_disk() -&gt; Vec3 {
+    loop {
+        let p = Vec3::new(
+            rand::random_range(-1.0..1.0),
+            rand::random_range(-1.0..1.0),
+            0.0,
+        );
+        if p.length_squared() &lt; 1.0 {
+            return p;
+        }
+    }
+}</code></pre>
<!-- NOTE: This commit is the latest, however the feature was impelemted earlier which is why we show an older diff  -->
<p><strong>Listing 85:</strong> [<a href="https://github.com/goldnor/code/blob/409a0091e1b14c4a64af91b19dc405ab78f32862/src/vec3.rs">vec3.rs</a>] <em>Generate random point inside unit disk</em></p>
<br>
<p>Now let's update the camera to originate rays from the defocus disk:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index 44da965..6b51a5b 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,220 +1,259 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span> pub struct Camera {
     /// Ratio of image width over height
     pub aspect_ratio: f64,
     /// Rendered image width in pixel count
     pub image_width: i32,
     // Count of random samples for each pixel
     pub samples_per_pixel: i32,
     // Maximum number of ray bounces into scene
     pub max_depth: i32,
     // Vertical view angle (field of view)
     pub vfov: f64,
     /// Point camera is looking from
     pub lookfrom: Point3,
     /// Point camera is looking at
     pub lookat: Point3,
     /// Camera-relative "up" direction
     pub vup: Vec3,
+    /// Variation angle of rays through each pixel
+    pub defocus_angle: f64,
+    /// Distance from camera lookfrom point to plane of perfect focus
+    pub focus_dist: f64,
 
     /// Rendered image height
     image_height: i32,
     // Color scale factor for a sum of pixel samples
     pixel_samples_scale: f64,
     /// Camera center
     center: Point3,
     /// Location of pixel 0, 0
     pixel00_loc: Point3,
     /// Offset to pixel to the right
     pixel_delta_u: Vec3,
     /// Offset to pixel below
     pixel_delta_v: Vec3,
     /// Camera frame basis vector - right
     u: Vec3,
     /// Camera frame basis vector - up
     v: Vec3,
     /// Camera frame basis vector - opposite view direction
     w: Vec3,
+    /// Defocus disk horizontal radius
+    defocus_disk_u: Vec3,
+    /// Defocus disk vertical radius
+    defocus_disk_v: Vec3,
 }
 
 impl Default for Camera {
     fn default() -&gt; Self {
         Self {
             aspect_ratio: 1.0,
             image_width: 100,
             samples_per_pixel: 10,
             max_depth: 10,
             vfov: 90.0,
             lookfrom: Point3::new(0.0, 0.0, 0.0),
             lookat: Point3::new(0.0, 0.0, -1.0),
             vup: Point3::new(0.0, 1.0, 0.0),
+            defocus_angle: 0.0,
+            focus_dist: 10.0,
             image_height: Default::default(),
             pixel_samples_scale: Default::default(),
             center: Default::default(),
             pixel00_loc: Default::default(),
             pixel_delta_u: Default::default(),
             pixel_delta_v: Default::default(),
             u: Default::default(),
             v: Default::default(),
             w: Default::default(),
+            defocus_disk_u: Default::default(),
+            defocus_disk_v: Default::default(),
         }
     }
 }
 
 impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
</span><span class="boring">         self.max_depth = max_depth;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_vfov(mut self, vfov: f64) -&gt; Self {
</span><span class="boring">         self.vfov = vfov;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_lookfrom(mut self, lookfrom: Point3) -&gt; Self {
</span><span class="boring">         self.lookfrom = lookfrom;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_lookat(mut self, lookat: Point3) -&gt; Self {
</span><span class="boring">         self.lookat = lookat;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_vup(mut self, vup: Vec3) -&gt; Self {
</span><span class="boring">         self.vup = vup;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span> 
+    pub fn with_defocus_angle(mut self, defocus_angle: f64) -&gt; Self {
+        self.defocus_angle = defocus_angle;
+
+        self
+    }
+
+    pub fn with_focus_dist(mut self, focus_dist: f64) -&gt; Self {
+        self.focus_dist = focus_dist;
+
+        self
+    }
+
<span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, self.max_depth, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span>     fn initialize(&amp;mut self) {
         self.image_height = {
             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
             if image_height &lt; 1 { 1 } else { image_height }
         };
 
         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
 
         self.center = self.lookfrom;
 
         // Determine viewport dimensions.
-        let focal_length = (self.lookfrom - self.lookat).length();
         let theta = self.vfov.to_radians();
         let h = f64::tan(theta / 2.0);
<span class="boring">-        let viewport_height = 2.0 * h * focal_length;
</span>+        let viewport_height = 2.0 * h * self.focus_dist;
         let viewport_width =
             viewport_height * (self.image_width as f64) / (self.image_height as f64);
 
         // Calculate the u,v,w unit basis vectors for the camera coordinate frame.
         self.w = unit_vector(self.lookfrom - self.lookat);
         self.u = unit_vector(cross(self.vup, self.w));
         self.v = cross(self.w, self.u);
 
         // Calculate the vectors across the horizontal and down the vertical viewport edges.
         let viewport_u = viewport_width * self.u; // Vector across viewport horizontal edge
         let viewport_v = viewport_height * -self.v; // Vector down viewport vertical edge
 
         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
         self.pixel_delta_u = viewport_u / self.image_width as f64;
         self.pixel_delta_v = viewport_v / self.image_height as f64;
 
         // Calculate the location of the upper left pixel.
         let viewport_upper_left =
<span class="boring">-            self.center - (focal_length * self.w) - viewport_u / 2.0 - viewport_v / 2.0;
</span>+            self.center - (self.focus_dist * self.w) - viewport_u / 2.0 - viewport_v / 2.0;
         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
+
+        // Calculate the camera defocus disk basis vectors.
+        let defocus_radius = self.focus_dist * f64::tan((self.defocus_angle / 2.0).to_radians());
+        self.defocus_disk_u = self.u * defocus_radius;
+        self.defocus_disk_v = self.v * defocus_radius;
     }
 
     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
<span class="boring">-        // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">-        // point around the pixel location i, j.
</span>+        // Construct a camera ray originating from the defocus disk and directed at a randomly
+        // sampled point around the pixel location i, j.
 
         let offset = Self::sample_square();
         let pixel_sample = self.pixel00_loc
             + ((i as f64 + offset.x()) * self.pixel_delta_u)
             + ((j as f64 + offset.y()) * self.pixel_delta_v);
 
<span class="boring">-        let ray_origin = self.center;
</span>+        let ray_origin = if self.defocus_angle &lt;= 0.0 {
+            self.center
+        } else {
+            self.defocus_disk_sample()
+        };
         let ray_direction = pixel_sample - ray_origin;
 
         Ray::new(ray_origin, ray_direction)
     }
 
     fn sample_square() -&gt; Vec3 {
<span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span> 
<span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span>     }
 
+    fn defocus_disk_sample(&amp;self) -&gt; Point3 {
+        // Returns a random point in the camera defocus disk.
+        let p = random_in_unit_disk();
+
+        self.center + (p[0] * self.defocus_disk_u) + (p[1] * self.defocus_disk_v)
+    }
+
     fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">         // If we've exceeded the ray bounce limit, no more light is gathered.
</span><span class="boring">         if depth &lt;= 0 {
</span><span class="boring">             return Color::new(0.0, 0.0, 0.0);
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         if let Some(rec) = world.hit(r, Interval::new(0.001, INFINITY)) {
</span><span class="boring">             if let Some((scattered, attenuation)) = rec.mat.scatter(r, rec.clone()) {
</span><span class="boring">                 return attenuation * Self::ray_color(scattered, depth - 1, world);
</span><span class="boring">             }
</span><span class="boring">             return Color::new(0.0, 0.0, 0.0);
</span><span class="boring">         }
</span> 
<span class="boring">         let unit_direction = unit_vector(r.direction());
</span><span class="boring">         let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>     }
 }</code></pre>
<p><strong>Listing 86:</strong> [<a href="https://github.com/goldnor/code/blob/e38cd9da49c32555a48301a9d263c48356ba3baa/src/camera.rs">camera.rs</a>] <em>Camera with adjustable depth-of-field</em></p>
<br>
<p>Using a large aperture:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index f7deb5e..51d420b 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,56 +1,58 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">     material::{Dielectric, Lambertian, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span> fn main() -&gt; std::io::Result&lt;()&gt; {
<span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span><span class="boring">     let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
</span><span class="boring">     let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
</span><span class="boring">     let material_left = Rc::new(Dielectric::new(1.5));
</span><span class="boring">     let material_bubble = Rc::new(Dielectric::new(1.0 / 1.5));
</span><span class="boring">     let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
</span><span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, -100.5, -1.0),
</span><span class="boring">         100.0,
</span><span class="boring">         material_ground,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(0.0, 0.0, -1.2),
</span><span class="boring">         0.5,
</span><span class="boring">         material_center,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_left,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">         0.4,
</span><span class="boring">         material_bubble,
</span><span class="boring">     )));
</span><span class="boring">     world.add(Rc::new(Sphere::new(
</span><span class="boring">         Point3::new(1.0, 0.0, -1.0),
</span><span class="boring">         0.5,
</span><span class="boring">         material_right,
</span><span class="boring">     )));
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span> 
     Camera::default()
         .with_aspect_ratio(16.0 / 9.0)
         .with_image_width(400)
         .with_samples_per_pixel(100)
         .with_max_depth(50)
         .with_vfov(20.0)
         .with_lookfrom(Point3::new(-2.0, 2.0, 1.0))
         .with_lookat(Point3::new(0.0, 0.0, -1.0))
         .with_vup(Point3::new(0.0, 1.0, 0.0))
+        .with_defocus_angle(10.0)
+        .with_focus_dist(3.4)
         .render(&amp;world)
 }</code></pre>
<p><strong>Listing 87:</strong> [<a href="https://github.com/goldnor/code/blob/f6173c36dab520541cdac68d8f9c40c24ca7b606/src/main.rs">main.rs</a>] <em>Scene camera with depth-of-field</em></p>
<br>
<p>We get:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/defocus_blur/../../imgs/img-1.22-depth-of-field.png" alt="Spheres with depth-of-field">
<p><strong>Image 22:</strong> <em>Spheres with depth-of-field</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-final-render"><a class="header" href="#a-final-render">A Final Render</a></h2>
<p>Let’s make the image on the cover of this book — lots of random spheres.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 51d420b..54ff4ef 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,58 +1,86 @@
</span><span class="boring"> use code::{
</span><span class="boring">     camera::Camera,
</span><span class="boring">     hittable_list::HittableList,
</span><span class="boring">-    material::{Dielectric, Lambertian, Metal},
</span><span class="boring">+    material::{Dielectric, Lambertian, Material, Metal},
</span><span class="boring">     prelude::*,
</span><span class="boring">     sphere::Sphere,
</span><span class="boring"> };
</span><span class="boring"> 
</span> fn main() -&gt; std::io::Result&lt;()&gt; {
     let mut world = HittableList::new();
 
<span class="boring">-    let material_ground = Rc::new(Lambertian::new(Color::new(0.8, 0.8, 0.0)));
</span><span class="boring">-    let material_center = Rc::new(Lambertian::new(Color::new(0.1, 0.2, 0.5)));
</span><span class="boring">-    let material_left = Rc::new(Dielectric::new(1.5));
</span><span class="boring">-    let material_bubble = Rc::new(Dielectric::new(1.0 / 1.5));
</span><span class="boring">-    let material_right = Rc::new(Metal::new(Color::new(0.8, 0.6, 0.2), 1.0));
</span><span class="boring">-
</span><span class="boring">-    world.add(Rc::new(Sphere::new(
</span><span class="boring">-        Point3::new(0.0, -100.5, -1.0),
</span><span class="boring">-        100.0,
</span><span class="boring">-        material_ground,
</span><span class="boring">-    )));
</span>+    let ground_material = Rc::new(Lambertian::new(Color::new(0.5, 0.5, 0.5)));
     world.add(Rc::new(Sphere::new(
<span class="boring">-        Point3::new(0.0, 0.0, -1.2),
</span><span class="boring">-        0.5,
</span><span class="boring">-        material_center,
</span>+        Point3::new(0.0, -1000.0, 0.0),
+        1000.0,
+        ground_material,
     )));
+
+    for a in -11..11 {
+        for b in -11..11 {
+            let choose_mat: f64 = rand::random();
+            let center = Point3::new(
+                a as f64 + 0.9 * rand::random::&lt;f64&gt;(),
+                0.2,
+                b as f64 + 0.9 * rand::random::&lt;f64&gt;(),
+            );
+
+            if (center - Point3::new(4.0, 0.2, 0.0)).length() &gt; 0.9 {
+                let sphere_material: Rc&lt;dyn Material&gt; = if choose_mat &lt; 0.8 {
+                    // diffuse
+                    let albedo = Color::random() * Color::random();
+
+                    Rc::new(Lambertian::new(albedo))
+                } else if choose_mat &lt; 0.95 {
+                    // metal
+                    let albedo = Color::random_range(0.5, 1.0);
+                    let fuzz = rand::random_range(0.0..0.5);
+
+                    Rc::new(Metal::new(albedo, fuzz))
+                } else {
+                    // glass
+
+                    Rc::new(Dielectric::new(1.5))
+                };
+
+                world.add(Rc::new(Sphere::new(center, 0.2, sphere_material)));
+            }
+        }
+    }
+
+    let material1 = Rc::new(Dielectric::new(1.5));
     world.add(Rc::new(Sphere::new(
<span class="boring">-        Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">-        0.5,
</span><span class="boring">-        material_left,
</span>+        Point3::new(0.0, 1.0, 0.0),
+        1.0,
+        material1,
     )));
+
+    let material2 = Rc::new(Lambertian::new(Color::new(0.4, 0.2, 0.1)));
     world.add(Rc::new(Sphere::new(
<span class="boring">-        Point3::new(-1.0, 0.0, -1.0),
</span><span class="boring">-        0.4,
</span><span class="boring">-        material_bubble,
</span>+        Point3::new(-4.0, 1.0, 0.0),
+        1.0,
+        material2,
     )));
+
+    let material3 = Rc::new(Metal::new(Color::new(0.7, 0.6, 0.5), 0.0));
     world.add(Rc::new(Sphere::new(
<span class="boring">-        Point3::new(1.0, 0.0, -1.0),
</span><span class="boring">-        0.5,
</span><span class="boring">-        material_right,
</span>+        Point3::new(4.0, 1.0, 0.0),
+        1.0,
+        material3,
     )));
 
     env_logger::init();
 
     Camera::default()
         .with_aspect_ratio(16.0 / 9.0)
<span class="boring">-        .with_image_width(400)
</span><span class="boring">-        .with_samples_per_pixel(100)
</span>+        .with_image_width(1200)
+        .with_samples_per_pixel(500)
         .with_max_depth(50)
         .with_vfov(20.0)
<span class="boring">-        .with_lookfrom(Point3::new(-2.0, 2.0, 1.0))
</span><span class="boring">-        .with_lookat(Point3::new(0.0, 0.0, -1.0))
</span>+        .with_lookfrom(Point3::new(13.0, 2.0, 3.0))
+        .with_lookat(Point3::new(0.0, 0.0, 0.0))
         .with_vup(Point3::new(0.0, 1.0, 0.0))
<span class="boring">-        .with_defocus_angle(10.0)
</span><span class="boring">-        .with_focus_dist(3.4)
</span>+        .with_defocus_angle(0.6)
+        .with_focus_dist(10.0)
         .render(&amp;world)
 }</code></pre>
<p><strong>Listing 88:</strong> [<a href="chapters/where_next/">main.rs</a>] <em>Final scene</em></p>
<br>
<p>(Note that the code above differs slightly from the project sample code: the <code>samples_per_pixel</code> is set to 500 above for a high-quality image that will take quite a while to render. The project source code uses a value of 10 in the interest of reasonable run times while developing and validating.)</p>
<p>This gives:</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/where_next/../../imgs/img-1.23-book1-final.jpg" alt="Final scene">
<p><strong>Image 23:</strong> <em>Final scene</em></p>
<br>
<p>An interesting thing you might note is the glass balls don’t really have shadows which makes them look like they are floating. This is not a bug — you don’t see glass balls much in real life, where they also look a bit strange, and indeed seem to float on cloudy days. A point on the big sphere under a glass ball still has lots of light hitting it because the sky is re-ordered rather than blocked.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>You now have a cool ray tracer! What next?</p>
<h3 id="book-2-ray-tracing-the-next-week"><a class="header" href="#book-2-ray-tracing-the-next-week">Book 2: Ray Tracing: The Next Week</a></h3>
<p>The second book in this series builds on the ray tracer you've developed here. This includes new features such as:</p>
<ul>
<li>Motion blur — Realistically render moving objects.</li>
<li>Bounding volume hierarchies — speeding up the rendering of complex scenes.</li>
<li>Texture maps — placing images on objects.</li>
<li>Perlin noise — a random noise generator very useful for many techniques.</li>
<li>Quadrilaterals — something to render besides spheres! Also, the foundation to implement disks, triangles, rings or just about any other 2D primitive.</li>
<li>Lights — add sources of light to your scene.</li>
<li>Transforms — useful for placing and rotating objects.</li>
<li>Volumetric rendering — render smoke, clouds and other gaseous volumes.</li>
</ul>
<h3 id="book-3-ray-tracing-the-rest-of-your-life"><a class="header" href="#book-3-ray-tracing-the-rest-of-your-life">Book 3: Ray Tracing: The Rest of Your Life</a></h3>
<p>This book expands again on the content from the second book. A lot of this book is about improving both the rendered image quality and the renderer performance, and focuses on generating the <em>right rays</em> and accumulating them appropriately.</p>
<p>This book is for the reader seriously interested in writing professional-level ray tracers, and/or interested in the foundation to implement advanced effects like subsurface scattering or nested dielectrics.</p>
<h3 id="other-directions"><a class="header" href="#other-directions">Other Directions</a></h3>
<p>There are so many additional directions you can take from here, including techniques we haven't (yet?) covered in this series. These include:</p>
<p><strong>Triangles</strong> — Most cool models are in triangle form. The model I/O is the worst and almost everybody tries to get somebody else’s code to do this. This also includes efficiently handling large meshes of triangles, which present their own challenges.</p>
<p><strong>Parallelism</strong> — Run \( N \) copies of your code on \( N \) cores with different random seeds. Average the \( N \) runs. This averaging can also be done hierarchically where \( N/2 \) pairs can be averaged to get \( N/4 \) images, and pairs of those can be averaged. That method of parallelism should extend well into the thousands of cores with very little coding.</p>
<p><strong>Shadow Rays</strong> — When firing rays at light sources, you can determine exactly how a particular point is shadowed. With this, you can render crisp or soft shadows, adding another degreee of realism to your scenes.</p>
<p>Have fun, and please send me your cool images!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h1>
<h3 id="original-manuscript-help"><a class="header" href="#original-manuscript-help">Original Manuscript Help</a></h3>
<ul>
<li>Dave Hart</li>
<li>Jean Buckley</li>
</ul>
<h3 id="web-release"><a class="header" href="#web-release">Web Release</a></h3>
<ul>
<li><a href="https://github.com/bernakabadayi">Berna Kabadayı</a></li>
<li><a href="https://github.com/lmancini">Lorenzo Mancini</a></li>
<li><a href="https://github.com/lorihollasch">Lori Whippler Hollasch</a></li>
<li><a href="https://github.com/ronaldfw">Ronald Wotzlaw</a></li>
</ul>
<h3 id="corrections-and-improvements"><a class="header" href="#corrections-and-improvements">Corrections and Improvements</a></h3>
<ul>
<li><a href="https://github.com/jammm">Aaryaman Vasishta</a></li>
<li>Andrew Kensler</li>
<li><a href="https://github.com/antoniogamiz">Antonio Gamiz</a></li>
<li>Apoorva Joshi</li>
<li><a href="https://github.com/aras-p">Aras Pranckevičius</a></li>
<li><a href="https://github.com/armansito">Arman Uguray</a></li>
<li>Becker</li>
<li>Ben Kerl</li>
<li>Benjamin Summerton</li>
<li>Bennett Hardwick</li>
<li><a href="https://bthtsang.github.io/">Benny Tsang</a></li>
<li>Dan Drummond</li>
<li><a href="https://github.com/dafhi">David Chambers</a></li>
<li>David Hart</li>
<li><a href="https://github.com/dimitry-ishenko">Dimitry Ishenko</a></li>
<li><a href="https://github.com/mu-lambda">Dmitry Lomov</a></li>
<li><a href="https://github.com/erich666">Eric Haines</a></li>
<li>Fabio Sancinetti</li>
<li>Filipe Scur</li>
<li>Frank He</li>
<li><a href="https://github.com/TheThief">Gareth Martin</a></li>
<li><a href="https://github.com/celeph">Gerrit Wessendorf</a></li>
<li>Grue Debry</li>
<li><a href="https://github.com/xaldew">Gustaf Waldemarson</a></li>
<li>Ingo Wald</li>
<li>Jason Stone</li>
<li><a href="https://github.com/JC-ProgJava">JC-ProgJava</a></li>
<li>Jean Buckley</li>
<li><a href="https://github.com/whydoubt">Jeff Smith</a></li>
<li>Joey Cho</li>
<li><a href="https://github.com/rjkilpatrick">John Kilpatrick</a></li>
<li><a href="https://github.com/D-K-E">Kaan Eraslan</a></li>
<li><a href="https://github.com/lmancini">Lorenzo Mancini</a></li>
<li><a href="https://github.com/manas96">Manas Kale</a></li>
<li>Marcus Ottosson</li>
<li><a href="https://github.com/mrmcsoftware">Mark Craig</a></li>
<li>Markus Boos</li>
<li>Matthew Heimlich</li>
<li>Nakata Daisuke</li>
<li><a href="https://github.com/rupsis">Nate Rupsis</a></li>
<li><a href="https://github.com/niccolot">Niccolò Tiezzi</a></li>
<li>Paul Melis</li>
<li>Phil Cristensen</li>
<li><a href="https://github.com/LollipopFt">LollipopFt</a></li>
<li><a href="https://github.com/ronaldfw">Ronald Wotzlaw</a></li>
<li><a href="https://github.com/shaunplee">Shaun P. Lee</a></li>
<li><a href="https://github.com/estshorter">Shota Kawajiri</a></li>
<li>Tatsuya Ogawa</li>
<li>Thiago Ize</li>
<li><a href="https://github.com/gau-nernst">Thien Tran</a></li>
<li>Vahan Sosoyan</li>
<li><a href="https://github.com/wlbksy">WANG Lei</a></li>
<li><a href="https://github.com/ymherklotz">Yann Herklotz</a></li>
<li><a href="https://github.com/oxine">ZeHao Chen</a></li>
</ul>
<h3 id="special-thanks"><a class="header" href="#special-thanks">Special Thanks</a></h3>
<p>Thanks to the team at <a href="https://limnu.com/">Limnu</a> for help on the figures.</p>
<p>These books are entirely written in Morgan McGuire's fantastic and free <a href="https://casual-effects.com/markdeep/">Markdeep</a> library. To see what this looks like, view the page source from your browser. <sup class="footnote-reference" id="fr-15a-1"><a href="#footnote-15a">1</a></sup></p>
<p>Thanks to <a href="https://github.com/hhu">Helen Hu</a> for graciously donating her <a href="https://github.com/RayTracing/">https://github.com/RayTracing/</a> GitHub organization to this project.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-15a">
<p>We used <a href="https://github.com/rust-lang/mdBook">mdBook</a> instead. Thank you for the great tool to document and write books! <a href="#fr-15a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="citing-this-book"><a class="header" href="#citing-this-book">Citing This Book</a></h1>
<p>Consistent citations make it easier to identify the source, location and versions of this work. If you are citing this book, we ask that you try to use one of the following forms if possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="basic-data"><a class="header" href="#basic-data">Basic Data</a></h2>
<ul>
<li><strong>Title (series)</strong>: “Ray Tracing in One Weekend Series”</li>
<li><strong>Title (book)</strong>: “Ray Tracing in One Weekend”</li>
<li><strong>Author</strong>: Peter Shirley, Trevor David Black, Steve Hollasch</li>
<li><strong>Version/Edition</strong>: v4.0.2</li>
<li><strong>Date: 2025-04-25</strong></li>
<li><strong>URL (series)</strong>: https://raytracing.github.io</li>
<li><strong>URL (book)</strong>: https://raytracing.github.io/books/raytracinginoneweekend.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="snippets"><a class="header" href="#snippets">Snippets</a></h2>
<h3 id="markdown"><a class="header" href="#markdown">Markdown</a></h3>
<pre><code class="language-markdown">[_Ray Tracing in One Weekend_](https://raytracing.github.io/books/RayTracingInOneWeekend.html)
</code></pre>
<h3 id="html"><a class="header" href="#html">HTML</a></h3>
<pre><code class="language-html">&lt;a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html"&gt;
    &lt;cite&gt;Ray Tracing in One Weekend&lt;/cite&gt;
&lt;/a&gt;
</code></pre>
<h3 id="latex-adn-bibtex"><a class="header" href="#latex-adn-bibtex">LaTeX adn BibTex</a></h3>
<pre><code class="language-tex">~\cite{Shirley2025RTW1}

@misc{Shirley2025RTW1,
   title = {Ray Tracing in One Weekend},
   author = {Peter Shirley, Trevor David Black, Steve Hollasch},
   year = {2025},
   month = {April},
   note = {\small \texttt{https://raytracing.github.io/books/RayTracingInOneWeekend.html}},
   url = {https://raytracing.github.io/books/RayTracingInOneWeekend.html}
}
</code></pre>
<h3 id="biblatex"><a class="header" href="#biblatex">BibLaTeX</a></h3>
<pre><code class="language-tex">\usepackage{biblatex}

~\cite{Shirley2025RTW1}

@online{Shirley2025RTW1,
   title = {Ray Tracing in One Weekend},
   author = {Peter Shirley, Trevor David Black, Steve Hollasch},
   year = {2025},
   month = {April},
   url = {https://raytracing.github.io/books/RayTracingInOneWeekend.html}
}
</code></pre>
<h3 id="ieee"><a class="header" href="#ieee">IEEE</a></h3>
<pre><code class="language-plaintext">“Ray Tracing in One Weekend.” raytracing.github.io/books/RayTracingInOneWeekend.html
(accessed MMM. DD, YYYY)
</code></pre>
<h3 id="mla"><a class="header" href="#mla">MLA</a></h3>
<pre><code class="language-plaintext">Ray Tracing in One Weekend. raytracing.github.io/books/RayTracingInOneWeekend.html
Accessed DD MMM. YYYY.
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
