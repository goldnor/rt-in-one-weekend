<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ray Tracing in One Weekend (Rust)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ray Tracing in One Weekend (Rust)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h1>
<p>The content of the original <a href="https://raytracing.github.io">book series</a> is licensed under the <a href="https://github.com/RayTracing/raytracing.github.io/blob/release/COPYING.txt">CC0 license</a>, which permits copying, modification, and distribution. The explanations are copied directly and have been annotated with Rust-specific details where appropriate. Any sentences that include words such as <em>I</em>, <em>me</em>, or <em>mine</em> are from the original authors, Peter Shirley, Trevor David Black or Steve Hollasch. Once again, thank you for this outstanding book series.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="chapters/../imgs/cover/CoverRTW1.jpg" alt="cover" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>I’ve taught many graphics classes over the years. Often I do them in ray tracing, because you are forced to write all the code, but you can still get cool images with no API. I decided to adapt my course notes into a how-to, to get you to a cool program as quickly as possible. It will not be a full-featured ray tracer, but it does have the indirect lighting which has made ray tracing a staple in movies. Follow these steps, and the architecture of the ray tracer you produce will be good for extending to a more extensive ray tracer if you get excited and want to pursue that.</p>
<p>When somebody says “ray tracing” it could mean many things. What I am going to describe is technically a path tracer, and a fairly general one. While the code will be pretty simple (let the computer do the work!) I think you’ll be very happy with the images you can make.</p>
<p>I’ll take you through writing a ray tracer in the order I do it, along with some debugging tips. By the end, you will have a ray tracer that produces some great images. You should be able to do this in a weekend. If you take longer, don’t worry about it. I use C++ as the driving language, but you don’t need to.<sup class="footnote-reference" id="fr-1a-1"><a href="#footnote-1a">1</a></sup> However, I suggest you do, because it’s fast, portable, and most production movie and video game renderers are written in C++. Note that I avoid most “modern features” of C++, but inheritance and operator overloading are too useful for ray tracers to pass on.<sup class="footnote-reference" id="fr-1b-1"><a href="#footnote-1b">2</a></sup></p>
<p>I do not provide the code online, but the code is real and I show all of it except for a few straightforward operators in the vec3 class. I am a big believer in typing in code to learn it, but when code is available I use it, so I only practice what I preach when the code is not available. So don’t ask!
I have left that last part in because it is funny what a 180 I have done. Several readers ended up with subtle errors that were helped when we compared code. So please do type in the code, but you can find the finished source for each book in the <a href="https://github.com/goldnor/rt-books">RayTracing project on GitHub</a>.</p>
<p>A note on the implementing code for these books — our philosophy for the included code prioritizes the following goals:</p>
<ul>
<li>The code should implement the concepts covered in the books.</li>
<li>We use C++, but as simple as possible. Our programming style is very C-like, but we take advantage of modern features where it makes the code easier to use or understand.</li>
<li>Our coding style continues the style established from the original books as much as possible, for continuity.</li>
<li>Line length is kept to 96 characters per line, to keep lines consistent between the codebase and code listings in the books.<sup class="footnote-reference" id="fr-1c-1"><a href="#footnote-1c">3</a></sup></li>
</ul>
<p>The code thus provides a baseline implementation, with tons of improvements left for the reader to enjoy. There are endless ways one can optimize and modernize the code; we prioritize the simple solution.</p>
<p>We assume a little bit of familiarity with vectors (like dot product and vector addition). If you don’t know that, do a little review. If you need that review, or to learn it for the first time, check out the online <em><a href="https://graphicscodex.com/">Graphics Codex</a></em> by Morgan McGuire, <em>Fundamentals of Computer Graphics</em> by Steve Marschner and Peter Shirley, or <em>Computer Graphics: Principles and Practice</em> by J.D. Foley and Andy Van Dam.</p>
<p>See the <a href="https://github.com/goldnor/rt-books/blob/main/README.md">project README</a> file for information about this project, the repository on GitHub, directory structure, building &amp; running, and how to make or reference corrections and contributions.</p>
<p>See our <a href="https://github.com/RayTracing/raytracing.github.io/wiki/Further-Readings">Further Reading wiki page</a> for additional project related resources.</p>
<p>These books have been formatted to print well directly from your browser. We also include PDFs of each book <a href="chapters/TODO">with each release</a>, in the “Assets” section.</p>
<p>If you want to communicate with us, feel free to send us an email at:</p>
<ul>
<li>Peter Shirley, <a href="mailto:ptrshrl@gmail.com">ptrshrl@gmail.com</a></li>
<li>Steve Hollasch, <a href="mailto:steve@hollasch.net">steve@hollasch.net</a></li>
<li>Trevor David Black, <a href="mailto:trevordblack@trevord.black">trevordblack@trevord.black</a></li>
</ul>
<p>Finally, if you run into problems with your implementation, have general questions, or would like to share your own ideas or work, see the GitHub Discussions forum on the GitHub project.</p>
<p>Thanks to everyone who lent a hand on this project. You can find them in the acknowledgments section at the end of this book.</p>
<p>Let’s get on with it!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1a">
<p>There is where Rust comes into play - a fast, reliable language with better ergonomics. This is an unbiased opinion of course *caugh*. <a href="#fr-1a-1">↩</a></p>
</li>
<li id="footnote-1b">
<p>Inheritance is not supported in Rust. In many places simple composition and traits will do the trick. <a href="#fr-1b-1">↩</a></p>
</li>
<li id="footnote-1c">
<p><a href="https://github.com/rust-lang/rustfmt">rustfmt</a> will be used instead, as it is shipped with most IDEs. <a href="#fr-1c-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="the-ppm-image-format"><a class="header" href="#the-ppm-image-format">The PPM Image Format</a></h2>
<p>Whenever you start a renderer, you need a way to see an image. The most straightforward way is to write it to a file. The catch is, there are so many formats. Many of those are complex. I always start with a plain text ppm file. Here’s a nice description from Wikipedia:</p>
<p><img src="chapters/output_an_image/../../imgs/fig-1.01-ppm.jpg" alt="PPM Example" /></p>
<p><strong>Figure 1:</strong> <em>PPM Example</em></p>
<br>
<p>Let’s make some C++ code to output such a thing:<sup class="footnote-reference" id="fr-21a-1"><a href="#footnote-21a">1</a></sup></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Image

    const IMAGE_WIDTH: u32 = 256;
    const IMAGE_HEIGHT: u32 = 256;

    // Render

    println!("P3");
    println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
    println!("255");

    for j in 0..IMAGE_HEIGHT {
        for i in 0..IMAGE_WIDTH {
            let r = i as f64 / (IMAGE_WIDTH - 1) as f64;
            let g = j as f64 / (IMAGE_HEIGHT - 1) as f64;
            let b = 0.0;

            let ir = (255.999 * r) as i32;
            let ig = (255.999 * g) as i32;
            let ib = (255.999 * b) as i32;

            println!("{ir} {ig} {ib}");
        }
    }
}</code></pre></pre>
<p><strong>Listing 1:</strong> [<a href="https://github.com/goldnor/code/blob/c2b88fe22dadf9cba6dff369ee0b1834dd9733d4/src/main.rs">main.rs</a>] <em>Creating your first image</em></p>
<br>
<p>There are some things to note in this code:</p>
<ol>
<li>The pixels are written out in rows.</li>
<li>Every row of pixels is written out left to right.</li>
<li>These rows are written out from top to bottom.</li>
<li>By convention, each of the red/green/blue components are represented internally by real-valued variables that range from 0.0 to 1.0. These must be scaled to integer values between 0 and 255 before we print them out.</li>
<li>Red goes from fully off (black) to fully on (bright red) from left to right, and green goes from fully off at the top (black) to fully on at the bottom (bright green). Adding red and green light together make yellow so we should expect the bottom right corner to be yellow.</li>
</ol>
<hr>
<ol class="footnote-definition"><li id="footnote-21a">
<p>It is Rust code of course. This won't be annotated anymore. <a href="#fr-21a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="creating-an-image-file"><a class="header" href="#creating-an-image-file">Creating an Image File</a></h2>
<p>Because the file is written to the standard output stream, you'll need to redirect it to an image file. Typically this is done from the command-line by using the <code>&gt;</code> redirection operator.</p>
<p>On Windows, you'd get the debug build from CMake running this command:<sup class="footnote-reference" id="fr-22a-1"><a href="#footnote-22a">1</a></sup></p>
<pre><code class="language-shell">cargo b
</code></pre>
<p>Then run your newly-built program like so:<sup class="footnote-reference" id="fr-22b-1"><a href="#footnote-22b">2</a></sup></p>
<pre><code class="language-shell">cargo r &gt; image.ppm
</code></pre>
<p>Later, it will be better to run optimized builds for speed. In that case, you would build like this:</p>
<pre><code class="language-shell">cargo b -r
</code></pre>
<p>and would run the optimized program like this:</p>
<pre><code class="language-shell">cargo r -r
</code></pre>
<p>The examples above assume that you are building with CMake, using the same approach as the CMakeLists.txt file in the included source. Use whatever build environment (and language) you're most comfortable with.</p>
<p>On Mac or Linux, release build, you would launch the program like this:<sup class="footnote-reference" id="fr-22c-1"><a href="#footnote-22c">3</a></sup></p>
<pre><code class="language-shell">cargo r &gt; image.ppm
</code></pre>
<p>Complete building and running instructions can be found in the <a href="https://github.com/goldnor/rt-books/blob/main/README.md">project README</a>.</p>
<p>Opening the output file (in <code>ToyViewer</code> on my Mac, but try it in your favorite image viewer and Google “ppm viewer” if your viewer doesn’t support it) shows this result:</p>
<img style="width: 100%" src="chapters/output_an_image/../../imgs/img-1.01-first-ppm-image.png" alt="First PPM image">
<p><strong>Image 1:</strong> <em>First PPM image</em></p>
<br>
<p>Hooray! This is the graphics “hello world”. If your image doesn’t look like that, open the output file in a text editor and see what it looks like. It should start something like this:</p>
<pre><code class="language-ppm">P3
256 256
255
0 0 0
1 0 0
2 0 0
3 0 0
4 0 0
5 0 0
6 0 0
7 0 0
8 0 0
9 0 0
10 0 0
11 0 0
12 0 0
...
</code></pre>
<p><strong>Listing 2:</strong> <em>First image output</em></p>
<br>
<p>If your PPM file doesn't look like this, then double-check your formatting code. If it <em>does</em> look like this but fails to render, then you may have line-ending differences or something similar that is confusing your image viewer. To help debug this, you can find a file <code>test.ppm</code> in the <code>images</code> directory of the Github project. This should help to ensure that your viewer can handle the PPM format and to use as a comparison against your generated PPM file.</p>
<p>Some readers have reported problems viewing their generated files on Windows. In this case, the problem is often that the PPM is written out as UTF-16, often from PowerShell. If you run into this problem, see <a href="https://github.com/RayTracing/raytracing.github.io/discussions/1114">Discussion 1114</a> for help with this issue.</p>
<p>If everything displays correctly, then you're pretty much done with system and IDE issues — everything in the remainder of this series uses this same simple mechanism for generated rendered images.</p>
<p>If you want to produce other image formats, I am a fan of <code>stb_image.h</code>, a header-only image library available on GitHub at <a href="https://github.com/nothings/stb">https://github.com/nothings/stb</a>.<sup class="footnote-reference" id="fr-22d-1"><a href="#footnote-22d">4</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-22a">
<p>We are not using CMake; we are relying on the standard cargo build tool. <a href="#fr-22a-1">↩</a></p>
</li>
<li id="footnote-22b">
<p>You can skip the building step since it is part of the run command (or <code>r</code> for short). <a href="#fr-22b-1">↩</a></p>
</li>
<li id="footnote-22c">
<p>It is the same as for Windows. <a href="#fr-22c-1">↩</a></p>
</li>
<li id="footnote-22d">
<p>Rust crate alternativ: <a href="https://crates.io/crates/stb_image">https://crates.io/crates/stb_image</a>. <a href="#fr-22d-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="adding-a-progress-indicator"><a class="header" href="#adding-a-progress-indicator">Adding a Progress Indicator</a></h2>
<p>Before we continue, let's add a progress indicator to our output. This is a handy way to track the progress of a long render, and also to possibly identify a run that's stalled out due to an infinite loop or other problem.</p>
<p>Our program outputs the image to the standard output stream (<code>std::cout</code>), so leave that alone and instead write to the logging output stream (<code>std::clog</code>):<sup class="footnote-reference" id="fr-23a-1"><a href="#footnote-23a">1</a></sup></p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index af636bc..00cad27 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,26 +1,29 @@
</span><span class="boring"> fn main() {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const IMAGE_WIDTH: u32 = 256;
</span><span class="boring">     const IMAGE_HEIGHT: u32 = 256;
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span>+    env_logger::init();
     println!("P3");
     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
     println!("255");
 
     for j in 0..IMAGE_HEIGHT {
+        log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
         for i in 0..IMAGE_WIDTH {
             let r = i as f64 / (IMAGE_WIDTH - 1) as f64;
             let g = j as f64 / (IMAGE_HEIGHT - 1) as f64;
             let b = 0.0;
 
             let ir = (255.999 * r) as i32;
             let ig = (255.999 * g) as i32;
             let ib = (255.999 * b) as i32;
 
             println!("{ir} {ig} {ib}");
         }
     }
+    log::info!("Done.");
<span class="boring"> }</span></code></pre>
<p><strong>Listing 3:</strong> [<a href="https://github.com/goldnor/code/blob/5c4dfec5c8122b0a6df768027866c4a526da8677/src/main.rs">main.rs</a>] <em>Main render loop with progress reporting</em></p>
<br>
<p>Now when running, you'll see a running count of the number of scanlines remaining. Hopefully this runs so fast that you don't even see it! Don't worry — you'll have lots of time in the future to watch a slowly updating progress line as we expand our ray tracer.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-23a">
<p>The <a href="https://crates.io/crates/log">log crate</a> with the <a href="https://crates.io/crates/env_logger">env_logger</a> implementation is a good alternative to <code>std::clog</code>. Run <code>RUST_LOG=info cargo r &gt; image.ppm</code> for the log output. <a href="#fr-23a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="the-vec3-class-1"><a class="header" href="#the-vec3-class-1">The vec3 Class <sup class="footnote-reference" id="fr-3a-1"><a href="#footnote-3a">1</a></sup></a></h1>
<p>Almost all graphics programs have some class(es) for storing geometric vectors and colors. In many systems these vectors are 4D (3D position plus a homogeneous coordinate for geometry, or RGB plus an alpha transparency component for colors). For our purposes, three coordinates suffice. We’ll use the same class vec3 for colors, locations, directions, offsets, whatever. Some people don’t like this because it doesn’t prevent you from doing something silly, like subtracting a position from a color. They have a good point, but we’re going to always take the “less code” route when not obviously wrong. In spite of this, we do declare two aliases for vec3: point3 and color. Since these two types are just aliases for vec3, you won't get warnings if you pass a color to a function expecting a point3, and nothing is stopping you from adding a point3 to a color, but it makes the code a little bit easier to read and to understand.</p>
<p>We define the vec3 class in the top half of a new vec3.h header file, and define a set of useful vector utility functions in the bottom half:</p>
<pre><code class="language-rust norun noplayground">use std::{
    fmt::Display,
    ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
};

#[derive(Debug, Default, Clone, Copy)]
pub struct Vec3 {
    pub e: [f64; 3],
}

pub type Point3 = Vec3;

impl Vec3 {
    pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
        Self { e: [e0, e1, e2] }
    }

    pub fn x(&amp;self) -&gt; f64 {
        self.e[0]
    }

    pub fn y(&amp;self) -&gt; f64 {
        self.e[1]
    }

    pub fn z(&amp;self) -&gt; f64 {
        self.e[2]
    }

    pub fn length(&amp;self) -&gt; f64 {
        f64::sqrt(self.length_squared())
    }

    pub fn length_squared(&amp;self) -&gt; f64 {
        self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
    }
}

impl Neg for Vec3 {
    type Output = Self;

    fn neg(self) -&gt; Self::Output {
        Self::Output {
            e: self.e.map(|e| -e),
        }
    }
}

impl Index&lt;usize&gt; for Vec3 {
    type Output = f64;

    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self.e[index]
    }
}

impl IndexMut&lt;usize&gt; for Vec3 {
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
        &amp;mut self.e[index]
    }
}

impl AddAssign for Vec3 {
    fn add_assign(&amp;mut self, rhs: Self) {
        self.e[0] += rhs.e[0];
        self.e[1] += rhs.e[1];
        self.e[2] += rhs.e[2];
    }
}

impl MulAssign&lt;f64&gt; for Vec3 {
    fn mul_assign(&amp;mut self, rhs: f64) {
        self.e[0] *= rhs;
        self.e[1] *= rhs;
        self.e[2] *= rhs;
    }
}

impl DivAssign&lt;f64&gt; for Vec3 {
    fn div_assign(&amp;mut self, rhs: f64) {
        self.mul_assign(1.0 / rhs);
    }
}

impl Display for Vec3 {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
    }
}

impl Add for Vec3 {
    type Output = Self;

    fn add(self, rhs: Self) -&gt; Self::Output {
        Self::Output {
            e: [
                self.e[0] + rhs.e[0],
                self.e[1] + rhs.e[1],
                self.e[2] + rhs.e[2],
            ],
        }
    }
}

impl Sub for Vec3 {
    type Output = Self;

    fn sub(self, rhs: Self) -&gt; Self::Output {
        Self::Output {
            e: [
                self.e[0] - rhs.e[0],
                self.e[1] - rhs.e[1],
                self.e[2] - rhs.e[2],
            ],
        }
    }
}

impl Mul for Vec3 {
    type Output = Self;

    fn mul(self, rhs: Self) -&gt; Self::Output {
        Self::Output {
            e: [
                self.e[0] * rhs.e[0],
                self.e[1] * rhs.e[1],
                self.e[2] * rhs.e[2],
            ],
        }
    }
}

impl Mul&lt;f64&gt; for Vec3 {
    type Output = Self;

    fn mul(self, rhs: f64) -&gt; Self::Output {
        Self::Output {
            e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
        }
    }
}

impl Mul&lt;Vec3&gt; for f64 {
    type Output = Vec3;

    fn mul(self, rhs: Vec3) -&gt; Self::Output {
        rhs.mul(self)
    }
}

impl Div&lt;f64&gt; for Vec3 {
    type Output = Self;

    fn div(self, rhs: f64) -&gt; Self::Output {
        self * (1.0 / rhs)
    }
}

#[inline]
pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
    u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
}

#[inline]
pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
    Vec3::new(
        u.e[1] * v.e[2] - u.e[2] * v.e[1],
        u.e[2] * v.e[0] - u.e[0] * v.e[2],
        u.e[0] * v.e[1] - u.e[1] * v.e[0],
    )
}

#[inline]
pub fn unit_vector(v: Vec3) -&gt; Vec3 {
    v / v.length()
}</code></pre>
<p><strong>Listing 4:</strong> [<a href="https://github.com/goldnor/code/blob/400e8e91847d5b2fbde6eb17432cbbe49794e28d/src/vec3.rs">vec3.rs</a>] <em>vec3 definitions and helper functions</em></p>
<br>
<p>We use double here, but some ray tracers use float. double has greater precision and range, but is twice the size compared to float. This increase in size may be important if you're programming in limited memory conditions (such as hardware shaders). Either one is fine — follow your own tastes.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-3a">
<p>There are no classes in Rust. They are replaced with structs. <a href="#fr-3a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="color-utility-functions"><a class="header" href="#color-utility-functions">Color Utility Functions</a></h2>
<p>Using our new <code>vec3</code> class, we'll create a new <code>color.h</code> header file and define a utility function that writes a single pixel's color out to the standard output stream.</p>
<pre><code class="language-rust norun noplayground">use crate::vec3::Vec3;

pub type Color = Vec3;

pub fn write_color(mut out: impl std::io::Write, pixel_color: Color) -&gt; std::io::Result&lt;()&gt; {
    let r = pixel_color.x();
    let g = pixel_color.y();
    let b = pixel_color.z();

    let rbyte = (255.999 * r) as i32;
    let gbyte = (255.999 * g) as i32;
    let bbyte = (255.999 * b) as i32;

    writeln!(out, "{rbyte} {gbyte} {bbyte}")
}</code></pre>
<p><strong>Listing 5:</strong> [<a href="https://github.com/goldnor/code/blob/6a4c63a317edcf4bb154fff3f817c561c2ed3aa9/src/color.rs">color.rs</a>] <em>color utility functions</em></p>
<br>
<p>Now we can change our main to use both of these:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 00cad27..bb37ee6 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,29 +1,30 @@
</span><span class="boring">-fn main() {
</span>+use code::color::{Color, write_color};
+
+fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
     // Image
 
     const IMAGE_WIDTH: u32 = 256;
     const IMAGE_HEIGHT: u32 = 256;
 
     // Render
 
     env_logger::init();
     println!("P3");
     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
     println!("255");
 
     for j in 0..IMAGE_HEIGHT {
         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
         for i in 0..IMAGE_WIDTH {
<span class="boring">-            let r = i as f64 / (IMAGE_WIDTH - 1) as f64;
</span><span class="boring">-            let g = j as f64 / (IMAGE_HEIGHT - 1) as f64;
</span><span class="boring">-            let b = 0.0;
</span><span class="boring">-
</span><span class="boring">-            let ir = (255.999 * r) as i32;
</span><span class="boring">-            let ig = (255.999 * g) as i32;
</span><span class="boring">-            let ib = (255.999 * b) as i32;
</span><span class="boring">-
</span><span class="boring">-            println!("{ir} {ig} {ib}");
</span>+            let pixel_color = Color::new(
+                i as f64 / (IMAGE_WIDTH - 1) as f64,
+                j as f64 / (IMAGE_HEIGHT - 1) as f64,
+                0.0,
+            );
+            write_color(std::io::stdout(), pixel_color)?;
         }
     }
     log::info!("Done.");
+
+    Ok(())
 }</code></pre>
<p><strong>Listing 6:</strong> [<a href="https://github.com/goldnor/code/blob/7e3d601b91c93177f3b3d1ed98aa69d8ecf4ffee/src/main.rs">main.rs</a>)] <em>Final code for the first PPM image</em></p>
<br>
<p>And you should get the exact same picture as before.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-ray-class"><a class="header" href="#the-ray-class">The ray Class</a></h2>
<p>The one thing that all ray tracers have is a ray class and a computation of what color is seen along a ray. Let’s think of a ray as a function \( \mathbf{P} (t) = \mathbf{A} + t \mathbf{b} \). Here \( \mathbf{P} \) is a 3D position along a line in 3D. \( \mathbf{A} \) is the ray origin and \( \mathbf{b} \) is the ray direction. The ray parameter \( t \) is a real number (double in the code). Plug in a different \( t \) and \( \mathbf{P} (t) \) moves the point along the ray. Add in negative \( t \) values and you can go anywhere on the 3D line. For positive \( t \), you get only the parts in front of \( \mathbf{A} \), and this is what is often called a half-line or a ray.</p>
<p><img src="chapters/rays_a_simple_camera_and_background/../../imgs/fig-1.02-lerp.jpg" alt="Linear interpolation" /></p>
<p><strong>Figure 2:</strong> <em>Linear interpolation</em></p>
<br>
<p>We can represent the idea of a ray as a class, and represent the function \( \mathbf{P} (t) \) as a function that we'll call <code>ray::at(t)</code>:</p>
<pre><code class="language-rust norun noplayground">use crate::vec3::{Point3, Vec3};

#[derive(Debug, Default, Clone, Copy)]
pub struct Ray {
    origin: Point3,
    direction: Vec3,
}

impl Ray {
    pub fn new(origin: Point3, direction: Vec3) -&gt; Self {
        Self { origin, direction }
    }

    pub fn origin(&amp;self) -&gt; Point3 {
        self.origin
    }

    pub fn direction(&amp;self) -&gt; Vec3 {
        self.direction
    }

    pub fn at(&amp;self, t: f64) -&gt; Point3 {
        self.origin + t * self.direction
    }
}</code></pre>
<p><strong>Listing 7:</strong> [<a href="https://github.com/goldnor/code/blob/b54170d548e41ff6ea02b4eceb59269ee20b2a56/src/ray.rs">ray.rs</a>] <em>The ray class</em></p>
<br>
<p>(For those unfamiliar with C++, the functions ray::origin() and ray::direction() both return an immutable reference to their members. Callers can either just use the reference directly, or make a mutable copy depending on their needs.) <sup class="footnote-reference" id="fr-41a-1"><a href="#footnote-41a">1</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-41a">
<p>The careful reader may have noticed that, in the Rust approach, both the <code>Vec3</code> and <code>Ray</code> structs implement Copy. This method is generally more common than returning a reference and cloning it for mutability when needed. <a href="#fr-41a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="sending-rays-into-the-scene"><a class="header" href="#sending-rays-into-the-scene">Sending Rays Into the Scene</a></h2>
<p>Now we are ready to turn the corner and make a ray tracer. At its core, a ray tracer sends rays through pixels and computes the color seen in the direction of those rays. The involved steps are</p>
<ol>
<li>Calculate the ray from the “eye” through the pixel,</li>
<li>Determine which objects the ray intersects, and</li>
<li>Compute a color for the closest intersection point.</li>
</ol>
<p>When first developing a ray tracer, I always do a simple camera for getting the code up and running.</p>
<p>I’ve often gotten into trouble using square images for debugging because I transpose 𝑥 and 𝑦 too often, so we’ll use a non-square image. A square image has a 1∶1 aspect ratio, because its width is the same as its height. Since we want a non-square image, we'll choose 16∶9 because it's so common. A 16∶9 aspect ratio means that the ratio of image width to image height is 16∶9. Put another way, given an image with a 16∶9 aspect ratio,</p>
<p>\[ width\,/\,height=16\,/\,9=1.7778 \]</p>
<p>For a practical example, an image 800 pixels wide by 400 pixels high has a 2∶1 aspect ratio.</p>
<p>The image's aspect ratio can be determined from the ratio of its width to its height. However, since we have a given aspect ratio in mind, it's easier to set the image's width and the aspect ratio, and then using this to calculate for its height. This way, we can scale up or down the image by changing the image width, and it won't throw off our desired aspect ratio. We do have to make sure that when we solve for the image height the resulting height is at least 1.</p>
<p>In addition to setting up the pixel dimensions for the rendered image, we also need to set up a virtual <em>viewport</em> through which to pass our scene rays. The viewport is a virtual rectangle in the 3D world that contains the grid of image pixel locations. If pixels are spaced the same distance horizontally as they are vertically, the viewport that bounds them will have the same aspect ratio as the rendered image. The distance between two adjacent pixels is called the pixel spacing, and square pixels is the standard.</p>
<p>To start things off, we'll choose an arbitrary viewport height of 2.0, and scale the viewport width to give us the desired aspect ratio. Here's a snippet of what this code will look like:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use code::color::{Color, write_color};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    // Image
</span><span class="boring">
</span>    const ASPECT_RATIO: f64 = 16.0 / 9.0;
    const IMAGE_WIDTH: i32 = 400;

    // Calculate the image height, and ensure that it's at least 1.
    const IMAGE_HEIGHT: i32 = {
        let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
        if image_height &lt; 1 { 1 } else { image_height }
    };

    // Viewport widths less than one are ok since they are real valued.
    let viewport_height = 2.0;
    let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
<span class="boring">
</span><span class="boring">    // Render
</span><span class="boring">
</span><span class="boring">    env_logger::init();
</span><span class="boring">    println!("P3");
</span><span class="boring">    println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">    println!("255");
</span><span class="boring">
</span><span class="boring">    for j in 0..IMAGE_HEIGHT {
</span><span class="boring">        log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">        for i in 0..IMAGE_WIDTH {
</span><span class="boring">            let pixel_color = Color::new(
</span><span class="boring">                i as f64 / (IMAGE_WIDTH - 1) as f64,
</span><span class="boring">                j as f64 / (IMAGE_HEIGHT - 1) as f64,
</span><span class="boring">                0.0,
</span><span class="boring">            );
</span><span class="boring">            write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    log::info!("Done.");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 8:</strong> <em>Rendered image setup</em></p>
<br>
<p>If you're wondering why we don't just use <code>aspect_ratio</code> when computing <code>viewport_width</code>, it's because the value set to <code>aspect_ratio</code> is the ideal ratio, it may not be the <em>actual</em> ratio between <code>image_width</code> and <code>image_height</code>. If <code>image_height</code> was allowed to be real valued—rather than just an integer—then it would be fine to use <code>aspect_ratio</code>. But the <em>actual</em> ratio between <code>image_width</code> and <code>image_height</code> can vary based on two parts of the code. First, <code>image_height</code> is rounded down to the nearest integer, which can increase the ratio. Second, we don't allow <code>image_height</code> to be less than one, which can also change the actual aspect ratio.</p>
<p>Note that <code>aspect_ratio</code> is an ideal ratio, which we approximate as best as possible with the integer-based ratio of image width over image height. In order for our viewport proportions to exactly match our image proportions, we use the calculated image aspect ratio to determine our final viewport width.</p>
<p>Next we will define the camera center: a point in 3D space from which all scene rays will originate (this is also commonly referred to as the <em>eye point</em>). The vector from the camera center to the viewport center will be orthogonal to the viewport. We'll initially set the distance between the viewport and the camera center point to be one unit. This distance is often referred to as the <em>focal length</em>.</p>
<p>For simplicity we'll start with the camera center at \( (0,0,0) \). We'll also have the y-axis go up, the x-axis to the right, and the negative z-axis pointing in the viewing direction. (This is commonly referred to as <em>right-handed coordinates</em>.)</p>
<p><img src="chapters/rays_a_simple_camera_and_background/../../imgs/fig-1.03-cam-geom.jpg" alt="Camera geometry" /></p>
<p><strong>Figure 3:</strong> <em>Camera geometry</em></p>
<br>
<p>Now the inevitable tricky part. While our 3D space has the conventions above, this conflicts with our image coordinates, where we want to have the zeroth pixel in the top-left and work our way down to the last pixel at the bottom right. This means that our image coordinate Y-axis is inverted: Y increases going down the image.</p>
<p>As we scan our image, we will start at the upper left pixel (pixel \( 0,0 \)), scan left-to-right across each row, and then scan row-by-row, top-to-bottom. To help navigate the pixel grid, we'll use a vector from the left edge to the right edge (\( \mathbf{V_u} \)), and a vector from the upper edge to the lower edge (\( \mathbf{V_v} \)).</p>
<p>Our pixel grid will be inset from the viewport edges by half the pixel-to-pixel distance. This way, our viewport area is evenly divided into width × height identical regions. Here's what our viewport and pixel grid look like:</p>
<p><img src="chapters/rays_a_simple_camera_and_background/../../imgs/fig-1.04-pixel-grid.jpg" alt="Viewport and pixel grid" /></p>
<p><strong>Figure 4:</strong> <em>Viewport and pixel grid</em></p>
<br>
<p>In this figure, we have the viewport, the pixel grid for a 7×5 resolution image, the viewport upper left corner \( \mathbf{Q} \), the pixel \( \mathbf{P_{0,0}} \) location, the viewport vector \( \mathbf{V_u} \) (<code>viewport_u</code>), the viewport vector \( \mathbf{V_v} \) (<code>viewport_v</code>), and the pixel delta vectors \( \mathbf{\Delta u} \) and \( \mathbf{\Delta v} \).</p>
<p>Drawing from all of this, here's the code that implements the camera. We'll stub in a function <code>ray_color(const ray&amp; r)</code> that returns the color for a given scene ray — which we'll set to always return black for now.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index bb37ee6..8104ae8 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,30 +1,65 @@
</span><span class="boring">-use code::color::{Color, write_color};
</span>+use code::{
+    color::{Color, write_color},
+    ray::Ray,
+    vec3::{Point3, Vec3},
+};
+
+fn ray_color(r: Ray) -&gt; Color {
+    Color::new(0.0, 0.0, 0.0)
+}
 
 fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
     // Image
 
<span class="boring">-    const IMAGE_WIDTH: u32 = 256;
</span><span class="boring">-    const IMAGE_HEIGHT: u32 = 256;
</span>+    const ASPECT_RATIO: f64 = 16.0 / 9.0;
+    const IMAGE_WIDTH: i32 = 400;
+
+    // Calculate the image height, and ensure that it's at least 1.
+    const IMAGE_HEIGHT: i32 = {
+        let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
+        if image_height &lt; 1 { 1 } else { image_height }
+    };
+
+    // Camera
+
+    let focal_length = 1.0;
+    let viewport_height = 2.0;
+    let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
+    let camera_center = Point3::new(0.0, 0.0, 0.0);
+
+    // Calculate the vectors across the horizontal and down the vertical viewport edges.
+    let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
+    let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
+
+    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
+    let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
+    let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
+
+    // Calculate the location of the upper left pixel.
+    let viewport_upper_left =
+        camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
+    let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
 
     // Render
 
     env_logger::init();
     println!("P3");
     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
     println!("255");
 
     for j in 0..IMAGE_HEIGHT {
         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
         for i in 0..IMAGE_WIDTH {
<span class="boring">-            let pixel_color = Color::new(
</span><span class="boring">-                i as f64 / (IMAGE_WIDTH - 1) as f64,
</span><span class="boring">-                j as f64 / (IMAGE_HEIGHT - 1) as f64,
</span><span class="boring">-                0.0,
</span><span class="boring">-            );
</span>+            let pixel_center =
+                pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
+            let ray_direction = pixel_center - camera_center;
+            let r = Ray::new(camera_center, ray_direction);
+
+            let pixel_color = ray_color(r);
             write_color(std::io::stdout(), pixel_color)?;
         }
     }
     log::info!("Done.");
 
     Ok(())
 }</code></pre>
<p><strong>Listing 9:</strong> [<a href="https://github.com/goldnor/code/blob/8f5c9042f86a1a778ef557f05162e6512ef2a85f/src/main.rs">main.rs</a>] <em>Creating scene rays</em></p>
<br>
<p>Notice that in the code above, I didn't make <code>ray_direction</code> a unit vector, because I think not doing that makes for simpler and slightly faster code.</p>
<p>Now we'll fill in the <code>ray_color(ray)</code> function to implement a simple gradient. This function will linearly blend white and blue depending on the height of the \( y \) coordinate <em>after</em> scaling the ray direction to unit length (so \( -1.0 &lt; y &lt; 1.0 \)). Because we're looking at the 𝑦 height after normalizing the vector, you'll notice a horizontal gradient to the color in addition to the vertical gradient.</p>
<p>I'll use a standard graphics trick to linearly scale \( 0.0 \leq a \leq 1.0 \). When \( a = 1.0 \), I want blue. When \( a = 0.0 \), I want white. In between, I want a blend. This forms a “linear blend”, or “linear interpolation”. This is commonly referred to as a <em>lerp</em> between two values. A lerp is always of the form</p>
<p>\[ blendedValue = (1 − 𝑎) \cdot startValue + 𝑎 \cdot endValue, \]</p>
<p>with \( a \) going from zero to one.</p>
<p>Putting all this together, here's what we get:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 8104ae8..f31dc16 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,65 +1,67 @@
</span> use code::{
     color::{Color, write_color},
     ray::Ray,
<span class="boring">-    vec3::{Point3, Vec3},
</span>+    vec3::{Point3, Vec3, unit_vector},
 };
 
 fn ray_color(r: Ray) -&gt; Color {
<span class="boring">-    Color::new(0.0, 0.0, 0.0)
</span>+    let unit_direction = unit_vector(r.direction());
+    let a = 0.5 * (unit_direction.y() + 1.0);
+    (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
<span class="boring"> 
</span><span class="boring"> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     log::info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 10:</strong> [<a href="https://github.com/goldnor/code/blob/d38202d1d50207cb9ff4bd6721dd88167e06feb6/src/main.rs">main.rs</a>] <em>Rendering a blue-to-white gradient</em></p>
<br>
<p>In our case this produces:</p>
<img style="width: 100%" src="chapters/rays_a_simple_camera_and_background/../../imgs/img-1.02-blue-to-white.png" alt="A blue-to-white gradient depending on ray Y coordinate">
<p><strong>Image 2:</strong> <em>A blue-to-white gradient depending on ray Y coordinate</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-sphere"><a class="header" href="#adding-a-sphere">Adding a Sphere</a></h1>
<p>Let’s add a single object to our ray tracer. People often use spheres in ray tracers because calculating whether a ray hits a sphere is relatively simple.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ray-sphere-intersection"><a class="header" href="#ray-sphere-intersection">Ray-Sphere Intersection</a></h2>
<p>The equation for a sphere of radius \( r \) that is centered at the origin is an important mathematical equation:</p>
<p>\[ x^2 + y^2 + z^2 = r^2 \]</p>
<p>You can also think of this as saying that if a given point \( (x, y, z) \) is on the surface of the sphere, then \( x^2 + y^2 + z^2 = r^2 \). If a given point \( (x, y, z) \) is <em>inside</em> the sphere, then \( x^2 + y^2 + z^2 &lt; r^2 \), and if a given point \( (x, y, z) \) is <em>outside</em> the sphere, then \( x^2 + y^2 + z^2 &gt; r^2 \).</p>
<p>If we want to allow the sphere center to be at an arbitrary point \( (C_x, C_y, C_z) \), then the equation becomes a lot less nice:</p>
<p>\[ (C_x - x)^2 + (C_y - y)^2 + (C_z - z)^2 = r^2 \]</p>
<p>In graphics, you almost always want your formulas to be in terms of vectors so that all the \( x/y/z \) stuff can be simply represented using a <code>vec3</code> class. You might note that the vector from point \( \mathbf{P} = (x, y, z) \) to center \( \mathbf{C} = (C_x, C_y, C_z) \) is \( (\mathbf{C} - \mathbf{P}) \).</p>
<p>If we use the definition of the dot product:</p>
<p>\[ (\mathbf{C} - \mathbf{P}) \cdot (\mathbf{C} - \mathbf{P}) = (C_x - x)^2 + (C_y - y)^2 + (C_z - z)^2 \]
Then we can rewrite the equation of the sphere in vector form as:</p>
<p>\[ (\mathbf{C} - \mathbf{P}) \cdot (\mathbf{C} - \mathbf{P}) = r^2 \]</p>
<p>We can read this as “any point \( \mathbf{P} \)  that satisfies this equation is on the sphere”. We want to know if our ray \( \mathbf{P}(t) = \mathbf{Q} + t \mathbf{d} \) ever hits the sphere anywhere. If it does hit the sphere, there is some \( t \) for which \( \mathbf{P}(t) \) satisfies the sphere equation. So we are looking for any \( t \) where this is true:</p>
<p>\[ (\mathbf{C} - \mathbf{P}(t)) \cdot (\mathbf{C} - \mathbf{P}(t)) = r^2 \]</p>
<p>which can be found by replacing \( \mathbf{P}(t) \) with its expanded form:</p>
<p>\[ (\mathbf{C} - (\mathbf{Q} + t \mathbf{d})) \cdot (\mathbf{C} - (\mathbf{Q} + t \mathbf{d})) = r^2 \]</p>
<p>We have three vectors on the left dotted by three vectors on the right. If we solved for the full dot product we would get nine vectors. You can definitely go through and write everything out, but we don't need to work that hard. If you remember, we want to solve for \( t \), so we'll separate the terms based on whether there is a \( t \) or not:</p>
<p>\[ (-t \mathbf{d} + (\mathbf{C} - \mathbf{Q})) \cdot (-t \mathbf{d} + (\mathbf{C} - \mathbf{Q})) = r^2 \]</p>
<p>And now we follow the rules of vector algebra to distribute the dot product:</p>
<p>\[ t^2 \mathbf{d} \cdot \mathbf{d} - 2 t \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) + (\mathbf{C} - \mathbf{Q}) \cdot (\mathbf{C} - \mathbf{Q}) = r^2 \]</p>
<p>Move the square of the radius over to the left hand side:</p>
<p>\[ t^2 \mathbf{d} \cdot \mathbf{d} - 2 t \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) + (\mathbf{C} - \mathbf{Q}) \cdot (\mathbf{C} - \mathbf{Q}) - r^2 = 0 \]</p>
<p>It's hard to make out what exactly this equation is, but the vectors and \( r \) in that equation are all constant and known. Furthermore, the only vectors that we have are reduced to scalars by dot product. The only unknown is \( t \), and we have a \( t^2 \), which means that this equation is quadratic. You can solve for a quadratic equation \( ax^2 + bx + c = 0 \) by using the quadratic formula:</p>
<p>\[ \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} \]</p>
<p>So solving for \( t \) in the ray-sphere intersection equation gives us these values for \( a \), \( b \), and \( c \):</p>
<p>\[ a = \mathbf{d} \cdot \mathbf{d} \]
\[ b = -2 \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) \]
\[ c = (\mathbf{C} - \mathbf{Q}) \cdot (\mathbf{C} - \mathbf{Q}) - r^2 \]</p>
<p>Using all of the above you can solve for \( t \), but there is a square root part that can be either positive (meaning two real solutions), negative (meaning no real solutions), or zero (meaning one real solution). In graphics, the algebra almost always relates very directly to the geometry. What we have is:</p>
<p><img src="chapters/adding_a_sphere/../../imgs/fig-1.05-ray-sphere.jpg" alt="Ray-sphere intersection results" /></p>
<p><strong>Figure 5:</strong> <em>Ray-sphere intersection results</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-our-first-raytraced-image"><a class="header" href="#creating-our-first-raytraced-image">Creating Our First Raytraced Image</a></h2>
<p>If we take that math and hard-code it into our program, we can test our code by placing a small sphere at \( −1 \) on the z-axis and then coloring red any pixel that intersects it.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index f31dc16..e3d9091 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,67 +1,81 @@
</span> use code::{
     color::{Color, write_color},
     ray::Ray,
<span class="boring">-    vec3::{Point3, Vec3, unit_vector},
</span>+    vec3::{Point3, Vec3, dot, unit_vector},
 };
 
+fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; bool {
+    let oc = center - r.origin();
+    let a = dot(r.direction(), r.direction());
+    let b = -2.0 * dot(r.direction(), oc);
+    let c = dot(oc, oc) - radius * radius;
+    let discriminant = b * b - 4.0 * a * c;
+
+    discriminant &gt;= 0.0
+}
+
 fn ray_color(r: Ray) -&gt; Color {
+    if hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
+        return Color::new(1.0, 0.0, 0.0);
+    }
+
     let unit_direction = unit_vector(r.direction());
     let a = 0.5 * (unit_direction.y() + 1.0);
     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
<span class="boring"> 
</span><span class="boring"> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     log::info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 11:</strong> [<a href="https://github.com/goldnor/code/blob/2cf21871a39a309bce0edfb75464389bba9782f4/src/main.rs">main.rs</a>] <em>Rendering a red sphere</em></p>
<br>
<p>What we get is this:</p>
<img style="width: 100%" src="chapters/adding_a_sphere/../../imgs/img-1.03-red-sphere.png" alt="A simple red sphere">
<p><strong>Image 3:</strong> <em>A simple red sphere</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="shading-with-surface-normals"><a class="header" href="#shading-with-surface-normals">Shading with Surface Normals</a></h2>
<p>First, let’s get ourselves a surface normal so we can shade. This is a vector that is perpendicular to the surface at the point of intersection.</p>
<p>We have a key design decision to make for normal vectors in our code: whether normal vectors will have an arbitrary length, or will be normalized to unit length.</p>
<p>It is tempting to skip the expensive square root operation involved in normalizing the vector, in case it's not needed. In practice, however, there are three important observations. First, if a unit-length normal vector is <em>ever</em> required, then you might as well do it up front once, instead of over and over again “just in case” for every location where unit-length is required. Second, we <em>do</em> require unit-length normal vectors in several places. Third, if you require normal vectors to be unit length, then you can often efficiently generate that vector with an understanding of the specific geometry class, in its constructor, or in the <code>hit()</code> function. For example, sphere normals can be made unit length simply by dividing by the sphere radius, avoiding the square root entirely.</p>
<p>Given all of this, we will adopt the policy that all normal vectors will be of unit length.</p>
<p>For a sphere, the outward normal is in the direction of the hit point minus the center:</p>
<p><img src="chapters/surface_normals_and_multiple_objects/../../imgs/fig-1.06-sphere-normal.jpg" alt="Sphere surface-normal geometry" /></p>
<p><strong>Figure 6:</strong> <em>Sphere surface-normal geometry</em></p>
<br>
<p>On the earth, this means that the vector from the earth’s center to you points straight up. Let’s throw that into the code now, and shade it. We don’t have any lights or anything yet, so let’s just visualize the normals with a color map. A common trick used for visualizing normals (because it’s easy and somewhat intuitive to assume \( \mathbf{n} \) is a unit length vector — so each component is between \( −1 \) and \( 1 \)) is to map each component to the interval from \( 0 \) to \( 1 \), and then map \( (x, y, z) \) to \( (red, green, blue) \). For the normal, we need the hit point, not just whether we hit or not (which is all we're calculating at the moment). We only have one sphere in the scene, and it's directly in front of the camera, so we won't worry about negative values of \( t \) yet. We'll just assume the closest hit point (smallest \( t \)) is the one that we want. These changes in the code let us compute and visualize \( \mathbf{n} \):</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index e3d9091..405ca4b 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,81 +1,82 @@
</span> use code::{
     color::{Color, write_color},
     ray::Ray,
     vec3::{Point3, Vec3, dot, unit_vector},
 };
 
<span class="boring">-fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; bool {
</span>+fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; Option&lt;f64&gt; {
     let oc = center - r.origin();
     let a = dot(r.direction(), r.direction());
     let b = -2.0 * dot(r.direction(), oc);
     let c = dot(oc, oc) - radius * radius;
     let discriminant = b * b - 4.0 * a * c;
 
<span class="boring">-    discriminant &gt;= 0.0
</span>+    (discriminant &gt;= 0.0).then(|| (-b - f64::sqrt(discriminant)) / (2.0 * a))
 }
 
 fn ray_color(r: Ray) -&gt; Color {
<span class="boring">-    if hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
</span><span class="boring">-        return Color::new(1.0, 0.0, 0.0);
</span>+    if let Some(t) = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
+        let n = unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
+        return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
     }
 
     let unit_direction = unit_vector(r.direction());
     let a = 0.5 * (unit_direction.y() + 1.0);
     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
 
 fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
     // Image
 
     const ASPECT_RATIO: f64 = 16.0 / 9.0;
<span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     log::info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 12:</strong> [<a href="https://github.com/goldnor/code/blob/47441cbbe4cb464b6f29e82801d47aba101092f2/src/main.rs">main.rs</a>] <em>Rendering surface normals on a sphere</em></p>
<br>
<p>And that yields this picture:</p>
<img style="width: 100%" src="chapters/surface_normals_and_multiple_objects/../../imgs/img-1.04-normals-sphere.png" alt="A sphere colored according to its normal vectors">
<p><strong>Image 4:</strong> A sphere colored according to its normal vectors</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="simplifying-the-ray-sphere-intersection-code"><a class="header" href="#simplifying-the-ray-sphere-intersection-code">Simplifying the Ray-Sphere Intersection Code</a></h2>
<p>Let’s revisit the ray-sphere function:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use code::{
</span><span class="boring">    color::{Color, write_color},
</span><span class="boring">    ray::Ray,
</span><span class="boring">    vec3::{Point3, Vec3, dot, unit_vector},
</span><span class="boring">};
</span><span class="boring">
</span>fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; Option&lt;f64&gt; {
    let oc = center - r.origin();
    let a = dot(r.direction(), r.direction());
    let b = -2.0 * dot(r.direction(), oc);
    let c = dot(oc, oc) - radius * radius;
    let discriminant = b * b - 4.0 * a * c;

    (discriminant &gt;= 0.0).then(|| (-b - f64::sqrt(discriminant)) / (2.0 * a))
}
<span class="boring">
</span><span class="boring">fn ray_color(r: Ray) -&gt; Color {
</span><span class="boring">    if let Some(t) = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
</span><span class="boring">        let n = unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
</span><span class="boring">        return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let unit_direction = unit_vector(r.direction());
</span><span class="boring">    let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">    (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    // Image
</span><span class="boring">
</span><span class="boring">    const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">    const IMAGE_WIDTH: i32 = 400;
</span><span class="boring">
</span><span class="boring">    // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">    const IMAGE_HEIGHT: i32 = {
</span><span class="boring">        let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">        if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // Camera
</span><span class="boring">
</span><span class="boring">    let focal_length = 1.0;
</span><span class="boring">    let viewport_height = 2.0;
</span><span class="boring">    let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">    let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring">
</span><span class="boring">    // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">    let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">    let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring">
</span><span class="boring">    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">    let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">    let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring">
</span><span class="boring">    // Calculate the location of the upper left pixel.
</span><span class="boring">    let viewport_upper_left =
</span><span class="boring">        camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">    let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring">
</span><span class="boring">    // Render
</span><span class="boring">
</span><span class="boring">    env_logger::init();
</span><span class="boring">    println!("P3");
</span><span class="boring">    println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">    println!("255");
</span><span class="boring">
</span><span class="boring">    for j in 0..IMAGE_HEIGHT {
</span><span class="boring">        log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">        for i in 0..IMAGE_WIDTH {
</span><span class="boring">            let pixel_center =
</span><span class="boring">                pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">            let ray_direction = pixel_center - camera_center;
</span><span class="boring">            let r = Ray::new(camera_center, ray_direction);
</span><span class="boring">
</span><span class="boring">            let pixel_color = ray_color(r);
</span><span class="boring">            write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    log::info!("Done.");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 13:</strong> [<a href="https://github.com/goldnor/code/blob/47441cbbe4cb464b6f29e82801d47aba101092f2/src/main.rs">main.rs</a>] <em>Ray-sphere intersection code (before)</em></p>
<br>
<p>First, recall that a vector dotted with itself is equal to the squared length of that vector.</p>
<p>Second, notice how the equation for \( b \) has a factor of negative two in it. Consider what happens to the quadratic equation if \( b = 2h \):</p>
<p>\[ \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}\]
\[= \frac{-(-2h) \pm \sqrt{(-2h)^2 - 4ac}}{2a}\]
\[= \frac{2h \pm 2 \sqrt{h^2 - ac}}{2a}\]
\[= \frac{h \pm \sqrt{h^2 - ac}}{a}\]</p>
<p>This simplifies nicely, so we'll use it. So solving for \( h \):</p>
<p>\[b = -2 \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) \]
\[b = -2h \]
\[h = \frac{b}{-2} = \mathbf{d} \cdot (\mathbf{C} - \mathbf{Q}) \]</p>
<p>Using these observations, we can now simplify the sphere-intersection code to this:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 405ca4b..1f26e3d 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,82 +1,82 @@
</span><span class="boring"> use code::{
</span><span class="boring">     color::{Color, write_color},
</span><span class="boring">     ray::Ray,
</span><span class="boring">     vec3::{Point3, Vec3, dot, unit_vector},
</span><span class="boring"> };
</span><span class="boring"> 
</span> fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; Option&lt;f64&gt; {
     let oc = center - r.origin();
<span class="boring">-    let a = dot(r.direction(), r.direction());
</span><span class="boring">-    let b = -2.0 * dot(r.direction(), oc);
</span><span class="boring">-    let c = dot(oc, oc) - radius * radius;
</span><span class="boring">-    let discriminant = b * b - 4.0 * a * c;
</span>+    let a = r.direction().length_squared();
+    let h = dot(r.direction(), oc);
+    let c = oc.length_squared() - radius * radius;
+    let discriminant = h * h - a * c;
 
<span class="boring">-    (discriminant &gt;= 0.0).then(|| (-b - f64::sqrt(discriminant)) / (2.0 * a))
</span>+    (discriminant &gt;= 0.0).then(|| (h - f64::sqrt(discriminant)) / a)
 }
<span class="boring"> 
</span><span class="boring"> fn ray_color(r: Ray) -&gt; Color {
</span><span class="boring">     if let Some(t) = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
</span><span class="boring">         let n = unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
</span><span class="boring">         return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     let unit_direction = unit_vector(r.direction());
</span><span class="boring">     let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     log::info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 14:</strong> [<a href="https://github.com/goldnor/code/blob/f878b49faaf7958cf88bf4748416acf7cfd61408/src/main.rs">main.rs</a>] <em>Ray-sphere intersection code (after)</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="an-abstraction-for-hittable-objects"><a class="header" href="#an-abstraction-for-hittable-objects">An Abstraction for Hittable Objects</a></h2>
<p>Now, how about more than one sphere? While it is tempting to have an array of spheres, a very clean solution is to make an “abstract class” for anything a ray might hit, and make both a sphere and a list of spheres just something that can be hit. What that class should be called is something of a quandary — calling it an “object” would be good if not for “object oriented” programming. “Surface” is often used, with the weakness being maybe we will want volumes (fog, clouds, stuff like that). “hittable” emphasizes the member function that unites them. I don’t love any of these, but we'll go with “hittable”.</p>
<p>This <code>hittable</code> abstract class will have a <code>hit</code> function that takes in a ray. <sup class="footnote-reference" id="fr-63a-1"><a href="#footnote-63a">1</a></sup> Most ray tracers have found it convenient to add a valid interval for hits \( t_{min} \) to \( t_{max} \), so the hit only “counts” if \( t_{min} &lt; t &lt; t_{max} \). For the initial rays this is positive \( t \), but as we will see, it can simplify our code to have an interval \( t_{min} \) to \( t_{max} \). One design question is whether to do things like compute the normal if we hit something. We might end up hitting something closer as we do our search, and we will only need the normal of the closest thing. I will go with the simple solution and compute a bundle of stuff I will store in some structure. Here’s the abstract class:</p>
<pre><code class="language-rust norun noplayground">use crate::{
    ray::Ray,
    vec3::{Point3, Vec3},
};

#[derive(Debug, Default, Clone, Copy)]
pub struct HitRecord {
    pub p: Point3,
    pub normal: Vec3,
    pub t: f64,
}

pub trait Hittable {
    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
}</code></pre>
<p><strong>Listing 15:</strong> [<a href="https://github.com/goldnor/code/blob/1791ddbea0fdc81c13e4ef3daaaca7e440cec404/src/hittable.rs">hittable.rs</a>] <em>The hittable class</em></p>
<br>
<p>And here’s the sphere:</p>
<pre><code class="language-rust norun noplayground">use crate::{
    hittable::{HitRecord, Hittable},
    ray::Ray,
    vec3::{Point3, dot},
};

#[derive(Debug, Clone, Copy)]
pub struct Sphere {
    center: Point3,
    radius: f64,
}

impl Sphere {
    pub fn new(center: Point3, radius: f64) -&gt; Self {
        Self {
            center,
            radius: f64::max(0.0, radius),
        }
    }
}

impl Hittable for Sphere {
    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
        let oc = self.center - r.origin();
        let a = r.direction().length_squared();
        let h = dot(r.direction(), oc);
        let c = oc.length_squared() - self.radius * self.radius;

        let discriminant = h * h - a * c;
        if discriminant &lt; 0.0 {
            return None;
        }

        let sqrtd = f64::sqrt(discriminant);

        // Find the nearest root that lies in the acceptable range.
        let mut root = (h - sqrtd) / a;
        if root &lt;= ray_tmin || ray_tmax &lt;= root {
            root = (h + sqrtd) / a;
            if root &lt;= ray_tmin || ray_tmax &lt;= root {
                return None;
            }
        }

        let t = root;
        let p = r.at(t);
        let rec = HitRecord {
            t,
            p,
            normal: (p - self.center) / self.radius,
        };

        Some(rec)
    }
}</code></pre>
<p><strong>Listing 16:</strong> [<a href="https://github.com/goldnor/code/blob/36e5e545d452e57637150a4e1a8ba2ff93aee52b/src/sphere.rs">sphere.rs</a>] <em>The sphere class</em></p>
<br>
<p>(Note here that we use the C++ standard function <code>std::fmax()</code>, which returns the maximum of the two floating-point arguments. Similarly, we will later use <code>std::fmin()</code>, which returns the minimum of the two floating-point arguments.) <sup class="footnote-reference" id="fr-63b-1"><a href="#footnote-63b">2</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-63a">
<p>A simple Rust Trait will be used instead. <a href="#fr-63a-1">↩</a></p>
</li>
<li id="footnote-63b">
<p>The Rust standard library provides the functions <code>f64::max()</code> and <code>f64::min()</code>. <a href="#fr-63b-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="front-faces-versus-back-faces"><a class="header" href="#front-faces-versus-back-faces">Front Faces Versus Back Faces</a></h2>
<p>The second design decision for normals is whether they should always point out. At present, the normal found will always be in the direction of the center to the intersection point (the normal points out). If the ray intersects the sphere from the outside, the normal points against the ray. If the ray intersects the sphere from the inside, the normal (which always points out) points with the ray. Alternatively, we can have the normal always point against the ray. If the ray is outside the sphere, the normal will point outward, but if the ray is inside the sphere, the normal will point inward.</p>
<p><img src="chapters/surface_normals_and_multiple_objects/../../imgs/fig-1.07-normal-sides.jpg" alt="Possible directions for sphere surface-normal geometry" /></p>
<p><strong>Figure 7:</strong> <em>Possible directions for sphere surface-normal geometry</em></p>
<br>
<p>We need to choose one of these possibilities because we will eventually want to determine which side of the surface that the ray is coming from. This is important for objects that are rendered differently on each side, like the text on a two-sided sheet of paper, or for objects that have an inside and an outside, like glass balls.</p>
<p>If we decide to have the normals always point out, then we will need to determine which side the ray is on when we color it. We can figure this out by comparing the ray with the normal. If the ray and the normal face in the same direction, the ray is inside the object, if the ray and the normal face in the opposite direction, then the ray is outside the object. This can be determined by taking the dot product of the two vectors, where if their dot is positive, the ray is inside the sphere.</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{
</span><span class="boring">    ray::Ray,
</span><span class="boring">    vec3::{Point3, Vec3, dot},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct HitRecord {
</span><span class="boring">    pub p: Point3,
</span><span class="boring">    pub normal: Vec3,
</span><span class="boring">    pub t: f64,
</span><span class="boring">    pub front_face: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl HitRecord {
</span><span class="boring">    pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">        // Sets the hit record normal vector.
</span><span class="boring">        // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring">
</span><span class="boring">        let normal;
</span><span class="boring">        let front_face;
</span>        if dot(r.direction(), outward_normal) &gt; 0.0 {
            // ray is inside the sphere
<span class="boring">            normal = -outward_normal;
</span><span class="boring">            front_face = false;
</span>        } else {
            // ray is outside the sphere
<span class="boring">            normal = outward_normal;
</span><span class="boring">            front_face = true;
</span>        }
<span class="boring">
</span><span class="boring">        self.front_face = front_face;
</span><span class="boring">        self.normal = normal;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub trait Hittable {
</span><span class="boring">    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 17:</strong> <em>Comparing the ray and the normal</em></p>
<br>
<p>If we decide to have the normals always point against the ray, we won't be able to use the dot product to determine which side of the surface the ray is on. Instead, we would need to store that information:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{
</span><span class="boring">    ray::Ray,
</span><span class="boring">    vec3::{Point3, Vec3, dot},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Clone, Copy)]
</span><span class="boring">pub struct HitRecord {
</span><span class="boring">    pub p: Point3,
</span><span class="boring">    pub normal: Vec3,
</span><span class="boring">    pub t: f64,
</span><span class="boring">    pub front_face: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl HitRecord {
</span><span class="boring">    pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">        // Sets the hit record normal vector.
</span><span class="boring">        // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring">
</span><span class="boring">        let normal;
</span>        let front_face;
        if dot(r.direction(), outward_normal) &gt; 0.0 {
            // ray is inside the sphere
            normal = -outward_normal;
            front_face = false;
        } else {
            // ray is outside the sphere
            normal = outward_normal;
            front_face = true;
        }
<span class="boring">
</span><span class="boring">        self.front_face = front_face;
</span><span class="boring">        self.normal = normal;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub trait Hittable {
</span><span class="boring">    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring">}</span></code></pre>
<p><strong>Listing 18:</strong> <em>Remembering the side of the surface</em></p>
<br>
<p>We can set things up so that normals always point “outward” from the surface, or always point against the incident ray. This decision is determined by whether you want to determine the side of the surface at the time of geometry intersection or at the time of coloring. In this book we have more material types than we have geometry types, so we'll go for less work and put the determination at geometry time. This is simply a matter of preference, and you'll see both implementations in the literature.</p>
<p>We add the <code>front_face</code> bool to the <code>hit_record</code> class. We'll also add a function to solve this calculation for us: <code>set_face_normal()</code>. For convenience we will assume that the vector passed to the new <code>set_face_normal()</code> function is of unit length. We could always normalize the parameter explicitly, but it's more efficient if the geometry code does this, as it's usually easier when you know more about the specific geometry.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable.rs b/src/hittable.rs
</span><span class="boring">index b8a3fcf..8ced826 100644
</span><span class="boring">--- a/src/hittable.rs
</span><span class="boring">+++ b/src/hittable.rs
</span><span class="boring">@@ -1,15 +1,30 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     ray::Ray,
</span><span class="boring">-    vec3::{Point3, Vec3},
</span><span class="boring">+    vec3::{Point3, Vec3, dot},
</span><span class="boring"> };
</span><span class="boring"> 
</span> #[derive(Debug, Default, Clone, Copy)]
 pub struct HitRecord {
     pub p: Point3,
     pub normal: Vec3,
     pub t: f64,
+    pub front_face: bool,
+}
+
+impl HitRecord {
+    pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
+        // Sets the hit record normal vector.
+        // NOTE: the parameter `outward_normal` is assumed to have unit length.
+
+        self.front_face = dot(r.direction(), outward_normal) &lt; 0.0;
+        self.normal = if self.front_face {
+            outward_normal
+        } else {
+            -outward_normal
+        };
+    }
 }
<span class="boring"> 
</span><span class="boring"> pub trait Hittable {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 19:</strong> [<a href="https://github.com/goldnor/code/blob/a1c2d4fad73108c42bb6612c0bdb02d2a9c6a7ed/src/hittable.rs">hittable.rs</a>] <em>Adding front-face tracking to hit_record</em></p>
<br>
<p>And then we add the surface side determination to the class:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index aa651e9..86d3cbb 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,56 +1,57 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     hittable::{HitRecord, Hittable},
</span><span class="boring">     ray::Ray,
</span><span class="boring">     vec3::{Point3, dot},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Clone, Copy)]
</span><span class="boring"> pub struct Sphere {
</span><span class="boring">     center: Point3,
</span><span class="boring">     radius: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sphere {
</span><span class="boring">     pub fn new(center: Point3, radius: f64) -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             center,
</span><span class="boring">             radius: f64::max(0.0, radius),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Hittable for Sphere {
     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
<span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span><span class="boring"> 
</span><span class="boring">         // Find the nearest root that lies in the acceptable range.
</span><span class="boring">         let mut root = (h - sqrtd) / a;
</span><span class="boring">         if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span><span class="boring">             root = (h + sqrtd) / a;
</span><span class="boring">             if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span><span class="boring">                 return None;
</span><span class="boring">             }
</span><span class="boring">         }
</span> 
         let t = root;
         let p = r.at(t);
<span class="boring">-        let rec = HitRecord {
</span>+        let mut rec = HitRecord {
             t,
             p,
<span class="boring">-            normal: (p - self.center) / self.radius,
</span>             ..Default::default()
         };
+        let outward_normal = (p - self.center) / self.radius;
+        rec.set_face_normal(r, outward_normal);
 
         Some(rec)
     }
 }</code></pre>
<p><strong>Listing 20:</strong> [<a href="https://github.com/goldnor/code/blob/e54430867656af9ca129dfd3350fe4f0ead18d19/src/sphere.rs">sphere.rs</a>] <em>The sphere class with normal determination</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-list-of-hittable-objects"><a class="header" href="#a-list-of-hittable-objects">A List of Hittable Objects</a></h2>
<p>We have a generic object called a <code>hittable</code> that the ray can intersect with. We now add a class that stores a list of <code>hittables</code>:</p>
<pre><code class="language-rust norun noplayground">use std::rc::Rc;

use crate::{
    hittable::{HitRecord, Hittable},
    ray::Ray,
};

#[derive(Default)]
pub struct HittableList {
    pub objects: Vec&lt;Rc&lt;dyn Hittable&gt;&gt;,
}

impl HittableList {
    pub fn new() -&gt; Self {
        Self::default()
    }

    pub fn clear(&amp;mut self) {
        self.objects.clear();
    }

    pub fn add(&amp;mut self, object: Rc&lt;dyn Hittable&gt;) {
        self.objects.push(object);
    }
}

impl Hittable for HittableList {
    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
        self.objects
            .iter()
            .filter_map(|obj| obj.hit(r, ray_tmin, ray_tmax))
            .min_by(|a, b| a.t.partial_cmp(&amp;b.t).expect("no NaN value"))
    }
}</code></pre>
<p><strong>Listing 21:</strong> [<a href="https://github.com/goldnor/code/blob/86c110ccad16979ec62dce945725abab72499799/src/hittable_list.rs">hittable_list.rs</a>] <em>The hittable_list class</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="some-new-c-features-1"><a class="header" href="#some-new-c-features-1">Some New C++ Features <sup class="footnote-reference" id="fr-66a-1"><a href="#footnote-66a">1</a></sup></a></h2>
<p>The <code>hittable_list</code> class code uses some C++ features that may trip you up if you're not normally a C++ programmer: <code>vector</code>, <code>shared_ptr</code>, and <code>make_shared</code>. <sup class="footnote-reference" id="fr-66b-1"><a href="#footnote-66b">2</a></sup></p>
 <!-- It is possible to use `Arc` instead for `Rc` if using multithreading and insert a `Cell` type to allow for interior mutability, but since the scene is setup once and does not change over the course of the program lifetime a simple `Rc` is sufficient. -->
<p><code>shared_ptr&lt;type&gt;</code> is a pointer to some allocated type, with reference-counting semantics. Every time you assign its value to another shared pointer (usually with a simple assignment), the reference count is incremented. As shared pointers go out of scope (like at the end of a block or function), the reference count is decremented. Once the count goes to zero, the object is safely deleted. <sup class="footnote-reference" id="fr-66c-1"><a href="#footnote-66c">3</a></sup></p>
<p>Typically, a shared pointer is first initialized with a newly-allocated object, something like this:</p>
<pre><pre class="playground"><code class="language-rust norun nodiff"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let double_ptr: Rc&lt;double&gt; = Rc::new(0.37);
let vec3_ptr: Rc&lt;Vec3&gt; = Rc::new(Vec3::new(1.414214, 2.718281, 1.618034));
let sphere_ptr: Rc&lt;Sphere&gt; = Rc::new(Sphere::new(Point3::new(0.0, 0.0, 0.0), 1.0));
<span class="boring">}</span></code></pre></pre>
<p><strong>Listing 22:</strong> <em>An example allocation using shared_ptr</em></p>
<br>
<p><code>make_shared&lt;thing&gt;(thing_constructor_params ...)</code> allocates a new instance of type thing, using the constructor parameters. It returns a <code>shared_ptr&lt;thing&gt;</code>. <sup class="footnote-reference" id="fr-66d-1"><a href="#footnote-66d">4</a></sup></p>
<p>Since the type can be automatically deduced by the return type of <code>make_shared&lt;type&gt;(...)</code>, the above lines can be more simply expressed using C++'s <code>auto</code> type specifier: <sup class="footnote-reference" id="fr-66e-1"><a href="#footnote-66e">5</a></sup></p>
<pre><pre class="playground"><code class="language-rust norun nodiff"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let double_ptr = Rc::new(0.37);
let vec3_ptr = Rc::new(Vec3::new(1.414214, 2.718281, 1.618034));
let sphere_ptr = Rc::new(Sphere::new(Point3::new(0.0, 0.0, 0.0), 1.0));
<span class="boring">}</span></code></pre></pre>
<p><strong>Listing 23:</strong>  <em>An example allocation using shared_ptr with auto type</em></p>
<br>
<p>We'll use shared pointers in our code, because it allows multiple geometries to share a common instance (for example, a bunch of spheres that all use the same color material), and because it makes memory management automatic and easier to reason about.</p>
<p><code>std::shared_ptr</code> is included with the <code>&lt;memory&gt;</code> header.<sup class="footnote-reference" id="fr-66f-1"><a href="#footnote-66f">6</a></sup></p>
<p>The second C++ feature you may be unfamiliar with is <code>std::vector</code>. This is a generic array-like collection of an arbitrary type. Above, we use a collection of pointers to <code>hittable</code>. <code>std::vector</code> automatically grows as more values are added: <code>objects.push_back(object)</code> adds a value to the end of the <code>std::vector</code> member variable <code>objects</code>.</p>
<p><code>std::vector</code> is included with the ``<vector>` header. <sup class="footnote-reference" id="fr-66g-1"><a href="#footnote-66g">7</a></sup></p>
<p>Finally, the <code>using</code> statements in <a href="chapters/surface_normals_and_multiple_objects/a_list_of_hittable_objects.html">listing 21</a> tell the compiler that we'll be getting <code>shared_ptr</code> and <code>make_shared</code> from the <code>std</code> library, so we don't need to prefix these with <code>std::</code> every time we reference them.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-66a">
<p>This chapter can be safely skipped when the code of last chapter is clear. <a href="#fr-66a-1">↩</a></p>
</li>
<li id="footnote-66b">
<p>The Rust equivalents are <code>Vec</code>, <code>Rc</code> and a simple <code>new</code> method of the reference counting smart pointer. <a href="#fr-66b-1">↩</a></p>
</li>
<li id="footnote-66c">
<p>Here we use <code>Rc</code>. In contrast to the C++ <code>shared_ptr</code>, the contained value of an <code>Rc</code> is inmutable. Enclosing the value with a cell based type like for example <code>RefCell</code> would allow for interior mutability. However in this case, all objects are created on startup and do not change over the course of the program lifetime which is why a simple <code>Rc</code> is sufficient. <a href="#fr-66c-1">↩</a></p>
</li>
<li id="footnote-66d">
<p>Rust has no constructors, instead it is convention to fill structs with the <code>new</code> method, the implementation of traits like <code>Default</code>, <code>From</code> or similar, or to use any method that returns <code>Self</code>. So technically something like <code>make_shared</code> does not exist in Rust. <a href="#fr-66d-1">↩</a></p>
</li>
<li id="footnote-66e">
<p>The type annotations in the last listing were not nessecary, Rust's <code>let</code> declarations can in this case infere the types. <a href="#fr-66e-1">↩</a></p>
</li>
<li id="footnote-66f">
<p><code>Rc</code> is found in <code>std::rc::Rc</code>. <a href="#fr-66f-1">↩</a></p>
</li>
<li id="footnote-66g">
<p><code>Vec</code> is included in Rust's std prelude and does have to be included to be used. <a href="#fr-66g-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="common-constants-and-utility-functions"><a class="header" href="#common-constants-and-utility-functions">Common Constants and Utility Functions</a></h2>
<p>We need some math constants that we conveniently define in their own header file. For now we only need infinity, but we will also throw our own definition of pi in there, which we will need later. We'll also throw common useful constants and future utility functions in here. This new header, <code>rtweekend.h</code>, will be our general main header file. <sup class="footnote-reference" id="fr-67a-1"><a href="#footnote-67a">1</a></sup></p>
<pre><code class="language-rust norun noplayground">pub use log::*;

// Rust Std usings

pub use std::rc::Rc;

// Constants

pub const INFINITY: f64 = f64::INFINITY;
pub const PI: f64 = std::f64::consts::PI;

// Common Headers

pub use crate::{color::*, ray::*, vec3::*};</code></pre>
<p><strong>Listing 24:</strong> [<a href="https://github.com/goldnor/code/blob/9e1b0c216e67d1bcf41de6ee6c449758c9cc33e5/src/prelude.rs">prelude.rs</a>] <em>The rtweekend.h common header</em></p>
<br>
<p>Program files will include <code>rtweekend.h</code> first, so all other header files (where the bulk of our code will reside) can implicitly assume that <code>rtweekend.h</code> has already been included. Header files still need to explicitly include any other necessary header files. We'll make some updates with these assumptions in mind.</p>
<pre><code class="language-rust norun noplayground">// nothing changes</code></pre>
<p><strong>Listing 25:</strong> [<a href="https://github.com/goldnor/code/blob/9e1b0c216e67d1bcf41de6ee6c449758c9cc33e5/src/color.rs">color.rs</a>] <em>Assume rtweekend.h inclusion for color.h</em> <sup class="footnote-reference" id="fr-67b-1"><a href="#footnote-67b">2</a></sup></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable.rs b/src/hittable.rs
</span><span class="boring">index 8ced826..a7aab5a 100644
</span><span class="boring">--- a/src/hittable.rs
</span><span class="boring">+++ b/src/hittable.rs
</span><span class="boring">@@ -1,30 +1,27 @@
</span>-use crate::{
-    ray::Ray,
-    vec3::{Point3, Vec3, dot},
-};
+use crate::prelude::*;
<span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct HitRecord {
</span><span class="boring">     pub p: Point3,
</span><span class="boring">     pub normal: Vec3,
</span><span class="boring">     pub t: f64,
</span><span class="boring">     pub front_face: bool,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl HitRecord {
</span><span class="boring">     pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">         // Sets the hit record normal vector.
</span><span class="boring">         // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring"> 
</span><span class="boring">         self.front_face = dot(r.direction(), outward_normal) &lt; 0.0;
</span><span class="boring">         self.normal = if self.front_face {
</span><span class="boring">             outward_normal
</span><span class="boring">         } else {
</span><span class="boring">             -outward_normal
</span><span class="boring">         };
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub trait Hittable {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 26:</strong> [<a href="https://github.com/goldnor/code/blob/a83dfcb94c1741454b03fe57b8dc56e97a47c0cc/src/hittable.rs">hittable.rs</a>] <em>Assume rtweekend.h inclusion for hittable.h</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable_list.rs b/src/hittable_list.rs
</span><span class="boring">index 95c24e4..7841161 100644
</span><span class="boring">--- a/src/hittable_list.rs
</span><span class="boring">+++ b/src/hittable_list.rs
</span><span class="boring">@@ -1,34 +1,32 @@
</span>-use std::rc::Rc;
-
 use crate::{
     hittable::{HitRecord, Hittable},
-    ray::Ray,
+    prelude::*,
 };
<span class="boring"> 
</span><span class="boring"> #[derive(Default)]
</span><span class="boring"> pub struct HittableList {
</span><span class="boring">     pub objects: Vec&lt;Rc&lt;dyn Hittable&gt;&gt;,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl HittableList {
</span><span class="boring">     pub fn new() -&gt; Self {
</span><span class="boring">         Self::default()
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn clear(&amp;mut self) {
</span><span class="boring">         self.objects.clear();
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn add(&amp;mut self, object: Rc&lt;dyn Hittable&gt;) {
</span><span class="boring">         self.objects.push(object);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Hittable for HittableList {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
</span><span class="boring">         self.objects
</span><span class="boring">             .iter()
</span><span class="boring">             .filter_map(|obj| obj.hit(r, ray_tmin, ray_tmax))
</span><span class="boring">             .min_by(|a, b| a.t.partial_cmp(&amp;b.t).expect("no NaN value"))
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 27:</strong> [<a href="https://github.com/goldnor/code/blob/fd505c6bc51cd1887e71b1ce44fe0ee32a1fb198/src/hittable_list.rs">hittable_list.rs</a>] <em>Assume rtweekend.h inclusion for hittable_list.h</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index 86d3cbb..9de9f72 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,57 +1,56 @@
</span> use crate::{
     hittable::{HitRecord, Hittable},
-    ray::Ray,
-    vec3::{Point3, dot},
+    prelude::*,
 };
<span class="boring"> 
</span><span class="boring"> #[derive(Debug, Clone, Copy)]
</span><span class="boring"> pub struct Sphere {
</span><span class="boring">     center: Point3,
</span><span class="boring">     radius: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sphere {
</span><span class="boring">     pub fn new(center: Point3, radius: f64) -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             center,
</span><span class="boring">             radius: f64::max(0.0, radius),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Hittable for Sphere {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
</span><span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span><span class="boring"> 
</span><span class="boring">         // Find the nearest root that lies in the acceptable range.
</span><span class="boring">         let mut root = (h - sqrtd) / a;
</span><span class="boring">         if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span><span class="boring">             root = (h + sqrtd) / a;
</span><span class="boring">             if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span><span class="boring">                 return None;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let t = root;
</span><span class="boring">         let p = r.at(t);
</span><span class="boring">         let mut rec = HitRecord {
</span><span class="boring">             t,
</span><span class="boring">             p,
</span><span class="boring">             ..Default::default()
</span><span class="boring">         };
</span><span class="boring">         let outward_normal = (p - self.center) / self.radius;
</span><span class="boring">         rec.set_face_normal(r, outward_normal);
</span><span class="boring"> 
</span><span class="boring">         Some(rec)
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 28:</strong> [<a href="https://github.com/goldnor/code/blob/d57e0ab6d5de95b5d3105a150a69c552e4eeb167/src/sphere.rs">sphere.rs</a>] <em>Assume rtweekend.h inclusion for sphere.h</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground">// nothing changes</code></pre>
<p><strong>Listing 29:</strong> [<a href="https://github.com/goldnor/code/blob/d57e0ab6d5de95b5d3105a150a69c552e4eeb167/src/vec3.rs">vec3.rs</a>] <em>Assume rtweekend.h inclusion for vec3.h</em></p>
<br>
<p>And now the new main:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 1f26e3d..59c000b 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,82 +1,74 @@
</span>-use code::{
-    color::{Color, write_color},
-    ray::Ray,
-    vec3::{Point3, Vec3, dot, unit_vector},
-};
-
-fn hit_sphere(center: Point3, radius: f64, r: Ray) -&gt; Option&lt;f64&gt; {
<span class="boring">-    let oc = center - r.origin();
</span><span class="boring">-    let a = r.direction().length_squared();
</span><span class="boring">-    let h = dot(r.direction(), oc);
</span><span class="boring">-    let c = oc.length_squared() - radius * radius;
</span><span class="boring">-    let discriminant = h * h - a * c;
</span>-
<span class="boring">-    (discriminant &gt;= 0.0).then(|| (h - f64::sqrt(discriminant)) / a)
</span>-}
+use code::{hittable::Hittable, hittable_list::HittableList, prelude::*, sphere::Sphere};
 
<span class="boring">-fn ray_color(r: Ray) -&gt; Color {
</span><span class="boring">-    if let Some(t) = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r) {
</span><span class="boring">-        let n = unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
</span><span class="boring">-        return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
</span>+fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
+    if let Some(rec) = world.hit(r, 0.0, INFINITY) {
+        return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
     }
 
     let unit_direction = unit_vector(r.direction());
     let a = 0.5 * (unit_direction.y() + 1.0);
     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
 
 fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
     // Image
 
     const ASPECT_RATIO: f64 = 16.0 / 9.0;
     const IMAGE_WIDTH: i32 = 400;
 
     // Calculate the image height, and ensure that it's at least 1.
     const IMAGE_HEIGHT: i32 = {
         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
         if image_height &lt; 1 { 1 } else { image_height }
     };
 
+    // World
+
+    let mut world = HittableList::new();
+
+    world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
+    world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
+
     // Camera
 
     let focal_length = 1.0;
     let viewport_height = 2.0;
     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
     let camera_center = Point3::new(0.0, 0.0, 0.0);
 
     // Calculate the vectors across the horizontal and down the vertical viewport edges.
     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
 
     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
 
     // Calculate the location of the upper left pixel.
     let viewport_upper_left =
         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
 
     // Render
 
     env_logger::init();
     println!("P3");
     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
     println!("255");
 
     for j in 0..IMAGE_HEIGHT {
<span class="boring">-        log::info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span>+        info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
         for i in 0..IMAGE_WIDTH {
             let pixel_center =
                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
             let ray_direction = pixel_center - camera_center;
             let r = Ray::new(camera_center, ray_direction);
 
<span class="boring">-            let pixel_color = ray_color(r);
</span>+            let pixel_color = ray_color(r, &amp;world);
             write_color(std::io::stdout(), pixel_color)?;
         }
     }
<span class="boring">-    log::info!("Done.");
</span>+    info!("Done.");
 
     Ok(())
 }</code></pre>
<p><strong>Listing 30:</strong> [<a href="https://github.com/goldnor/code/blob/e19dd26432882f6c779f25632318690a3be5a4ac/src/main.rs">main.rs</a>] <em>The new main with hittables</em></p>
<br>
<p>This yields a picture that is really just a visualization of where the spheres are located along with their surface normal. This is often a great way to view any flaws or specific characteristics of a geometric model.</p>
<img style="width: 100%" src="chapters/surface_normals_and_multiple_objects/../../imgs/img-1.05-normals-sphere-ground.png" alt=" Resulting render of normals-colored sphere with ground">
<p><strong>Image 5:</strong> <em>Resulting render of normals-colored sphere with ground</em></p>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-67a">
<p>In Rust it is common to create a prelude for common types, which we will do here instead. Note however, that there are at the momentan no <a href="https://github.com/rust-lang/rfcs/pull/890">plan to include a custom prelude as a language feature</a>, instead we need to import the prelude with <code>use crate::prelude::*</code>. <a href="#fr-67a-1">↩</a></p>
</li>
<li id="footnote-67b">
<p>There is no need to use the prelude in <code>color.rs</code> only for the <code>Vec3</code> struct. The listing is still included to match the numbering of the original book series. <a href="#fr-67b-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="an-interval-class"><a class="header" href="#an-interval-class">An Interval Class</a></h2>
<p>Before we continue, we'll implement an interval class to manage real-valued intervals with a minimum and a maximum. We'll end up using this class quite often as we proceed.</p>
<pre><code class="language-rust norun noplayground">#[derive(Debug, Clone, Copy)]
pub struct Interval {
    pub min: f64,
    pub max: f64,
}

impl Default for Interval {
    fn default() -&gt; Self {
        Self::EMPTY
    }
}

impl Interval {
    pub const EMPTY: Self = Self {
        min: f64::INFINITY,
        max: f64::NEG_INFINITY,
    };

    pub const UNIVERSE: Self = Self {
        min: f64::NEG_INFINITY,
        max: f64::INFINITY,
    };

    pub fn new(min: f64, max: f64) -&gt; Self {
        Self { min, max }
    }

    pub fn size(&amp;self) -&gt; f64 {
        self.max - self.min
    }

    pub fn contains(&amp;self, x: f64) -&gt; bool {
        self.min &lt;= x &amp;&amp; x &lt;= self.max
    }

    pub fn surrounds(&amp;self, x: f64) -&gt; bool {
        self.min &lt; x &amp;&amp; x &lt; self.max
    }
}</code></pre>
<p><strong>Listing 31:</strong> [<a href="https://github.com/goldnor/code/blob/b97cce927b5c04bc925b77462cef0a4ce6152d4a/src/interval.rs">interval.rs</a>] <em>Introducing the new interval class</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/prelude.rs b/src/prelude.rs
</span><span class="boring">index fcd4621..2ec9487 100644
</span><span class="boring">--- a/src/prelude.rs
</span><span class="boring">+++ b/src/prelude.rs
</span><span class="boring">@@ -1,14 +1,14 @@
</span><span class="boring"> pub use log::*;
</span><span class="boring"> 
</span><span class="boring"> // Rust Std usings
</span><span class="boring"> 
</span><span class="boring"> pub use std::rc::Rc;
</span><span class="boring"> 
</span><span class="boring"> // Constants
</span><span class="boring"> 
</span><span class="boring"> pub const INFINITY: f64 = f64::INFINITY;
</span><span class="boring"> pub const PI: f64 = std::f64::consts::PI;
</span><span class="boring"> 
</span> // Common Headers
 
<span class="boring">-pub use crate::{color::*, ray::*, vec3::*};
</span>+pub use crate::{color::*, interval::Interval, ray::*, vec3::*};</code></pre>
<p><strong>Listing 32:</strong> [<a href="https://github.com/goldnor/code/blob/7fc2aa1432889497ecb73854719905b0ed276a68/src/prelude.rs">prelude.rs</a>] <em>Including the new interval class</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable.rs b/src/hittable.rs
</span><span class="boring">index a7aab5a..1b65b92 100644
</span><span class="boring">--- a/src/hittable.rs
</span><span class="boring">+++ b/src/hittable.rs
</span><span class="boring">@@ -1,27 +1,27 @@
</span><span class="boring"> use crate::prelude::*;
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct HitRecord {
</span><span class="boring">     pub p: Point3,
</span><span class="boring">     pub normal: Vec3,
</span><span class="boring">     pub t: f64,
</span><span class="boring">     pub front_face: bool,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl HitRecord {
</span><span class="boring">     pub fn set_face_normal(&amp;mut self, r: Ray, outward_normal: Vec3) {
</span><span class="boring">         // Sets the hit record normal vector.
</span><span class="boring">         // NOTE: the parameter `outward_normal` is assumed to have unit length.
</span><span class="boring"> 
</span><span class="boring">         self.front_face = dot(r.direction(), outward_normal) &lt; 0.0;
</span><span class="boring">         self.normal = if self.front_face {
</span><span class="boring">             outward_normal
</span><span class="boring">         } else {
</span><span class="boring">             -outward_normal
</span><span class="boring">         };
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> pub trait Hittable {
<span class="boring">-    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt;;
</span>+    fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt;;
 }</code></pre>
<p><strong>Listing 33:</strong> [<a href="https://github.com/goldnor/code/blob/d75c2cf12d1747e49e2568b2d4718ea5efea86e5/src/hittable.rs">hittable.rs</a>] <em>hittable::hit() using interval</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/hittable_list.rs b/src/hittable_list.rs
</span><span class="boring">index 7841161..4647aa5 100644
</span><span class="boring">--- a/src/hittable_list.rs
</span><span class="boring">+++ b/src/hittable_list.rs
</span><span class="boring">@@ -1,32 +1,32 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     hittable::{HitRecord, Hittable},
</span><span class="boring">     prelude::*,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Default)]
</span><span class="boring"> pub struct HittableList {
</span><span class="boring">     pub objects: Vec&lt;Rc&lt;dyn Hittable&gt;&gt;,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl HittableList {
</span><span class="boring">     pub fn new() -&gt; Self {
</span><span class="boring">         Self::default()
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn clear(&amp;mut self) {
</span><span class="boring">         self.objects.clear();
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn add(&amp;mut self, object: Rc&lt;dyn Hittable&gt;) {
</span><span class="boring">         self.objects.push(object);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Hittable for HittableList {
<span class="boring">-    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
</span>+    fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt; {
         self.objects
             .iter()
<span class="boring">-            .filter_map(|obj| obj.hit(r, ray_tmin, ray_tmax))
</span>+            .filter_map(|obj| obj.hit(r, ray_t))
             .min_by(|a, b| a.t.partial_cmp(&amp;b.t).expect("no NaN value"))
     }
 }</code></pre>
<p><strong>Listing 34:</strong> [<a href="https://github.com/goldnor/code/blob/d75c2cf12d1747e49e2568b2d4718ea5efea86e5/src/hittable_list.rs">hittable_list.rs</a>] <em>hittable_list::hit() using interval</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index 9de9f72..a2710b4 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,56 +1,56 @@
</span><span class="boring"> use crate::{
</span><span class="boring">     hittable::{HitRecord, Hittable},
</span><span class="boring">     prelude::*,
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Clone, Copy)]
</span><span class="boring"> pub struct Sphere {
</span><span class="boring">     center: Point3,
</span><span class="boring">     radius: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sphere {
</span><span class="boring">     pub fn new(center: Point3, radius: f64) -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             center,
</span><span class="boring">             radius: f64::max(0.0, radius),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Hittable for Sphere {
<span class="boring">-    fn hit(&amp;self, r: Ray, ray_tmin: f64, ray_tmax: f64) -&gt; Option&lt;HitRecord&gt; {
</span>+    fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt; {
<span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span> 
         // Find the nearest root that lies in the acceptable range.
         let mut root = (h - sqrtd) / a;
<span class="boring">-        if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span>+        if !ray_t.surrounds(root) {
             root = (h + sqrtd) / a;
<span class="boring">-            if root &lt;= ray_tmin || ray_tmax &lt;= root {
</span>+            if !ray_t.surrounds(root) {
                 return None;
             }
         }
 
<span class="boring">         let t = root;
</span><span class="boring">         let p = r.at(t);
</span><span class="boring">         let mut rec = HitRecord {
</span><span class="boring">             t,
</span><span class="boring">             p,
</span><span class="boring">             ..Default::default()
</span><span class="boring">         };
</span><span class="boring">         let outward_normal = (p - self.center) / self.radius;
</span><span class="boring">         rec.set_face_normal(r, outward_normal);
</span><span class="boring"> 
</span><span class="boring">         Some(rec)
</span>     }
 }</code></pre>
<p><strong>Listing 35:</strong> [<a href="https://github.com/goldnor/code/blob/d75c2cf12d1747e49e2568b2d4718ea5efea86e5/src/sphere.rs">sphere.rs</a>] <em>sphere using interval</em></p>
<br>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 59c000b..a8d3932 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,74 +1,74 @@
</span><span class="boring"> use code::{hittable::Hittable, hittable_list::HittableList, prelude::*, sphere::Sphere};
</span><span class="boring"> 
</span> fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">-    if let Some(rec) = world.hit(r, 0.0, INFINITY) {
</span>+    if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
         return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
     }
 
     let unit_direction = unit_vector(r.direction());
     let a = 0.5 * (unit_direction.y() + 1.0);
     (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
 }
<span class="boring"> 
</span><span class="boring"> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">     // Image
</span><span class="boring"> 
</span><span class="boring">     const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">     const IMAGE_WIDTH: i32 = 400;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">     const IMAGE_HEIGHT: i32 = {
</span><span class="boring">         let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">         if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     // World
</span><span class="boring"> 
</span><span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
</span><span class="boring"> 
</span><span class="boring">     // Camera
</span><span class="boring"> 
</span><span class="boring">     let focal_length = 1.0;
</span><span class="boring">     let viewport_height = 2.0;
</span><span class="boring">     let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">     let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">     let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">     let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">     // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">     let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">     let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring"> 
</span><span class="boring">     // Calculate the location of the upper left pixel.
</span><span class="boring">     let viewport_upper_left =
</span><span class="boring">         camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">     let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">     // Render
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span><span class="boring">     println!("P3");
</span><span class="boring">     println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">     println!("255");
</span><span class="boring"> 
</span><span class="boring">     for j in 0..IMAGE_HEIGHT {
</span><span class="boring">         info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">         for i in 0..IMAGE_WIDTH {
</span><span class="boring">             let pixel_center =
</span><span class="boring">                 pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">             let ray_direction = pixel_center - camera_center;
</span><span class="boring">             let r = Ray::new(camera_center, ray_direction);
</span><span class="boring"> 
</span><span class="boring">             let pixel_color = ray_color(r, &amp;world);
</span><span class="boring">             write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">     info!("Done.");
</span><span class="boring"> 
</span><span class="boring">     Ok(())
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 36:</strong> [<a href="https://github.com/goldnor/code/blob/d75c2cf12d1747e49e2568b2d4718ea5efea86e5/src/main.rs">main.rs</a>] <em>The new main using interval</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moving-camera-code-into-its-own-class"><a class="header" href="#moving-camera-code-into-its-own-class">Moving Camera Code Into Its Own Class</a></h1>
<p>Before continuing, now is a good time to consolidate our camera and scene-render code into a single new class: the <code>camera</code> class. The camera class will be responsible for two important jobs:</p>
<ol>
<li>Construct and dispatch rays into the world.</li>
<li>Use the results of these rays to construct the rendered image.</li>
</ol>
<p>In this refactoring, we'll collect the <code>ray_color()</code> function, along with the image, camera, and render sections of our main program. The new camera class will contain two public methods <code>initialize()</code> and <code>render()</code>, plus two private helper methods <code>get_ray()</code> and <code>ray_color()</code>.</p>
<p>Ultimately, the camera will follow the simplest usage pattern that we could think of: it will be default constructed no arguments, then the owning code will modify the camera's public variables through simple assignment, and finally everything is initialized by a call to the <code>initialize()</code> function. This pattern is chosen instead of the owner calling a constructor with a ton of parameters or by defining and calling a bunch of setter methods. Instead, the owning code only needs to set what it explicitly cares about. Finally, we could either have the owning code call <code>initialize()</code>, or just have the camera call this function automatically at the start of <code>render()</code>. We'll use the second approach. <sup class="footnote-reference" id="fr-7a-1"><a href="#footnote-7a">1</a></sup></p>
<p>After main creates a camera and sets default values, it will call the <code>render()</code> method. The <code>render()</code> method will prepare the <code>camera</code> for rendering and then execute the render loop.</p>
<p>Here's the skeleton of our new <code>camera</code> class:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{hittable::Hittable, prelude::*};
</span><span class="boring">
</span><span class="boring">pub struct Camera {
</span><span class="boring">    /// Ratio of image width over height
</span><span class="boring">    pub aspect_ratio: f64,
</span><span class="boring">    /// Rendered image width in pixel count
</span><span class="boring">    pub image_width: i32,
</span><span class="boring">
</span><span class="boring">    /// Rendered image height
</span><span class="boring">    image_height: i32,
</span><span class="boring">    /// Camera center
</span><span class="boring">    center: Point3,
</span><span class="boring">    /// Location of pixel 0, 0
</span><span class="boring">    pixel00_loc: Point3,
</span><span class="boring">    /// Offset to pixel to the right
</span><span class="boring">    pixel_delta_u: Vec3,
</span><span class="boring">    /// Offset to pixel below
</span><span class="boring">    pixel_delta_v: Vec3,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Camera {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            aspect_ratio: 1.0,
</span><span class="boring">            image_width: 100,
</span><span class="boring">            image_height: Default::default(),
</span><span class="boring">            center: Default::default(),
</span><span class="boring">            pixel00_loc: Default::default(),
</span><span class="boring">            pixel_delta_u: Default::default(),
</span><span class="boring">            pixel_delta_v: Default::default(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Camera {
    pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
<span class="boring">        self.aspect_ratio = aspect_ratio;
</span>
<span class="boring">        self
</span>    }

    pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
<span class="boring">        self.image_width = image_width;
</span>
<span class="boring">        self
</span>    }

    pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
<span class="boring">        self.initialize();
</span>
<span class="boring">        println!("P3");
</span><span class="boring">        println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">        println!("255");
</span><span class="boring">
</span><span class="boring">        for j in 0..self.image_height {
</span><span class="boring">            info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">            for i in 0..self.image_width {
</span><span class="boring">                let pixel_center = self.pixel00_loc
</span><span class="boring">                    + (i as f64) * self.pixel_delta_u
</span><span class="boring">                    + (j as f64) * self.pixel_delta_v;
</span><span class="boring">                let ray_direction = pixel_center - self.center;
</span><span class="boring">                let r = Ray::new(self.center, ray_direction);
</span><span class="boring">
</span><span class="boring">                let pixel_color = Self::ray_color(r, world);
</span><span class="boring">                write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        info!("Done.");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span>    }

    fn initialize(&amp;mut self) {
<span class="boring">        self.image_height = {
</span><span class="boring">            let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">            if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">        };
</span>
<span class="boring">        self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring">
</span><span class="boring">        // Determine viewport dimensions.
</span><span class="boring">        let focal_length = 1.0;
</span><span class="boring">        let viewport_height = 2.0;
</span><span class="boring">        let viewport_width =
</span><span class="boring">            viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring">
</span><span class="boring">        // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">        let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">        let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring">
</span><span class="boring">        // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">        self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">        self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring">
</span><span class="boring">        // Calculate the location of the upper left pixel.
</span><span class="boring">        let viewport_upper_left =
</span><span class="boring">            self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">        self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span>    }

    fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">        if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span><span class="boring">            return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span><span class="boring">        }
</span>
<span class="boring">        let unit_direction = unit_vector(r.direction());
</span><span class="boring">        let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">        (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>    }
}</code></pre>
<p><strong>Listing 37:</strong> [<a href="https://github.com/goldnor/code/blob/9b893f7953de35ce34fad2062845cb4d0202c21e/src/camera.rs">camera.rs</a>] <em>The camera class skeleton</em></p>
<br>
<p>To begin with, let's fill in the <code>ray_color()</code> function from <code>main.cc</code>:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">use crate::{hittable::Hittable, prelude::*};
</span><span class="boring">
</span><span class="boring">pub struct Camera {
</span><span class="boring">    /// Ratio of image width over height
</span><span class="boring">    pub aspect_ratio: f64,
</span><span class="boring">    /// Rendered image width in pixel count
</span><span class="boring">    pub image_width: i32,
</span><span class="boring">
</span><span class="boring">    /// Rendered image height
</span><span class="boring">    image_height: i32,
</span><span class="boring">    /// Camera center
</span><span class="boring">    center: Point3,
</span><span class="boring">    /// Location of pixel 0, 0
</span><span class="boring">    pixel00_loc: Point3,
</span><span class="boring">    /// Offset to pixel to the right
</span><span class="boring">    pixel_delta_u: Vec3,
</span><span class="boring">    /// Offset to pixel below
</span><span class="boring">    pixel_delta_v: Vec3,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Camera {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            aspect_ratio: 1.0,
</span><span class="boring">            image_width: 100,
</span><span class="boring">            image_height: Default::default(),
</span><span class="boring">            center: Default::default(),
</span><span class="boring">            pixel00_loc: Default::default(),
</span><span class="boring">            pixel_delta_u: Default::default(),
</span><span class="boring">            pixel_delta_v: Default::default(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Camera {
<span class="boring">    pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">        self.aspect_ratio = aspect_ratio;
</span><span class="boring">
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">        self.image_width = image_width;
</span><span class="boring">
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">        self.initialize();
</span><span class="boring">
</span><span class="boring">        println!("P3");
</span><span class="boring">        println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">        println!("255");
</span><span class="boring">
</span><span class="boring">        for j in 0..self.image_height {
</span><span class="boring">            info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">            for i in 0..self.image_width {
</span><span class="boring">                let pixel_center = self.pixel00_loc
</span><span class="boring">                    + (i as f64) * self.pixel_delta_u
</span><span class="boring">                    + (j as f64) * self.pixel_delta_v;
</span><span class="boring">                let ray_direction = pixel_center - self.center;
</span><span class="boring">                let r = Ray::new(self.center, ray_direction);
</span><span class="boring">
</span><span class="boring">                let pixel_color = Self::ray_color(r, world);
</span><span class="boring">                write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        info!("Done.");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn initialize(&amp;mut self) {
</span><span class="boring">        self.image_height = {
</span><span class="boring">            let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">            if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring">
</span><span class="boring">        // Determine viewport dimensions.
</span><span class="boring">        let focal_length = 1.0;
</span><span class="boring">        let viewport_height = 2.0;
</span><span class="boring">        let viewport_width =
</span><span class="boring">            viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring">
</span><span class="boring">        // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">        let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">        let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring">
</span><span class="boring">        // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">        self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">        self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring">
</span><span class="boring">        // Calculate the location of the upper left pixel.
</span><span class="boring">        let viewport_upper_left =
</span><span class="boring">            self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">        self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
        if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
            return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
        }

        let unit_direction = unit_vector(r.direction());
        let a = 0.5 * (unit_direction.y() + 1.0);
        (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
    }
}</code></pre>
<p><strong>Listing 38:</strong> [<a href="https://github.com/goldnor/code/blob/9b893f7953de35ce34fad2062845cb4d0202c21e/src/camera.rs">camera.rs</a>] <em>The camera::ray_color function</em></p>
<br>
<p>Now we move almost everything from the <code>main()</code> function into our new camera class. The only thing remaining in the <code>main()</code> function is the world construction. Here's the camera class with newly migrated code:</p>
<pre><code class="language-rust norun noplayground">use crate::{hittable::Hittable, prelude::*};

pub struct Camera {
    /// Ratio of image width over height
    pub aspect_ratio: f64,
    /// Rendered image width in pixel count
    pub image_width: i32,

    /// Rendered image height
    image_height: i32,
    /// Camera center
    center: Point3,
    /// Location of pixel 0, 0
    pixel00_loc: Point3,
    /// Offset to pixel to the right
    pixel_delta_u: Vec3,
    /// Offset to pixel below
    pixel_delta_v: Vec3,
}

impl Default for Camera {
    fn default() -&gt; Self {
        Self {
            aspect_ratio: 1.0,
            image_width: 100,
            image_height: Default::default(),
            center: Default::default(),
            pixel00_loc: Default::default(),
            pixel_delta_u: Default::default(),
            pixel_delta_v: Default::default(),
        }
    }
}

impl Camera {
    pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
        self.aspect_ratio = aspect_ratio;

        self
    }

    pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
        self.image_width = image_width;

        self
    }

    pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
        self.initialize();

        println!("P3");
        println!("{} {}", self.image_width, self.image_height);
        println!("255");

        for j in 0..self.image_height {
            info!("Scanlines remaining: {}", self.image_height - j);
            for i in 0..self.image_width {
                let pixel_center = self.pixel00_loc
                    + (i as f64) * self.pixel_delta_u
                    + (j as f64) * self.pixel_delta_v;
                let ray_direction = pixel_center - self.center;
                let r = Ray::new(self.center, ray_direction);

                let pixel_color = Self::ray_color(r, world);
                write_color(std::io::stdout(), pixel_color)?;
            }
        }
        info!("Done.");

        Ok(())
    }

    fn initialize(&amp;mut self) {
        self.image_height = {
            let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
            if image_height &lt; 1 { 1 } else { image_height }
        };

        self.center = Point3::new(0.0, 0.0, 0.0);

        // Determine viewport dimensions.
        let focal_length = 1.0;
        let viewport_height = 2.0;
        let viewport_width =
            viewport_height * (self.image_width as f64) / (self.image_height as f64);

        // Calculate the vectors across the horizontal and down the vertical viewport edges.
        let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
        let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);

        // Calculate the horizontal and vertical delta vectors from pixel to pixel.
        self.pixel_delta_u = viewport_u / self.image_width as f64;
        self.pixel_delta_v = viewport_v / self.image_height as f64;

        // Calculate the location of the upper left pixel.
        let viewport_upper_left =
            self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
        self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
    }

    fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">        if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span><span class="boring">            return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span><span class="boring">        }
</span>
<span class="boring">        let unit_direction = unit_vector(r.direction());
</span><span class="boring">        let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">        (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>    }
}</code></pre>
<p><strong>Listing 39:</strong> [<a href="https://github.com/goldnor/code/blob/9b893f7953de35ce34fad2062845cb4d0202c21e/src/camera.rs">camera.rs</a>] <em>The working camera class</em></p>
<br>
<p>And here's the much reduced main:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index a8d3932..27377f1 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,74 +1,15 @@
</span><span class="boring">-use code::{hittable::Hittable, hittable_list::HittableList, prelude::*, sphere::Sphere};
</span><span class="boring">-
</span>-fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">-    if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span><span class="boring">-        return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span><span class="boring">-    }
</span>-
<span class="boring">-    let unit_direction = unit_vector(r.direction());
</span><span class="boring">-    let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">-    (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>-}
-
<span class="boring">-fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">-    // Image
</span><span class="boring">-
</span><span class="boring">-    const ASPECT_RATIO: f64 = 16.0 / 9.0;
</span><span class="boring">-    const IMAGE_WIDTH: i32 = 400;
</span><span class="boring">-
</span><span class="boring">-    // Calculate the image height, and ensure that it's at least 1.
</span><span class="boring">-    const IMAGE_HEIGHT: i32 = {
</span><span class="boring">-        let image_height = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">-        if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">-    };
</span><span class="boring">-
</span><span class="boring">-    // World
</span>+use code::{camera::Camera, hittable_list::HittableList, prelude::*, sphere::Sphere};
 
+fn main() -&gt; std::io::Result&lt;()&gt; {
     let mut world = HittableList::new();
 
     world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
     world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
 
<span class="boring">-    // Camera
</span><span class="boring">-
</span><span class="boring">-    let focal_length = 1.0;
</span><span class="boring">-    let viewport_height = 2.0;
</span><span class="boring">-    let viewport_width = viewport_height * (IMAGE_WIDTH as f64) / (IMAGE_HEIGHT as f64);
</span><span class="boring">-    let camera_center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring">-
</span><span class="boring">-    // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">-    let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">-    let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring">-
</span><span class="boring">-    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">-    let pixel_delta_u = viewport_u / IMAGE_WIDTH as f64;
</span><span class="boring">-    let pixel_delta_v = viewport_v / IMAGE_HEIGHT as f64;
</span><span class="boring">-
</span><span class="boring">-    // Calculate the location of the upper left pixel.
</span><span class="boring">-    let viewport_upper_left =
</span><span class="boring">-        camera_center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">-    let pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
</span><span class="boring">-
</span><span class="boring">-    // Render
</span><span class="boring">-
</span>     env_logger::init();
<span class="boring">-    println!("P3");
</span><span class="boring">-    println!("{IMAGE_WIDTH} {IMAGE_HEIGHT}");
</span><span class="boring">-    println!("255");
</span><span class="boring">-
</span><span class="boring">-    for j in 0..IMAGE_HEIGHT {
</span><span class="boring">-        info!("Scanlines remaining: {}", IMAGE_HEIGHT - j);
</span><span class="boring">-        for i in 0..IMAGE_WIDTH {
</span><span class="boring">-            let pixel_center =
</span><span class="boring">-                pixel00_loc + (i as f64) * pixel_delta_u + (j as f64) * pixel_delta_v;
</span><span class="boring">-            let ray_direction = pixel_center - camera_center;
</span><span class="boring">-            let r = Ray::new(camera_center, ray_direction);
</span><span class="boring">-
</span><span class="boring">-            let pixel_color = ray_color(r, &amp;world);
</span><span class="boring">-            write_color(std::io::stdout(), pixel_color)?;
</span><span class="boring">-        }
</span><span class="boring">-    }
</span><span class="boring">-    info!("Done.");
</span> 
<span class="boring">-    Ok(())
</span>+    Camera::default()
+        .with_aspect_ratio(16.0 / 9.0)
+        .with_image_width(400)
+        .render(&amp;world)
 }
</code></pre>
<p><strong>Listing 40:</strong> [<a href="https://github.com/goldnor/code/blob/1ffb3c6125e9e07efe10f448e9f1adc0b5800a1d/src/main.rs">main.rs</a>] <em>The new main, using the new camera</em></p>
<br>
<p>Running this newly refactored program should give us the same rendered image as before.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-7a">
<p>The idiomatic Rust solution for this type of problem is the builder pattern. Important parameters can be set either directly with struct access or via a convenient method chain in the owning code. <a href="#fr-7a-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="antialiasing"><a class="header" href="#antialiasing">Antialiasing</a></h1>
<p>If you zoom into the rendered images so far, you might notice the harsh “stair step” nature of edges in our rendered images. This stair-stepping is commonly referred to as “aliasing”, or “jaggies”. When a real camera takes a picture, there are usually no jaggies along edges, because the edge pixels are a blend of some foreground and some background. Consider that unlike our rendered images, a true image of the world is continuous. Put another way, the world (and any true image of it) has effectively infinite resolution. We can get the same effect by averaging a bunch of samples for each pixel.</p>
<p>With a single ray through the center of each pixel, we are performing what is commonly called <em>point sampling</em>. The problem with point sampling can be illustrated by rendering a small checkerboard far away. If this checkerboard consists of an 8×8 grid of black and white tiles, but only four rays hit it, then all four rays might intersect only white tiles, or only black, or some odd combination. In the real world, when we perceive a checkerboard far away with our eyes, we perceive it as a gray color, instead of sharp points of black and white. That's because our eyes are naturally doing what we want our ray tracer to do: integrate the (continuous function of) light falling on a particular (discrete) region of our rendered image.</p>
<p>Clearly we don't gain anything by just resampling the same ray through the pixel center multiple times — we'd just get the same result each time. Instead, we want to sample the light falling <em>around</em> the pixel, and then integrate those samples to approximate the true continuous result. So, how do we integrate the light falling around the pixel?</p>
<p>We'll adopt the simplest model: sampling the square region centered at the pixel that extends halfway to each of the four neighboring pixels. This is not the optimal approach, but it is the most straight-forward. (See <a href="https://www.researchgate.net/publication/244986797_A_Pixel_Is_Not_A_Little_Square_A_Pixel_Is_Not_A_Little_Square_A_Pixel_Is_Not_A_Little_Square">A Pixel is Not a Little Square</a> for a deeper dive into this topic.)</p>
<p><img src="chapters/antialiasing/../../imgs/fig-1.08-pixel-samples.jpg" alt="Pixel samples" /></p>
<p><strong>Figure 8:</strong> <em>Pixel samples</em></p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="some-random-number-utilities-1"><a class="header" href="#some-random-number-utilities-1">Some Random Number Utilities <sup class="footnote-reference" id="fr-81a-1"><a href="#footnote-81a">1</a></sup></a></h1>
<p>We're going to need a random number generator that returns real random numbers. This function should return a canonical random number, which by convention falls in the range \( 0 \le n &lt; 1 \). The “less than” before the \( 1 \) is important, as we will sometimes take advantage of that.</p>
<p>A simple approach to this is to use the <code>std::rand()</code> function that can be found in <code>&lt;cstdlib&gt;</code>, which returns a random integer in the range <code>0</code> and <code>RAND_MAX</code>. Hence we can get a real random number as desired with the following code snippet, added to <code>rtweekend.h</code>:</p>
<pre><code class="language-rust norun noplayground">// Utility Functions

#[inline]
pub fn degrees_to_radians(degrees: f64) -&gt; f64 {
    degrees.to_radians()
}

#[inline]
pub fn random_double() -&gt; f64 {
    // Returns a random real in [0,1).
    rand::random::&lt;i32&gt;() as f64 / (i32::MAX as f64 + 1.0)
}

#[inline]
pub fn random_double_range(min: f64, max: f64) -&gt; f64 {
    // Returns a random real in [min,max).
    min + (max - min) * random_double()
}</code></pre>
<p><strong>Listing 41:</strong> [<a href="https://github.com/goldnor/code/blob/48d27302c1d726208b8f952050bcca45e53dc756/src/prelude.rs">prelude.rs</a>] <em>random_double() functions</em></p>
<p>C++ did not traditionally have a standard random number generator, but newer versions of C++ have addressed this issue with the <code>&lt;random&gt;</code> header (if imperfectly according to some experts). <sup class="footnote-reference" id="fr-81b-1"><a href="#footnote-81b">2</a></sup> If you want to use this, you can obtain a random number with the conditions we need as follows:</p>
<p><a name="l42"></a></p>
<pre><code class="language-rust norun noplayground">// Utility Functions

#[inline]
pub fn degrees_to_radians(degrees: f64) -&gt; f64 {
    degrees.to_radians()
}

#[inline]
pub fn random_double() -&gt; f64 {
    // Returns a random real in [0,1).
    rand::random()
}

#[inline]
pub fn random_double_range(min: f64, max: f64) -&gt; f64 {
    // Returns a random real in [min,max).
    rand::random_range(min..max)
}</code></pre>
<p><strong>Listing 42:</strong> [<a href="https://github.com/goldnor/code/blob/48d27302c1d726208b8f952050bcca45e53dc756/src/prelude.rs">prelude.rs</a>] <em>random_double() functions</em></p>
<hr>
<ol class="footnote-definition"><li id="footnote-81a">
<p>The utility functions, such as <code>degrees_to_radians</code>, were not mentioned in <a href="chapters/antialiasing/../surface_normals_and_multiple_objects/common_constants_and_utility_functions.html">chapter 6.7</a> since Rust already provides this functionality by default. The utility functions for randomness described in this chapter will also not be included in the code, as they only wrap functions implemented in the Rust <a href="https://crates.io/crates/rand">rand crate</a> (see <a href="chapters/antialiasing/some_random_number_utilities.html#l42">listing 42</a>). <a href="#fr-81a-1">↩</a></p>
</li>
<li id="footnote-81b">
<p>As far as I am aware, the Rust implementation is perfectly fine. <a href="#fr-81b-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="generating-pixels-with-multiple-samples"><a class="header" href="#generating-pixels-with-multiple-samples">Generating Pixels with Multiple Samples</a></h1>
<p>For a single pixel composed of multiple samples, we'll select samples from the area surrounding the pixel and average the resulting light (color) values together.</p>
<p>First we'll update the <code>write_color()</code> function to account for the number of samples we use: we need to find the average across all of the samples that we take. To do this, we'll add the full color from each iteration, and then finish with a single division (by the number of samples) at the end, before writing out the color. To ensure that the color components of the final result remain within the proper \( [0,1] \) bounds, we'll add and use a small helper function: <code>interval::clamp(x)</code>. <sup class="footnote-reference" id="fr-82a-1"><a href="#footnote-82a">1</a></sup> <sup class="footnote-reference" id="fr-82b-1"><a href="#footnote-82b">2</a></sup></p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/interval.rs b/src/interval.rs
</span><span class="boring">index 509fddf..482d922 100644
</span><span class="boring">--- a/src/interval.rs
</span><span class="boring">+++ b/src/interval.rs
</span><span class="boring">@@ -1,39 +1,43 @@
</span><span class="boring"> #[derive(Debug, Clone, Copy)]
</span><span class="boring"> pub struct Interval {
</span><span class="boring">     pub min: f64,
</span><span class="boring">     pub max: f64,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Default for Interval {
</span><span class="boring">     fn default() -&gt; Self {
</span><span class="boring">         Self::EMPTY
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Interval {
<span class="boring">     pub const EMPTY: Self = Self {
</span><span class="boring">         min: f64::INFINITY,
</span><span class="boring">         max: f64::NEG_INFINITY,
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">     pub const UNIVERSE: Self = Self {
</span><span class="boring">         min: f64::NEG_INFINITY,
</span><span class="boring">         max: f64::INFINITY,
</span><span class="boring">     };
</span><span class="boring"> 
</span><span class="boring">-    pub fn new(min: f64, max: f64) -&gt; Self {
</span><span class="boring">+    pub const fn new(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Self { min, max }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn size(&amp;self) -&gt; f64 {
</span><span class="boring">         self.max - self.min
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn contains(&amp;self, x: f64) -&gt; bool {
</span><span class="boring">         self.min &lt;= x &amp;&amp; x &lt;= self.max
</span><span class="boring">     }
</span> 
     pub fn surrounds(&amp;self, x: f64) -&gt; bool {
         self.min &lt; x &amp;&amp; x &lt; self.max
     }
+
+    pub const fn clamp(&amp;self, x: f64) -&gt; f64 {
+        x.clamp(self.min, self.max)
+    }
 }</code></pre>
<p><strong>Listing 43:</strong> [<a href="https://github.com/goldnor/code/blob/c2937087b619981d108b6774b790af1d59316329/src/interval.rs">interval.rs</a>] <em>The interval::clamp() utility function</em></p>
<br>
<p>Here's the updated <code>write_color()</code> function that incorporates the interval clamping function:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/color.rs b/src/color.rs
</span><span class="boring">index c645ca2..1615d55 100644
</span><span class="boring">--- a/src/color.rs
</span><span class="boring">+++ b/src/color.rs
</span><span class="boring">@@ -1,15 +1,18 @@
</span><span class="boring">-use crate::vec3::Vec3;
</span>+use crate::prelude::*;
 
 pub type Color = Vec3;
 
 pub fn write_color(mut out: impl std::io::Write, pixel_color: Color) -&gt; std::io::Result&lt;()&gt; {
     let r = pixel_color.x();
     let g = pixel_color.y();
     let b = pixel_color.z();
 
<span class="boring">-    let rbyte = (255.999 * r) as i32;
</span><span class="boring">-    let gbyte = (255.999 * g) as i32;
</span><span class="boring">-    let bbyte = (255.999 * b) as i32;
</span>+    // Translate the [0,1] component values to the byte range [0,255].
+    const INTENSITY: Interval = Interval::new(0.000, 0.999);
+    let rbyte = (256.0 * INTENSITY.clamp(r)) as i32;
+    let gbyte = (256.0 * INTENSITY.clamp(g)) as i32;
+    let bbyte = (256.0 * INTENSITY.clamp(b)) as i32;
 
+    // Write out the pixel color components.
     writeln!(out, "{rbyte} {gbyte} {bbyte}")
 }</code></pre>
<p><strong>Listing 44:</strong> [<a href="https://github.com/goldnor/code/blob/f9b02376bc5c4d4f7337d6fef6903506086925da/src/color.rs">color.rs</a>] <em>The multi-sample write_color() function</em></p>
<br>
<p>Now let's update the camera class to define and use a new <code>camera::get_ray(i,j)</code> function, which will generate different samples for each pixel. This function will use a new helper function <code>sample_square()</code> that generates a random sample point within the unit square centered at the origin. We then transform the random sample from this ideal square back to the particular pixel we're currently sampling.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index 73dc5cc..f181b03 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,110 +1,151 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span> pub struct Camera {
     /// Ratio of image width over height
     pub aspect_ratio: f64,
     /// Rendered image width in pixel count
     pub image_width: i32,
+    // Count of random samples for each pixel
+    pub samples_per_pixel: i32,
 
     /// Rendered image height
     image_height: i32,
+    // Color scale factor for a sum of pixel samples
+    pixel_samples_scale: f64,
     /// Camera center
     center: Point3,
     /// Location of pixel 0, 0
     pixel00_loc: Point3,
     /// Offset to pixel to the right
     pixel_delta_u: Vec3,
     /// Offset to pixel below
     pixel_delta_v: Vec3,
 }
 
 impl Default for Camera {
     fn default() -&gt; Self {
         Self {
             aspect_ratio: 1.0,
             image_width: 100,
+            samples_per_pixel: 10,
             image_height: Default::default(),
+            pixel_samples_scale: Default::default(),
             center: Default::default(),
             pixel00_loc: Default::default(),
             pixel_delta_u: Default::default(),
             pixel_delta_v: Default::default(),
         }
     }
 }
 
 impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span> 
+    pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
+        self.samples_per_pixel = samples_per_pixel;
+
+        self
+    }
+
     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
         self.initialize();
 
         println!("P3");
         println!("{} {}", self.image_width, self.image_height);
         println!("255");
 
         for j in 0..self.image_height {
             info!("Scanlines remaining: {}", self.image_height - j);
             for i in 0..self.image_width {
<span class="boring">-                let pixel_center = self.pixel00_loc
</span><span class="boring">-                    + (i as f64) * self.pixel_delta_u
</span><span class="boring">-                    + (j as f64) * self.pixel_delta_v;
</span><span class="boring">-                let ray_direction = pixel_center - self.center;
</span><span class="boring">-                let r = Ray::new(self.center, ray_direction);
</span><span class="boring">-
</span><span class="boring">-                let pixel_color = Self::ray_color(r, world);
</span><span class="boring">-                write_color(std::io::stdout(), pixel_color)?;
</span>+                let mut pixel_color = Color::new(0.0, 0.0, 0.0);
+                for _sample in 0..self.samples_per_pixel {
+                    let r = self.get_ray(i, j);
+                    pixel_color += Self::ray_color(r, world);
+                }
+                write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
             }
         }
         info!("Done.");
 
         Ok(())
     }
 
     fn initialize(&amp;mut self) {
         self.image_height = {
             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
             if image_height &lt; 1 { 1 } else { image_height }
         };
 
+        self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
+
         self.center = Point3::new(0.0, 0.0, 0.0);
 
<span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span>     }
 
+    fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
+        // Construct a camera ray originating from the origin and directed at randomly sampled
+        // point around the pixel location i, j.
+
+        let offset = Self::sample_square();
+        let pixel_sample = self.pixel00_loc
+            + ((i as f64 + offset.x()) * self.pixel_delta_u)
+            + ((j as f64 + offset.y()) * self.pixel_delta_v);
+
+        let ray_origin = self.center;
+        let ray_direction = pixel_sample - ray_origin;
+
+        Ray::new(ray_origin, ray_direction)
+    }
+
+    fn sample_square() -&gt; Vec3 {
+        // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
+        Vec3::new(
+            rand::random::&lt;f64&gt;() - 0.5,
+            rand::random::&lt;f64&gt;() - 0.5,
+            0.0,
+        )
+    }
+
<span class="boring">+    fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">+        // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">+        radius * random_in_unit_disk()
</span><span class="boring">+    }
</span><span class="boring">+
</span>     fn ray_color(r: Ray, world: &amp;impl Hittable) -&gt; Color {
<span class="boring">         if let Some(rec) = world.hit(r, Interval::new(0.0, INFINITY)) {
</span><span class="boring">             return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
</span><span class="boring">         }
</span> 
<span class="boring">         let unit_direction = unit_vector(r.direction());
</span><span class="boring">         let a = 0.5 * (unit_direction.y() + 1.0);
</span><span class="boring">         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
</span>     }
 }</code></pre>
<p><strong>Listing 45:</strong> [<a href="https://github.com/goldnor/code/blob/8f64151623f1e58e249d00f11a8cac23523fec1b/src/camera.rs">camera.rs</a>] <em>Camera with samples-per-pixel parameter</em></p>
<br>
<p>(In addition to the new <code>sample_square()</code> function above, you'll also find the function <code>sample_disk()</code> in the Github source code. This is included in case you'd like to experiment with non-square pixels, but we won't be using it in this book. sample_disk() depends on the function random_in_unit_disk() which is defined later on.)</p>
<p>Main is updated to set the new camera parameter.</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/main.rs b/src/main.rs
</span><span class="boring">index 27377f1..9f08807 100644
</span><span class="boring">--- a/src/main.rs
</span><span class="boring">+++ b/src/main.rs
</span><span class="boring">@@ -1,15 +1,16 @@
</span><span class="boring"> use code::{camera::Camera, hittable_list::HittableList, prelude::*, sphere::Sphere};
</span><span class="boring"> 
</span> fn main() -&gt; std::io::Result&lt;()&gt; {
<span class="boring">     let mut world = HittableList::new();
</span><span class="boring"> 
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
</span><span class="boring">     world.add(Rc::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));
</span><span class="boring"> 
</span><span class="boring">     env_logger::init();
</span> 
     Camera::default()
         .with_aspect_ratio(16.0 / 9.0)
         .with_image_width(400)
+        .with_samples_per_pixel(100)
         .render(&amp;world)
 }</code></pre>
<p><strong>Listing 46:</strong> [<a href="https://github.com/goldnor/code/blob/d4b3a2498a7ed1a3a51ade2c425683a7ff4ad018/src/main.rs">main.rs</a>] <em>Setting the new samples-per-pixel parameter</em></p>
<br>
<p>Zooming into the image that is produced, we can see the difference in edge pixels.</p>
<img style="width: 100%; image-rendering: pixelated" src="chapters/antialiasing/../../imgs/img-1.06-antialias-before-after.png" alt="Before and after antialiasing">
<!-- ![x](../../imgs/img-1.06-antialias-before-after.png) -->
<p><strong>Image 6:</strong> <em>Before and after antialiasing</em></p>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-82a">
<p>For this purpose, version 1.50 of Rust introduced the <code>f64::clamp(self, min, max)</code> <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.clamp">function</a> (the C++17 standard introduced a similar <a href="https://en.cppreference.com/w/cpp/algorithm/clamp.html">function</a> called <code>std::clamp(v, lo, hi)</code>). <a href="#fr-82a-1">↩</a></p>
</li>
<li id="footnote-82b">
<p>The function is const, meaning it can be used to initialise const variables. This will be demonstrated in the next listing. <a href="#fr-82b-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
