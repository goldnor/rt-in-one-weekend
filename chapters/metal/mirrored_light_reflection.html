<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mirrored Light Reflection - Ray Tracing in One Weekend (Rust)</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ray Tracing in One Weekend (Rust)</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="mirrored-light-reflection"><a class="header" href="#mirrored-light-reflection">Mirrored Light Reflection</a></h2>
<p>For polished metals the ray won’t be randomly scattered. The key question is: How does a ray get reflected from a metal mirror? Vector math is our friend here:</p>
<p><img src="../../imgs/fig-1.15-reflection.jpg" alt="Ray reflection" /></p>
<p><strong>Figure 15:</strong> <em>Ray reflection</em></p>
<br>
<p>The reflected ray direction in red is just \( \mathbf{v} + 2 \mathbf{b} \). In our design, \( \mathbf{n} \) is a unit vector (length one), but \( \mathbf{v} \) may not be. To get the vector \( \mathbf{b} \), we scale the normal vector by the length of the projection of \( \mathbf{v} \) onto \( \mathbf{n} \), which is given by the dot product \( \mathbf{v} \cdot \mathbf{n} \). (If \( \mathbf{n} \) were not a unit vector, we would also need to divide this dot product by the length of \( \mathbf{n} \).) Finally, because \( \mathbf{b} \) points <em>into</em> the surface, and we want \( \mathbf{b} \) to point <em>out</em> of the surface, we need to negate this projection length.</p>
<p>Putting everything together, we get the following computation of the reflected vector:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/vec3.rs b/src/vec3.rs
</span><span class="boring">index 3348fef..4cb0b6f 100644
</span><span class="boring">--- a/src/vec3.rs
</span><span class="boring">+++ b/src/vec3.rs
</span><span class="boring">@@ -1,229 +1,234 @@
</span><span class="boring"> use std::{
</span><span class="boring">     fmt::Display,
</span><span class="boring">     ops::{Add, AddAssign, Div, DivAssign, Index, IndexMut, Mul, MulAssign, Neg, Sub},
</span><span class="boring"> };
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Vec3 {
</span><span class="boring">     pub e: [f64; 3],
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> pub type Point3 = Vec3;
</span><span class="boring"> 
</span><span class="boring"> impl Vec3 {
</span><span class="boring">     pub fn new(e0: f64, e1: f64, e2: f64) -&gt; Self {
</span><span class="boring">         Self { e: [e0, e1, e2] }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn x(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn y(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[1]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn z(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length(&amp;self) -&gt; f64 {
</span><span class="boring">         f64::sqrt(self.length_squared())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn length_squared(&amp;self) -&gt; f64 {
</span><span class="boring">         self.e[0] * self.e[0] + self.e[1] * self.e[1] + self.e[2] * self.e[2]
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn near_zero(&amp;self) -&gt; bool {
</span><span class="boring">         // Return true if the vector is close to zero in all dimensions.
</span><span class="boring">         const S: f64 = 1e-8;
</span><span class="boring">         self.e[0].abs() &lt; S &amp;&amp; self.e[1].abs() &lt; S &amp;&amp; self.e[2].abs() &lt; S
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random() -&gt; Self {
</span><span class="boring">         Vec3 { e: rand::random() }
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn random_range(min: f64, max: f64) -&gt; Self {
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">             rand::random_range(min..max),
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Neg for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn neg(self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: self.e.map(|e| -e),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Index&lt;usize&gt; for Vec3 {
</span><span class="boring">     type Output = f64;
</span><span class="boring"> 
</span><span class="boring">     fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">         &amp;self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl IndexMut&lt;usize&gt; for Vec3 {
</span><span class="boring">     fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">         &amp;mut self.e[index]
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl AddAssign for Vec3 {
</span><span class="boring">     fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">         self.e[0] += rhs.e[0];
</span><span class="boring">         self.e[1] += rhs.e[1];
</span><span class="boring">         self.e[2] += rhs.e[2];
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl MulAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn mul_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.e[0] *= rhs;
</span><span class="boring">         self.e[1] *= rhs;
</span><span class="boring">         self.e[2] *= rhs;
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl DivAssign&lt;f64&gt; for Vec3 {
</span><span class="boring">     fn div_assign(&amp;mut self, rhs: f64) {
</span><span class="boring">         self.mul_assign(1.0 / rhs);
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Display for Vec3 {
</span><span class="boring">     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">         write!(f, "{} {} {}", self.e[0], self.e[1], self.e[2])
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Add for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] + rhs.e[0],
</span><span class="boring">                 self.e[1] + rhs.e[1],
</span><span class="boring">                 self.e[2] + rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Sub for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] - rhs.e[0],
</span><span class="boring">                 self.e[1] - rhs.e[1],
</span><span class="boring">                 self.e[2] - rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [
</span><span class="boring">                 self.e[0] * rhs.e[0],
</span><span class="boring">                 self.e[1] * rhs.e[1],
</span><span class="boring">                 self.e[2] * rhs.e[2],
</span><span class="boring">             ],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         Self::Output {
</span><span class="boring">             e: [self.e[0] * rhs, self.e[1] * rhs, self.e[2] * rhs],
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Mul&lt;Vec3&gt; for f64 {
</span><span class="boring">     type Output = Vec3;
</span><span class="boring"> 
</span><span class="boring">     fn mul(self, rhs: Vec3) -&gt; Self::Output {
</span><span class="boring">         rhs.mul(self)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Div&lt;f64&gt; for Vec3 {
</span><span class="boring">     type Output = Self;
</span><span class="boring"> 
</span><span class="boring">     fn div(self, rhs: f64) -&gt; Self::Output {
</span><span class="boring">         self * (1.0 / rhs)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn dot(u: Vec3, v: Vec3) -&gt; f64 {
</span><span class="boring">     u.e[0] * v.e[0] + u.e[1] * v.e[1] + u.e[2] * v.e[2]
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn cross(u: Vec3, v: Vec3) -&gt; Vec3 {
</span><span class="boring">     Vec3::new(
</span><span class="boring">         u.e[1] * v.e[2] - u.e[2] * v.e[1],
</span><span class="boring">         u.e[2] * v.e[0] - u.e[0] * v.e[2],
</span><span class="boring">         u.e[0] * v.e[1] - u.e[1] * v.e[0],
</span><span class="boring">     )
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn unit_vector(v: Vec3) -&gt; Vec3 {
</span><span class="boring">     v / v.length()
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[inline]
</span><span class="boring"> pub fn random_unit_vector() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::random_range(-1.0, 1.0);
</span><span class="boring">         let lensq = p.length_squared();
</span><span class="boring">         if 1e-160 &lt; lensq &amp;&amp; lensq &lt;= 1.0 {
</span><span class="boring">             return p / f64::sqrt(lensq);
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> #[inline]
 pub fn random_on_hemisphere(normal: Vec3) -&gt; Vec3 {
<span class="boring">     let on_unit_sphere = random_unit_vector();
</span><span class="boring">     if dot(on_unit_sphere, normal) &gt; 0.0 {
</span><span class="boring">         on_unit_sphere
</span><span class="boring">     } else {
</span><span class="boring">         -on_unit_sphere
</span><span class="boring">     }
</span> }
 
 #[inline]
+pub fn reflect(v: Vec3, n: Vec3) -&gt; Vec3 {
+    v - 2.0 * dot(v, n) * n
+}
<span class="boring">+
</span><span class="boring">+#[inline]
</span><span class="boring"> pub fn random_in_unit_disk() -&gt; Vec3 {
</span><span class="boring">     loop {
</span><span class="boring">         let p = Vec3::new(
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             rand::random_range(-1.0..1.0),
</span><span class="boring">             0.0,
</span><span class="boring">         );
</span><span class="boring">         if p.length_squared() &lt; 1.0 {
</span><span class="boring">             return p;
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 64:</strong> [<a href="https://github.com/goldnor/code/blob/5454ed7161f531954e1b14fb97bd52d11b7331a4/src/vec3.rs">vec3.rs</a>] <em>vec3 reflection function</em></p>
<br>
<p>The metal material just reflects rays using that formula:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/material.rs b/src/material.rs
</span><span class="boring">index 1b49e15..8475d17 100644
</span><span class="boring">--- a/src/material.rs
</span><span class="boring">+++ b/src/material.rs
</span><span class="boring">@@ -1,34 +1,55 @@
</span><span class="boring"> use crate::{hittable::HitRecord, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub trait Material {
</span><span class="boring">     fn scatter(&amp;self, _r_in: Ray, _rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         None
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> #[derive(Debug, Default, Clone, Copy)]
</span><span class="boring"> pub struct Lambertian {
</span><span class="boring">     albedo: Color,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Lambertian {
</span><span class="boring">     pub fn new(albedo: Color) -&gt; Self {
</span><span class="boring">         Self { albedo }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Material for Lambertian {
<span class="boring">     fn scatter(&amp;self, _r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
</span><span class="boring">         let mut scatter_direction = rec.normal + random_unit_vector();
</span> 
<span class="boring">         // Catch degenerate scatter direction
</span><span class="boring">         if scatter_direction.near_zero() {
</span><span class="boring">             scatter_direction = rec.normal;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let scattered = Ray::new(rec.p, scatter_direction);
</span><span class="boring">         let attenuation = self.albedo;
</span><span class="boring"> 
</span><span class="boring">         Some((scattered, attenuation))
</span><span class="boring">     }
</span> }
+
+#[derive(Debug, Default, Clone, Copy)]
+pub struct Metal {
+    albedo: Color,
+}
+
+impl Metal {
+    pub fn new(albedo: Color) -&gt; Self {
+        Self { albedo }
+    }
+}
+
+impl Material for Metal {
+    fn scatter(&amp;self, r_in: Ray, rec: HitRecord) -&gt; Option&lt;(Ray, Color)&gt; {
+        let reflected = reflect(r_in.direction(), rec.normal);
+        let scattered = Ray::new(rec.p, reflected);
+        let attenuation = self.albedo;
+
+        Some((scattered, attenuation))
+    }
+}</code></pre>
<p><strong>Listing 65:</strong> [<a href="https://github.com/goldnor/code/blob/c5fbfbf8809f5009c7c5953bcb1bcae1493267de/src/material.rs">material.rs</a>] <em>Metal material with reflectance function</em></p>
<br>
<p>We need to modify the <code>ray_color()</code> function for all of our changes:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/camera.rs b/src/camera.rs
</span><span class="boring">index e6c60c3..1927898 100644
</span><span class="boring">--- a/src/camera.rs
</span><span class="boring">+++ b/src/camera.rs
</span><span class="boring">@@ -1,166 +1,168 @@
</span><span class="boring"> use crate::{hittable::Hittable, prelude::*};
</span><span class="boring"> 
</span><span class="boring"> pub struct Camera {
</span><span class="boring">     /// Ratio of image width over height
</span><span class="boring">     pub aspect_ratio: f64,
</span><span class="boring">     /// Rendered image width in pixel count
</span><span class="boring">     pub image_width: i32,
</span><span class="boring">     // Count of random samples for each pixel
</span><span class="boring">     pub samples_per_pixel: i32,
</span><span class="boring">     // Maximum number of ray bounces into scene
</span><span class="boring">     pub max_depth: i32,
</span><span class="boring"> 
</span><span class="boring">     /// Rendered image height
</span><span class="boring">     image_height: i32,
</span><span class="boring">     // Color scale factor for a sum of pixel samples
</span><span class="boring">     pixel_samples_scale: f64,
</span><span class="boring">     /// Camera center
</span><span class="boring">     center: Point3,
</span><span class="boring">     /// Location of pixel 0, 0
</span><span class="boring">     pixel00_loc: Point3,
</span><span class="boring">     /// Offset to pixel to the right
</span><span class="boring">     pixel_delta_u: Vec3,
</span><span class="boring">     /// Offset to pixel below
</span><span class="boring">     pixel_delta_v: Vec3,
</span><span class="boring"> }
</span><span class="boring"> 
</span><span class="boring"> impl Default for Camera {
</span><span class="boring">     fn default() -&gt; Self {
</span><span class="boring">         Self {
</span><span class="boring">             aspect_ratio: 1.0,
</span><span class="boring">             image_width: 100,
</span><span class="boring">             samples_per_pixel: 10,
</span><span class="boring">             max_depth: 10,
</span><span class="boring">             image_height: Default::default(),
</span><span class="boring">             pixel_samples_scale: Default::default(),
</span><span class="boring">             center: Default::default(),
</span><span class="boring">             pixel00_loc: Default::default(),
</span><span class="boring">             pixel_delta_u: Default::default(),
</span><span class="boring">             pixel_delta_v: Default::default(),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring"> 
</span> impl Camera {
<span class="boring">     pub fn with_aspect_ratio(mut self, aspect_ratio: f64) -&gt; Self {
</span><span class="boring">         self.aspect_ratio = aspect_ratio;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_image_width(mut self, image_width: i32) -&gt; Self {
</span><span class="boring">         self.image_width = image_width;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_samples_per_pixel(mut self, samples_per_pixel: i32) -&gt; Self {
</span><span class="boring">         self.samples_per_pixel = samples_per_pixel;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn with_max_depth(mut self, max_depth: i32) -&gt; Self {
</span><span class="boring">         self.max_depth = max_depth;
</span><span class="boring"> 
</span><span class="boring">         self
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     pub fn render(&amp;mut self, world: &amp;impl Hittable) -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">         self.initialize();
</span><span class="boring"> 
</span><span class="boring">         println!("P3");
</span><span class="boring">         println!("{} {}", self.image_width, self.image_height);
</span><span class="boring">         println!("255");
</span><span class="boring"> 
</span><span class="boring">         for j in 0..self.image_height {
</span><span class="boring">             info!("Scanlines remaining: {}", self.image_height - j);
</span><span class="boring">             for i in 0..self.image_width {
</span><span class="boring">                 let mut pixel_color = Color::new(0.0, 0.0, 0.0);
</span><span class="boring">                 for _sample in 0..self.samples_per_pixel {
</span><span class="boring">                     let r = self.get_ray(i, j);
</span><span class="boring">                     pixel_color += Self::ray_color(r, self.max_depth, world);
</span><span class="boring">                 }
</span><span class="boring">                 write_color(std::io::stdout(), self.pixel_samples_scale * pixel_color)?;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring">         info!("Done.");
</span><span class="boring"> 
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn initialize(&amp;mut self) {
</span><span class="boring">         self.image_height = {
</span><span class="boring">             let image_height = (self.image_width as f64 / self.aspect_ratio) as i32;
</span><span class="boring">             if image_height &lt; 1 { 1 } else { image_height }
</span><span class="boring">         };
</span><span class="boring"> 
</span><span class="boring">         self.pixel_samples_scale = 1.0 / self.samples_per_pixel as f64;
</span><span class="boring"> 
</span><span class="boring">         self.center = Point3::new(0.0, 0.0, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Determine viewport dimensions.
</span><span class="boring">         let focal_length = 1.0;
</span><span class="boring">         let viewport_height = 2.0;
</span><span class="boring">         let viewport_width =
</span><span class="boring">             viewport_height * (self.image_width as f64) / (self.image_height as f64);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the vectors across the horizontal and down the vertical viewport edges.
</span><span class="boring">         let viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
</span><span class="boring">         let viewport_v = Vec3::new(0.0, -viewport_height, 0.0);
</span><span class="boring"> 
</span><span class="boring">         // Calculate the horizontal and vertical delta vectors from pixel to pixel.
</span><span class="boring">         self.pixel_delta_u = viewport_u / self.image_width as f64;
</span><span class="boring">         self.pixel_delta_v = viewport_v / self.image_height as f64;
</span><span class="boring"> 
</span><span class="boring">         // Calculate the location of the upper left pixel.
</span><span class="boring">         let viewport_upper_left =
</span><span class="boring">             self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_u / 2.0 - viewport_v / 2.0;
</span><span class="boring">         self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn get_ray(&amp;self, i: i32, j: i32) -&gt; Ray {
</span><span class="boring">         // Construct a camera ray originating from the origin and directed at randomly sampled
</span><span class="boring">         // point around the pixel location i, j.
</span><span class="boring"> 
</span><span class="boring">         let offset = Self::sample_square();
</span><span class="boring">         let pixel_sample = self.pixel00_loc
</span><span class="boring">             + ((i as f64 + offset.x()) * self.pixel_delta_u)
</span><span class="boring">             + ((j as f64 + offset.y()) * self.pixel_delta_v);
</span><span class="boring"> 
</span><span class="boring">         let ray_origin = self.center;
</span><span class="boring">         let ray_direction = pixel_sample - ray_origin;
</span><span class="boring"> 
</span><span class="boring">         Ray::new(ray_origin, ray_direction)
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn sample_square() -&gt; Vec3 {
</span><span class="boring">         // Returns the vector to a random point in the [-.5,-.5]-[+.5,+.5] unit square.
</span><span class="boring">         Vec3::new(
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             rand::random::&lt;f64&gt;() - 0.5,
</span><span class="boring">             0.0,
</span><span class="boring">         )
</span><span class="boring">     }
</span><span class="boring"> 
</span><span class="boring">     fn _sample_disk(radius: f64) -&gt; Vec3 {
</span><span class="boring">         // Returns a random point in the unit (radius 0.5) disk centered at the origin.
</span><span class="boring">         radius * random_in_unit_disk()
</span><span class="boring">     }
</span> 
     fn ray_color(r: Ray, depth: i32, world: &amp;impl Hittable) -&gt; Color {
         // If we've exceeded the ray bounce limit, no more light is gathered.
         if depth &lt;= 0 {
             return Color::new(0.0, 0.0, 0.0);
         }
 
         if let Some(rec) = world.hit(r, Interval::new(0.001, INFINITY)) {
<span class="boring">-            let direction = rec.normal + random_unit_vector();
</span><span class="boring">-            return 0.1 * Self::ray_color(Ray::new(rec.p, direction), depth - 1, world);
</span>+            if let Some((scattered, attenuation)) = rec.mat.scatter(r, rec.clone()) {
+                return attenuation * Self::ray_color(scattered, depth - 1, world);
+            }
+            return Color::new(0.0, 0.0, 0.0);
         }
 
         let unit_direction = unit_vector(r.direction());
         let a = 0.5 * (unit_direction.y() + 1.0);
         (1.0 - a) * Color::new(1.0, 1.0, 1.0) + a * Color::new(0.5, 0.7, 1.0)
     }
 }</code></pre>
<p><strong>Listing 66:</strong> [<a href="https://github.com/goldnor/code/blob/6e7548e7e604786c7ee88cc924ef6015cb6b49d7/src/camera.rs">camera.rs</a>] <em>Ray color with scattered reflectance</em></p>
<br>
<p>Now we'll update the sphere constructor to initialize the material pointer <code>mat</code>:</p>
<pre><code class="language-rust-diff norun noplayground"><span class="boring">diff --git a/src/sphere.rs b/src/sphere.rs
</span><span class="boring">index 2b0026a..2a6b2ce 100644
</span><span class="boring">--- a/src/sphere.rs
</span><span class="boring">+++ b/src/sphere.rs
</span><span class="boring">@@ -1,61 +1,60 @@
</span> use crate::{
     hittable::{HitRecord, Hittable},
<span class="boring">-    material::{Lambertian, Material},
</span>+    material::Material,
     prelude::*,
 };
<span class="boring"> 
</span><span class="boring"> #[derive(Clone)]
</span><span class="boring"> pub struct Sphere {
</span><span class="boring">     center: Point3,
</span><span class="boring">     radius: f64,
</span><span class="boring">     mat: Rc&lt;dyn Material&gt;,
</span><span class="boring"> }
</span> 
 impl Sphere {
<span class="boring">-    pub fn new(center: Point3, radius: f64) -&gt; Self {
</span>+    pub fn new(center: Point3, radius: f64, mat: Rc&lt;dyn Material&gt;) -&gt; Self {
         Self {
             center,
             radius: f64::max(0.0, radius),
<span class="boring">-            // TODO: Initialize the material pointer `mat`.
</span><span class="boring">-            mat: Rc::new(Lambertian::default()),
</span>+            mat,
         }
     }
 }
<span class="boring"> 
</span><span class="boring"> impl Hittable for Sphere {
</span><span class="boring">     fn hit(&amp;self, r: Ray, ray_t: Interval) -&gt; Option&lt;HitRecord&gt; {
</span><span class="boring">         let oc = self.center - r.origin();
</span><span class="boring">         let a = r.direction().length_squared();
</span><span class="boring">         let h = dot(r.direction(), oc);
</span><span class="boring">         let c = oc.length_squared() - self.radius * self.radius;
</span><span class="boring"> 
</span><span class="boring">         let discriminant = h * h - a * c;
</span><span class="boring">         if discriminant &lt; 0.0 {
</span><span class="boring">             return None;
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let sqrtd = f64::sqrt(discriminant);
</span><span class="boring"> 
</span><span class="boring">         // Find the nearest root that lies in the acceptable range.
</span><span class="boring">         let mut root = (h - sqrtd) / a;
</span><span class="boring">         if !ray_t.surrounds(root) {
</span><span class="boring">             root = (h + sqrtd) / a;
</span><span class="boring">             if !ray_t.surrounds(root) {
</span><span class="boring">                 return None;
</span><span class="boring">             }
</span><span class="boring">         }
</span><span class="boring"> 
</span><span class="boring">         let t = root;
</span><span class="boring">         let p = r.at(t);
</span><span class="boring">         let mut rec = HitRecord {
</span><span class="boring">             t,
</span><span class="boring">             p,
</span><span class="boring">             mat: self.mat.clone(),
</span><span class="boring">             ..Default::default()
</span><span class="boring">         };
</span><span class="boring">         let outward_normal = (p - self.center) / self.radius;
</span><span class="boring">         rec.set_face_normal(r, outward_normal);
</span><span class="boring"> 
</span><span class="boring">         Some(rec)
</span><span class="boring">     }
</span><span class="boring"> }</span></code></pre>
<p><strong>Listing 67:</strong> [<a href="https://github.com/goldnor/code/blob/29d828944db9e970983d3e7a5b2b3ad827e3991b/src/sphere.rs">sphere.rs</a>] <em>Initializing sphere with a material</em></p>
<br>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../chapters/metal/modeling_light_scatter_and_reflectance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../chapters/metal/a_scene_with_metal_spheres.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../chapters/metal/modeling_light_scatter_and_reflectance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../chapters/metal/a_scene_with_metal_spheres.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
